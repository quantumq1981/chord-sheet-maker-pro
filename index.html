<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ChordSheet CSMPN Builder v1.8.0</title>

<!-- Google Fonts: Patrick Hand SC for fake book title -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Patrick+Hand+SC&display=swap" rel="stylesheet">

<!-- PDF.js (required for UG Pro PDF text extraction) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- html2canvas for image/PDF capture -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- jsPDF for optional PDF export (print remains the primary PDF workflow) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- abcjs for ABC import parsing/mining -->
<script src="https://cdn.jsdelivr.net/npm/abcjs@6.2.2/dist/abcjs-basic-min.js"></script>

<style>
  :root{
    --bg:#f5f5f5;
    --card:#ffffff;
    --ink:#111111;
    --muted:#5b5b5b;
    --accent:#2563eb;
    --accent2:#111827;
    --border:#d9d9d9;
    --radius:14px;
    /* Fake Book configurable defaults */
    --fb-font-scale:1;
    --fb-line-spacing:8px;
    --fb-bars-per-row:4;
  }

  *{ box-sizing:border-box; }

  body{
    margin:0;
    font-family: Helvetica, Arial, "Helvetica Neue", sans-serif;
    background:var(--bg);
    color:var(--ink);
  }

  .app{
    max-width:1200px;
    margin:0 auto;
    padding:12px;
  }

  .topbar{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
    margin-bottom:12px;
  }

  .title{
    font-weight:800;
    font-size:20px;
    margin-bottom:10px;
  }

  .row{
    display:grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap:10px;
    margin-bottom:10px;
  }

  .field label{
    display:block;
    font-size:12px;
    color:var(--muted);
    margin-bottom:4px;
    font-weight:700;
  }
  .field input, .field select{
    width:100%;
    padding:10px 10px;
    border:1px solid var(--border);
    border-radius:10px;
    font-size:16px;
    background:#fff;
  }

  .btnrow{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    margin:10px 0 8px 0;
  }
  button{
    border:0;
    border-radius:12px;
    padding:12px 14px;
    font-weight:800;
    font-size:16px;
    cursor:pointer;
  }
  button.accent{ background:var(--accent); color:white; }
  button.secondary{ background:var(--accent2); color:white; }
  button.outline{
    background:transparent;
    color:var(--accent2);
    border:2px solid var(--border);
  }

  .tips{
    margin-top:8px;
    font-size:13px;
    color:var(--muted);
    line-height:1.35;
  }
  .tips ul{ margin:8px 0 0 18px; }

  .status{
    margin-top:10px;
    padding:10px 12px;
    border-radius:12px;
    background:#eef2ff;
    border:1px solid #c7d2fe;
    font-weight:700;
  }
  .status.warn{
    background:#fff7ed;
    border-color:#fdba74;
  }
  .status.err{
    background:#fef2f2;
    border-color:#fca5a5;
  }

  /* Settings panel */
  .settingsPanel{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
    margin-bottom:12px;
    display:none;
  }
  .settingsPanel.open{ display:block; }
  .settingsPanel h3{
    margin:0 0 10px 0;
    font-size:16px;
    font-weight:800;
  }
  .settingsGrid{
    display:grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap:10px;
  }
  .settingsGrid label{
    display:block;
    font-size:12px;
    color:var(--muted);
    margin-bottom:4px;
    font-weight:700;
  }
  .settingsGrid select{
    width:100%;
    padding:8px;
    border:1px solid var(--border);
    border-radius:8px;
    font-size:14px;
    background:#fff;
  }

  .grid{
    display:grid;
    grid-template-columns: 1fr;
    gap:12px;
  }

  .card{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
  }

  textarea{
    width:100%;
    min-height:320px;
    resize:vertical;
    padding:12px;
    border:1px solid var(--border);
    border-radius:12px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:14px;
    line-height:1.35;
    background:#fff;
  }

  .previewWrap{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
  }

  .sheet{
    background:#fff;
    border:1px solid #e5e5e5;
    border-radius:12px;
    padding:24px 28px;
    box-shadow: 0 1px 0 rgba(0,0,0,0.04);
    max-width: 8.5in;
    margin: 0 auto;
    font-family: Helvetica, Arial, "Helvetica Neue", sans-serif;
  }

  /* ===== Fake Book layout & typography ===== */
  .sheetHeader{
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    gap:16px;
    border-bottom:1.5px solid #111;
    padding-bottom:6px;
    margin-bottom:14px;
  }

  .headerInfo{
    display:flex;
    flex-direction:column;
    gap:2px;
  }

  .headerMeta{
    font-size:calc(13px * var(--fb-font-scale));
    font-style:italic;
    color:#222;
    font-family: Helvetica, Arial, sans-serif;
  }

  .songTitle{
    font-family: "Patrick Hand SC", "Georgia", cursive;
    font-size:calc(32px * var(--fb-font-scale));
    font-weight:400;
    margin:0;
    letter-spacing:0.02em;
    text-transform:uppercase;
    font-variant:small-caps;
    line-height:1.1;
  }

  .headerComposer{
    font-size:calc(13px * var(--fb-font-scale));
    font-weight:600;
    font-family: Helvetica, Arial, sans-serif;
  }

  .headerRight{
    text-align:right;
    min-width:80px;
    display:flex;
    flex-direction:column;
    align-items:flex-end;
    gap:2px;
  }

  .tempoLine{
    font-size:calc(16px * var(--fb-font-scale));
    font-weight:700;
    font-family: Helvetica, Arial, sans-serif;
  }

  .timeSig{
    font-size:calc(28px * var(--fb-font-scale));
    font-weight:700;
    font-family: Helvetica, Arial, sans-serif;
    line-height:1;
  }

  /* Section labels: rehearsal letter + section name */
  .sectionBlock{
    margin:calc(14px * var(--fb-font-scale)) 0 calc(2px * var(--fb-font-scale)) 0;
  }

  .rehearsalLetter{
    display:inline-block;
    border:2px solid #111;
    padding:1px 6px;
    border-radius:3px;
    font-size:calc(14px * var(--fb-font-scale));
    font-weight:700;
    font-family: Helvetica, Arial, sans-serif;
    margin-bottom:2px;
    line-height:1.3;
  }

  .sectionText{
    margin:2px 0 4px 0;
    font-size:calc(15px * var(--fb-font-scale));
    font-weight:700;
    font-family: Helvetica, Arial, sans-serif;
  }

  .labelBox{
    display:inline-block;
    border:1.5px solid #111;
    padding:1px 7px;
    border-radius:3px;
    font-size:calc(14px * var(--fb-font-scale));
    font-weight:700;
    font-family: Helvetica, Arial, sans-serif;
    line-height:1.3;
  }

  .dividerRow{
    display:flex;
    align-items:center;
    gap:12px;
    margin:14px 0 4px 0;
  }

  .dividerRow .rule{
    flex:1;
    height:1.5px;
    background:#111;
  }

  /* Dynamic barline grid: columns generated by JS based on bars-per-row setting */
  .barlineRow{
    display:grid;
    align-items:center;
    gap:0;
    margin: var(--fb-line-spacing) 0 0 0;
    padding-top:4px;
    position:relative;
  }

  /* Default 4-bar grid (overridden by inline style when bars-per-row changes) */
  .barlineRow{
    grid-template-columns: 14px minmax(0, 1fr) 14px minmax(0, 1fr) 14px minmax(0, 1fr) 14px minmax(0, 1fr) 14px;
  }

  .barline{
    position:relative;
    height:calc(2.4em * var(--fb-font-scale));
  }

  .barline::before,
  .barline::after{
    content:'';
    position:absolute;
    top:0;
    bottom:0;
    border-left:1.5px solid #111;
  }

  .barline.single::before{
    left:50%;
  }

  .barline.double::before{
    left:35%;
  }

  .barline.double::after{
    left:60%;
    border-left-width:3px;
  }

  .barline.final::before{
    left:35%;
  }

  .barline.final::after{
    left:60%;
    border-left-width:4px;
  }

  .barline.repeat-start::before{
    left:20%;
    border-left-width:4px;
  }

  .barline.repeat-start::after{
    left:45%;
    border-left-width:1.5px;
  }

  .barline.repeat-start .dot-top,
  .barline.repeat-start .dot-bot,
  .barline.repeat-end .dot-top,
  .barline.repeat-end .dot-bot{
    position:absolute;
    width:5px;
    height:5px;
    border-radius:50%;
    background:#111;
  }

  .barline.repeat-start .dot-top{
    right:0;
    top:calc(50% - 8px);
  }
  .barline.repeat-start .dot-bot{
    right:0;
    top:calc(50% + 4px);
  }

  .barline.repeat-end::before{
    left:55%;
    border-left-width:1.5px;
  }

  .barline.repeat-end::after{
    left:80%;
    border-left-width:4px;
  }

  .barline.repeat-end .dot-top{
    left:0;
    top:calc(50% - 8px);
  }
  .barline.repeat-end .dot-bot{
    left:0;
    top:calc(50% + 4px);
  }

  /* Hidden barlines mode */
  .barline.hidden::before,
  .barline.hidden::after{
    display:none;
  }

  .measure{
    display:flex;
    align-items:center;
    justify-content:flex-start;
    min-height:calc(2.4em * var(--fb-font-scale));
    padding:0 6px;
    white-space:nowrap;
  }

  .measure.center-align{
    justify-content:center;
  }

  .beats{
    display:inline-flex;
    gap:0.5em;
    align-items:baseline;
    flex-wrap:wrap;
  }

  .beat{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:2px;
  }

  .beatAnnotation{
    font-size:calc(11px * var(--fb-font-scale));
    font-style:italic;
    color:#111;
  }

  .chord{
    display:inline-flex;
    align-items:baseline;
    font-family: Helvetica, Arial, "Helvetica Neue", sans-serif;
    font-weight:700;
    font-size:calc(22px * var(--fb-font-scale));
    line-height:1;
  }

  .chord-root{
    font-weight:800;
    font-size:calc(24px * var(--fb-font-scale));
  }

  .chord-quality{
    font-size:calc(16px * var(--fb-font-scale));
    margin-left:1px;
    font-weight:700;
  }

  .chord-bass{
    font-size:calc(18px * var(--fb-font-scale));
    margin-left:1px;
    font-weight:700;
  }

  .chord-bass::before{
    content:"/";
    margin-right:1px;
  }

  .musicSymbol{
    font-size:calc(22px * var(--fb-font-scale));
    font-family: Helvetica, Arial, sans-serif;
  }

  .repeatSymbol{
    font-size:calc(26px * var(--fb-font-scale));
  }

  .endingBracket{
    grid-row:1;
    align-self:start;
    justify-self:stretch;
    margin-top:-14px;
    border-top:1.5px solid #111;
    height:12px;
    position:relative;
  }

  .endingBracket::before{
    content:'';
    position:absolute;
    left:0;
    top:-1.5px;
    height:12px;
    border-left:1.5px solid #111;
  }

  .endingLabel{
    position:absolute;
    top:-1px;
    left:4px;
    font-size:calc(11px * var(--fb-font-scale));
    font-weight:700;
    background:#fff;
    padding:0 3px;
    font-family: Helvetica, Arial, sans-serif;
  }

  .annotation{
    margin:6px 0;
    font-size:calc(14px * var(--fb-font-scale));
    color:#111;
    font-family: Helvetica, Arial, sans-serif;
  }

  /* Page footer */
  .sheetFooter{
    margin-top:24px;
    padding-top:8px;
    border-top:1px solid #ccc;
    display:flex;
    justify-content:space-between;
    font-size:11px;
    color:#888;
    font-family: Helvetica, Arial, sans-serif;
  }

  .pageBreak{ page-break-before: always; break-before: page; height:1px; }

  /* Desktop: side-by-side editor and preview */
  @media (min-width: 980px){
    .grid{ grid-template-columns: 1fr 1fr; }
    textarea{ min-height: 520px; }
    .previewWrap{ position: sticky; top: 12px; align-self: start; }
  }

/* Export fidelity: flatten UI chrome for PDF/PNG captures */
body.exporting .card{
  border: none !important;
  box-shadow: none !important;
  border-radius: 0 !important;
  padding: 0 !important;
  margin: 0 !important;
}
body.exporting #renderTarget{
  padding: 0 !important;
  margin: 0 !important;
  background: #fff !important;
}
body.exporting .sheet{
  padding: 36px 42px !important;
}

@media print{
    body{ background:white; }
    .topbar, .card.editorCard, .tips, .status, .btnrow, .settingsPanel { display:none !important; }
    .app{ max-width:none; padding:0; }
    .previewWrap{ border:0; padding:0; }
    .sheet{ border-radius:0; padding:24px 36px; box-shadow:none; }
    @page { size: letter; margin: 0.5in; }
    .sheet{ max-width:none; margin:0; border:0; }
  }
</style>
</head>

<body>
<div id="abc-hidden" style="display:none"></div>
<div class="app">
  <div class="topbar">
    <div class="title">ChordSheet CSMPN Builder v1.8.0 ‚Äî Fake Book Edition</div>

    <div class="row">
      <div class="field"><label>Title</label><input id="hdrTitle" placeholder="Song title"></div>
      <div class="field"><label>Composer / Artist</label><input id="hdrComposer" placeholder="Artist / composer"></div>
      <div class="field"><label>Key</label><input id="hdrKey" placeholder="e.g., Bb"></div>
      <div class="field"><label>Time</label><input id="hdrTime" placeholder="e.g., 4/4"></div>
      <div class="field"><label>Tempo</label><input id="hdrTempo" placeholder="e.g., 120"></div>
      <div class="field"><label>Style</label><input id="hdrStyle" placeholder="e.g., Swing"></div>
    </div>

    <div class="btnrow">
      <button class="accent" id="btnImport">Import File</button>
      <button class="secondary" id="btnTransposeDown">-1</button>
      <button class="secondary" id="btnTransposeUp">+1</button>
      <button class="secondary" id="btnTransposeReset">Reset</button>
      <button class="outline" id="btnSettings">Settings</button>
      <button class="accent" id="btnPrint">Print / PDF</button>
      <button class="secondary" id="btnDownloadPdf">Download PDF</button>
      <button class="secondary" id="btnPng">PNG</button>
      <button class="secondary" id="btnCopy">Copy</button>
      <button class="outline" id="btnExportChordPro">Export ChordPro</button>
      <button class="outline" id="btnSave">Save</button>
      <button class="outline" id="btnLoad">Load</button>
    </div>

    <div class="tips">
      <strong>Fake Book Style:</strong>
      <ul>
        <li>Each chord token = 1 bar. Use <code>_</code> for split bars (e.g., <code>Bb7_A7</code>).</li>
        <li>Section markers: <code>- Verse</code>, <code>: Chorus</code>, <code>= Bridge</code> with optional rehearsal letters.</li>
        <li>Repeats: <code>|:</code> and <code>:|</code>, or <code>(A B C D)x2</code>. Endings: <code>1. C D 2. E F</code>.</li>
        <li><code>%</code> = repeat bar. Use Settings to adjust font size, bars/row, line spacing, and chord styles.</li>
        <li><strong>Shortcuts:</strong> Ctrl+S Save, Ctrl+P Print, Ctrl+‚Üë/‚Üì Transpose.</li>
      </ul>
    </div>

    <div id="status" class="status">Ready. v1.8 ‚Äî Fake Book formatting.</div>

    <input id="fileInput" type="file" accept=".pdf,.txt,.xml,.musicxml,.abc" style="display:none" />
  </div>

  <!-- Fake Book Settings Panel -->
  <div id="settingsPanel" class="settingsPanel">
    <h3>Fake Book Settings</h3>
    <div class="settingsGrid">
      <div class="field">
        <label>Font Size</label>
        <select id="setFontSize">
          <option value="M" selected>Medium (default)</option>
          <option value="S">Small</option>
          <option value="XS">Extra-Small</option>
        </select>
      </div>
      <div class="field">
        <label>Bars Per Row</label>
        <select id="setBarsPerRow">
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4" selected>4 (default)</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="8">8</option>
        </select>
      </div>
      <div class="field">
        <label>Line Spacing</label>
        <select id="setLineSpacing">
          <option value="0">None</option>
          <option value="2">Tight (2)</option>
          <option value="4">Compact (4)</option>
          <option value="8" selected>Default (8)</option>
          <option value="12">Relaxed (12)</option>
          <option value="16">Open (16)</option>
        </select>
      </div>
      <div class="field">
        <label>Bar Lines</label>
        <select id="setBarLines">
          <option value="visible" selected>Visible (default)</option>
          <option value="hidden">Hidden</option>
        </select>
      </div>
      <div class="field">
        <label>Chord Alignment</label>
        <select id="setChordAlign">
          <option value="left" selected>Left (default)</option>
          <option value="center">Center</option>
        </select>
      </div>
      <div class="field">
        <label>Major 7th Style</label>
        <select id="setMaj7Style">
          <option value="ma" selected>ma7 (default)</option>
          <option value="maj">maj7</option>
          <option value="triangle">&#916;7</option>
        </select>
      </div>
      <div class="field">
        <label>Minor Chord Style</label>
        <select id="setMinorStyle">
          <option value="m" selected>m (default)</option>
          <option value="min">min</option>
          <option value="minus">&minus;</option>
        </select>
      </div>
      <div class="field">
        <label>Page Footer</label>
        <select id="setFooter">
          <option value="visible" selected>Visible (default)</option>
          <option value="hidden">Hidden</option>
        </select>
      </div>
    </div>
  </div>

  <div class="grid">
    <div class="card editorCard">
      <label>CSMPN Source (ChordSheet-compatible)</label>
      <textarea id="source"></textarea>
    </div>

    <div class="previewWrap">
      <div id="preview" class="sheet">
        <div style="color:#666; font-size:14px; text-align:center; padding: 40px 10px;">
          Import a file or paste CSMPN to preview.
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================================================
   Core constants / helpers
========================================================= */
const sourceEl = document.getElementById('source');
const previewEl = document.getElementById('preview');
const statusEl = document.getElementById('status');

// PDF.js worker config (required when loading PDF.js from a CDN on GitHub Pages)
if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
  try {
    if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    }
  } catch (e) {
    console.warn('pdf.js workerSrc assignment skipped:', e);
  }
}

const hdr = {
  title: document.getElementById('hdrTitle'),
  composer: document.getElementById('hdrComposer'),
  key: document.getElementById('hdrKey'),
  time: document.getElementById('hdrTime'),
  tempo: document.getElementById('hdrTempo'),
  style: document.getElementById('hdrStyle'),
};

let currentTranspose = 0;
let notationPreference = 'sharp';
let validationWarnings = [];

/* =========================================================
   Fake Book Settings State
========================================================= */
const fbSettings = {
  fontSize: 'M',       // M, S, XS
  barsPerRow: 4,       // 2-8
  lineSpacing: 8,      // 0, 2, 4, 8, 12, 16
  barLines: 'visible', // visible, hidden
  chordAlign: 'left',  // left, center
  maj7Style: 'ma',     // ma, maj, triangle
  minorStyle: 'm',     // m, min, minus
  footer: 'visible',   // visible, hidden
};

const FONT_SCALE_MAP = { M: 1, S: 0.85, XS: 0.72 };

/* Performance: persist settings to localStorage so users don't reconfigure each visit */
function saveFBSettings(){
  try { localStorage.setItem('csmpn_settings', JSON.stringify(fbSettings)); } catch(_){}
}
function loadFBSettings(){
  try {
    const saved = localStorage.getItem('csmpn_settings');
    if (saved){
      const parsed = JSON.parse(saved);
      for (const k of Object.keys(fbSettings)){
        if (parsed[k] !== undefined) fbSettings[k] = parsed[k];
      }
      // Sync UI controls
      const setEl = (id, val) => { const el = document.getElementById(id); if (el) el.value = val; };
      setEl('setFontSize', fbSettings.fontSize);
      setEl('setBarsPerRow', String(fbSettings.barsPerRow));
      setEl('setLineSpacing', String(fbSettings.lineSpacing));
      setEl('setBarLines', fbSettings.barLines);
      setEl('setChordAlign', fbSettings.chordAlign);
      setEl('setMaj7Style', fbSettings.maj7Style);
      setEl('setMinorStyle', fbSettings.minorStyle);
      setEl('setFooter', fbSettings.footer);
    }
  } catch(_){}
}

function applyFBSettings(){
  const root = document.documentElement;
  root.style.setProperty('--fb-font-scale', FONT_SCALE_MAP[fbSettings.fontSize] || 1);
  root.style.setProperty('--fb-line-spacing', fbSettings.lineSpacing + 'px');
  root.style.setProperty('--fb-bars-per-row', fbSettings.barsPerRow);
  _chordParseCache.clear(); // Invalidate cache when chord style settings change
  saveFBSettings();
  updatePreview();
}

// Wire settings controls
document.getElementById('btnSettings').addEventListener('click', () => {
  document.getElementById('settingsPanel').classList.toggle('open');
});

document.getElementById('setFontSize').addEventListener('change', (e) => {
  fbSettings.fontSize = e.target.value; applyFBSettings();
});
document.getElementById('setBarsPerRow').addEventListener('change', (e) => {
  fbSettings.barsPerRow = parseInt(e.target.value, 10); applyFBSettings();
});
document.getElementById('setLineSpacing').addEventListener('change', (e) => {
  fbSettings.lineSpacing = parseInt(e.target.value, 10); applyFBSettings();
});
document.getElementById('setBarLines').addEventListener('change', (e) => {
  fbSettings.barLines = e.target.value; applyFBSettings();
});
document.getElementById('setChordAlign').addEventListener('change', (e) => {
  fbSettings.chordAlign = e.target.value; applyFBSettings();
});
document.getElementById('setMaj7Style').addEventListener('change', (e) => {
  fbSettings.maj7Style = e.target.value; applyFBSettings();
});
document.getElementById('setMinorStyle').addEventListener('change', (e) => {
  fbSettings.minorStyle = e.target.value; applyFBSettings();
});
document.getElementById('setFooter').addEventListener('change', (e) => {
  fbSettings.footer = e.target.value; applyFBSettings();
});

/* ---- Performance: debounce helper ---- */
function debounce(fn, ms){
  let timer;
  return function(...args){
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), ms);
  };
}

function setStatus(msg, type='info'){
  // Back-compat: older call sites passed boolean (true=error)
  if (type === true) type = 'error';
  if (type === false) type = 'info';

  try{
    window.__csmpnLog = window.__csmpnLog || [];
    window.__csmpnLog.push({ t: new Date().toISOString(), type, msg: String(msg), ua: navigator.userAgent });
    // Keep last ~500 entries
    if (window.__csmpnLog.length > 500) window.__csmpnLog = window.__csmpnLog.slice(-500);
  }catch(e){}

  statusEl.textContent = msg;
  statusEl.classList.remove('err', 'warn');
  if (type === 'error') statusEl.classList.add('err');
  if (type === 'warning') statusEl.classList.add('warn');
}

function escapeHtml(s){
  return (s ?? '').toString()
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'","&#039;");
}

function safeFilename(name, fallback='chart'){
  const base = (name || fallback).toString().trim() || fallback;
  return base
    .replace(/[\\\/\:*?"<>|]+/g,'-')
    .replace(/\s+/g,' ')
    .trim()
    .slice(0, 80);
}

async function tryShareFile(file){
  try{
    if (navigator.canShare && navigator.canShare({ files: [file] })) {
      await navigator.share({ files: [file], title: file.name });
      return true;
    }
  }catch(_e){}
  return false;
}

function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.rel = 'noopener';
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}



function normalizeAccidentals(s){
  return (s ?? '')
    .replace(/‚ô≠/g,'b')
    .replace(/‚ôØ/g,'#')
    .replace(/\u00A0/g,' ')
    .trim();
}

class SongModel {
  constructor(){
    this.meta = {
      title: '',
      composer: '',
      style: '',
      key: '',
      tempo: '',
      time: ''
    };
    this.sections = [];
  }

  toCSMPN(options = {}){
    const barsPerRowRaw = Number(options?.barsPerRow ?? fbSettings?.barsPerRow ?? 4);
    const barsPerRow = Number.isFinite(barsPerRowRaw) && barsPerRowRaw > 0 ? Math.floor(barsPerRowRaw) : 4;
    const out = [];

    if (this.meta.title) out.push(`Title: ${this.meta.title}`);
    if (this.meta.composer) out.push(`Composer: ${this.meta.composer}`);
    if (this.meta.style) out.push(`Style: ${this.meta.style}`);
    if (this.meta.key) out.push(`Key: ${this.meta.key}`);
    if (this.meta.tempo) out.push(`Tempo: ${this.meta.tempo}`);
    if (this.meta.time) out.push(`Time: ${this.meta.time}`);

    if (out.length && this.sections.length) out.push('');

    for (const section of this.sections){
      const label = (section?.label || '').trim();
      if (label){
        const lead = label[0];
        out.push(lead === '-' || lead === ':' || lead === '=' ? label : `- ${label}`);
      }

      const bars = Array.isArray(section?.bars)
        ? section.bars.map((bar) => (bar ?? '').toString().trim()).filter(Boolean)
        : [];

      for (let i = 0; i < bars.length; i += barsPerRow){
        out.push(bars.slice(i, i + barsPerRow).join(' '));
      }
      if (bars.length) out.push('');
    }

    return out.join('\n').replace(/\n{3,}/g, '\n\n').trim();
  }
}

function mapMusicXMLFifthsToKey(fifthsValue, mode){
  const fifths = Number(fifthsValue);
  if (!Number.isFinite(fifths)) return '';
  const majorMap = {
    '-7':'Cb','-6':'Gb','-5':'Db','-4':'Ab','-3':'Eb','-2':'Bb','-1':'F',
    '0':'C','1':'G','2':'D','3':'A','4':'E','5':'B','6':'F#','7':'C#'
  };
  const minorMap = {
    '-7':'Abm','-6':'Ebm','-5':'Bbm','-4':'Fm','-3':'Cm','-2':'Gm','-1':'Dm',
    '0':'Am','1':'Em','2':'Bm','3':'F#m','4':'C#m','5':'G#m','6':'D#m','7':'A#m'
  };
  const isMinor = (mode || '').trim().toLowerCase() === 'minor';
  return isMinor ? (minorMap[String(fifths)] || '') : (majorMap[String(fifths)] || '');
}

/* =========================================================
   Phase-1 fixes: Header <-> Source bidirectional sync
========================================================= */
function extractHeaderFromText(text, writeToInputs=true){
  // Extracts header metadata from CSMPN-like source and (optionally) syncs the form fields.
  // Defensive: avoids poisoning header fields with chord lines / section labels.
  const norm = (s) => (s ?? "").toString()
    .replace(/\u00A0/g, " ")
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim();

  const looksChordy = (s) => {
    const t = norm(s);
    if (!t) return false;
    if (/[|«Å]/.test(t) || /%/.test(t)) return true;
    const toks = t.split(" ").filter(Boolean);
    let chordCount = 0;
    for (const tok of toks){
      if (isChordToken(tok)) chordCount++;
    }
    // If it contains multiple chord tokens, it's likely not a human header value.
    return chordCount >= 2;
  };

  const normalizeField = (field, raw) => {
    let v = norm(raw);
    if (!v) return "";
    // Strip stray trailing punctuation
    v = v.replace(/^[\-\u2013\u2014]+/, "").trim();

    if (field === "key"){
      // Accept common key spellings: Bb, F#, C#m, Abm, etc.
      v = v.replace(/\s+/g, "");
      v = v.replace(/minor$/i, "m").replace(/min$/i, "m");
      // Reject obviously bad values
      if (!/^[A-G](?:#|b)?(?:m)?$/i.test(v)) return "";
      return v;
    }
    if (field === "time"){
      v = v.replace(/\s+/g, "");
      if (!/^\d{1,2}\/\d{1,2}$/.test(v)) return "";
      return v;
    }
    if (field === "tempo"){
      const m = v.match(/(\d{1,3})/);
      if (!m) return "";
      const n = parseInt(m[1], 10);
      if (!(n >= 20 && n <= 320)) return "";
      return String(n);
    }

    // title/composer/style: reject chord-like garbage or label-only values
    if (/^(title|composer|artist|style|tempo|time|key)\s*:?$/i.test(v)) return "";
    if (looksChordy(v)) return "";
    // Cap ridiculous lengths (often PDF garbage)
    if (v.length > 120) v = v.slice(0, 120).trim();
    return v;
  };

  const getLineValue = (labelRe) => {
    const m = text.match(labelRe);
    return m ? m[1] : "";
  };

  const hdr = {
    title: normalizeField("title", getLineValue(/^\s*Title:\s*(.*)$/im)),
    composer: normalizeField("composer", getLineValue(/^\s*(?:Composer|Artist):\s*(.*)$/im)),
    style: normalizeField("style", getLineValue(/^\s*Style:\s*(.*)$/im)),
    tempo: normalizeField("tempo", getLineValue(/^\s*Tempo:\s*(.*)$/im)),
    time: normalizeField("time", getLineValue(/^\s*Time:\s*(.*)$/im)),
    key: normalizeField("key", getLineValue(/^\s*Key:\s*(.*)$/im)),
  };

  // If no explicit Title: and first non-empty line looks like a title, adopt it.
  if (!hdr.title){
    const first = (text.split(/\r?\n/).map(l => l.trim()).find(l => l) || "");
    // Avoid promoting section/marker lines (e.g., "- Intro", "= Verse") to Title.
    const looksLikeMarker = (s) => /^[-=:#;\[]\s*/.test((s||"").trim());
    if (first && !looksLikeMarker(first) && !first.includes(":") && !looksChordy(first) && first.length <= 80){
      hdr.title = normalizeField("title", first);
    }
  }

  if (writeToInputs){
    // Reference the outer-scope `hdr` DOM element map (defined at top of script).
    // The local `hdr` here holds extracted string values; the outer one holds <input> elements.
    const elMap = {
      title: document.getElementById('hdrTitle'),
      composer: document.getElementById('hdrComposer'),
      style: document.getElementById('hdrStyle'),
      tempo: document.getElementById('hdrTempo'),
      time: document.getElementById('hdrTime'),
      key: document.getElementById('hdrKey'),
    };
    for (const k of Object.keys(elMap)){
      const v = hdr[k] || "";
      if (elMap[k] && elMap[k].value !== v) elMap[k].value = v;
    }
  }
  return hdr;
}

function applyHeaderToText(){
  const lines = sourceEl.value.split(/\r?\n/);
  const meta = {
    Title: hdr.title.value.trim(),
    Composer: hdr.composer.value.trim(),
    Key: hdr.key.value.trim(),
    Time: hdr.time.value.trim(),
    Tempo: hdr.tempo.value.trim(),
    Style: hdr.style.value.trim(),
  };

  // remove existing meta lines
  const keep = [];
  for (const line of lines){
    if (/^(Title|Composer|Artist|Key|Time|Tempo|Style)\s*:/i.test(line.trim())) continue;
    keep.push(line);
  }

  const metaLines = [];
  if (meta.Title) metaLines.push(`Title: ${meta.Title}`);
  if (meta.Composer) metaLines.push(`Composer: ${meta.Composer}`);
  if (meta.Style) metaLines.push(`Style: ${meta.Style}`);
  if (meta.Tempo) metaLines.push(`Tempo: ${meta.Tempo}`);
  if (meta.Time) metaLines.push(`Time: ${meta.Time}`);
  if (meta.Key) metaLines.push(`Key: ${meta.Key}`);

  // ensure a blank line after headers if content exists
  const body = keep.join('\n').trimStart();
  const combined = metaLines.join('\n') + (metaLines.length ? '\n\n' : '') + body;

  sourceEl.value = combined.replace(/\n{3,}/g,'\n\n');
}

// readHeaderInputs: read current values from the header form fields.
function readHeaderInputs(){
  return {
    title: hdr.title.value.trim(),
    composer: hdr.composer.value.trim(),
    key: hdr.key.value.trim(),
    time: hdr.time.value.trim(),
    tempo: hdr.tempo.value.trim(),
    style: hdr.style.value.trim(),
  };
}

for (const k of Object.keys(hdr)){
  hdr[k].addEventListener('input', () => {
    applyHeaderToText();
    updatePreview();
  });
}

const _debouncedPreview = debounce(() => {
  extractHeaderFromText(sourceEl.value);
  updatePreview();
}, 150);

sourceEl.addEventListener('input', _debouncedPreview);

/* =========================================================
   CSMPN parsing
========================================================= */
function detectNotationPreferenceFromKeyOrText(key, text){
  const k = (key||'').toLowerCase();
  if (k.includes('b')) return 'flat';
  if (k.includes('#')) return 'sharp';
  // fallback: inspect chord tokens (require boundary to avoid matching words like "Above")
  if (/\b[A-G]b(?:[^a-z]|$)/m.test(text)) return 'flat';
  if (/\b[A-G]#/.test(text)) return 'sharp';
  return 'sharp';
}

// ---------------------------------------------------------
// Transposition helpers
// ---------------------------------------------------------
const NOTE_INDEX = new Map([
  ['C',0],['B#',0],
  ['C#',1],['DB',1],
  ['D',2],
  ['D#',3],['EB',3],
  ['E',4],['FB',4],
  ['F',5],['E#',5],
  ['F#',6],['GB',6],
  ['G',7],
  ['G#',8],['AB',8],
  ['A',9],
  ['A#',10],['BB',10],
  ['B',11],['CB',11],
]);

const NOTES_SHARP = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const NOTES_FLAT  = ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];

function transposeNote(note, semis, pref){
  const n = normalizeAccidentals(note).toUpperCase().replace(/\s+/g,'');
  const idx = NOTE_INDEX.get(n);
  if (idx === undefined) return note;

  const t = (idx + (semis % 12) + 12) % 12;
  const arr = (pref === 'flat') ? NOTES_FLAT : NOTES_SHARP;
  return arr[t];
}


function parseCSMPN(text){
  const raw = (text || '').replace(/\r/g,'');
  const lines = raw.split('\n');

  const doc = {
    title: '',
    composer: '',
    style: '',
    tempo: '',
    time: '',
    key: '',
    blocks: []
  };

  const metaRE = /^(Title|Composer|Artist|Style|Tempo|Time|Key)\s*:\s*(.*)$/i;

  // First pass: meta extraction
  const contentLines = [];
  for (const line of lines){
    const m = line.match(metaRE);
    if (m){
      const field = m[1].toLowerCase();
      const val = m[2].trim();
      if (field === 'title') doc.title = val;
      else if (field === 'composer' || field === 'artist') doc.composer = val;
      else if (field === 'style') doc.style = val;
      else if (field === 'tempo') doc.tempo = val;
      else if (field === 'time') doc.time = val;
      else if (field === 'key') doc.key = val;
      continue;
    }
    contentLines.push(line);
  }

  for (const line0 of contentLines){
    const line = line0.trim();
    if (!line) continue;

    // page break
    if (line.startsWith('+')){
      doc.blocks.push({type:'pagebreak'});
      continue;
    }

    // marker lines
    const lead = line[0];
    if (lead === '-' || lead === ':' || lead === '=' || lead === ';' || lead === '#'){
      doc.blocks.push({type:'marker', marker: lead, text: line.slice(1).trim()});
      continue;
    }

    // chord line
    const tokens = tokenizeBars(line0);
    if (tokens.length){
      doc.blocks.push({type:'bars', tokens});
    }
  }

  return doc;
}

function normalizeBarlineDelimiters(line){
  // Accept UG/ChordSheet barline characters and normalize for tokenization
  // «Å / ‚Äñ / ‚à• are treated as double barlines
  // Use placeholders to prevent cascade destruction of multi-char barlines
  return (line || '')
    .replace(/[«Å‚Äñ‚à•]/g, '||')
    .replace(/\|\|:/g, ' \x01RSTART\x01 ')
    .replace(/:\|\|/g, ' \x01REND2\x01 ')
    .replace(/\|:/g, ' \x01RSINGLE\x01 ')
    .replace(/:\|/g, ' \x01REND1\x01 ')
    .replace(/\|\]/g, ' \x01FINAL\x01 ')
    .replace(/\|\|/g, ' \x01DOUBLE\x01 ')
    .replace(/\|/g, ' | ')
    .replace(/\x01RSTART\x01/g, '||:')
    .replace(/\x01REND2\x01/g, ':||')
    .replace(/\x01RSINGLE\x01/g, '|:')
    .replace(/\x01REND1\x01/g, ':|')
    .replace(/\x01FINAL\x01/g, '|]')
    .replace(/\x01DOUBLE\x01/g, '||')
    .replace(/\s+/g, ' ')
    .trim();
}


function normalizeUGProText(text){
  // Normalizes Ultimate Guitar / UG Pro text exports.
  let t = (text ?? "").toString();
  t = t.replace(/\r\n?/g, "\n");
  t = t.replace(/\u00A0/g, " ");
  t = t.replace(/[\u200B-\u200D\uFEFF]/g, ""); // zero-width
  // Normalize "times" repeat phrasing to xN
  t = t.replace(/\b(times)\s*(two|2)\b/gi, "x2");
  t = t.replace(/\b(times)\s*(three|3)\b/gi, "x3");
  t = t.replace(/\b(times)\s*(four|4)\b/gi, "x4");
  // Normalize unicode bars
  t = t.replace(/[«Å‚à•]/g, "||");
  // Collapse duplicate repeat tokens
  t = t.replace(/\b(x[234])(\s+\1)+\b/gi, "$1");
  // UG sometimes emits "x2 x2)" etc
  t = t.replace(/(\)\s*)\b(x[234])\b\s*\b\2\b/gi, "$1$2");
  // Normalize common quote types
  t = t.replace(/[‚Äú‚Äù]/g, "\"").replace(/[‚Äò‚Äô]/g, "'");
  return t.trim();
}

function tokenizeBars(line){
  // tokenization: keep quoted annotations intact; also supports UG-style barlines
  const s = normalizeBarlineDelimiters(line);
  if (!s) return [];
  const out = [];
  let cur = '';
  let inQuote = false;

  for (let i=0;i<s.length;i++){
    const ch = s[i];
    if (ch === '"'){
      inQuote = !inQuote;
      cur += ch;
      continue;
    }
    if (!inQuote && /\s/.test(ch)){
      if (cur){
        out.push(cur);
        cur = '';
      }
      continue;
    }
    cur += ch;
  }
  if (cur) out.push(cur);

  // If any token still contains barlines (rare PDF extraction cases), explode them.
  const exploded = [];
  for (const t of out){
    if (t.includes('|') && !isBarlineToken(t)){
      let buf = '';
      let i = 0;
      while (i < t.length){
        if (t[i] === '|'){
          if (buf){ exploded.push(buf); buf=''; }
          if (i+1 < t.length && t[i+1] === '|'){
            exploded.push('||'); i += 2; continue;
          } else {
            exploded.push('|'); i += 1; continue;
          }
        }
        buf += t[i];
        i++;
      }
      if (buf) exploded.push(buf);
    } else {
      exploded.push(t);
    }
  }

  return exploded;
}

function isBarlineToken(tok){
  return ['|', '||', '|:', ':|', '||:', ':||', '|]'].includes(tok);
}

function mapBarlineToken(tok){
  switch (tok){
    case '||':
      return 'double';
    case '|:':
    case '||:':
      return 'repeat-start';
    case ':|':
    case ':||':
      return 'repeat-end';
    case '|]':
      return 'final';
    default:
      return 'single';
  }
}

function transposeChordToken(tok, semis, pref){
  // structural tokens
  if (!tok) return tok;
  const upper = tok.toUpperCase();
  if (tok === '%' || tok === '%%' || /^%\d+$/.test(tok)) return tok;
  if (tok === '*' || isBarlineToken(tok)) return tok;
  if (upper === 'N.C.' || upper === 'NC') return tok;
  if (/^\d+\.$/.test(tok)) return tok; // endings marker token itself
  if (tok.startsWith('"') && tok.endsWith('"')) return tok; // annotation token

  // handle repeats: keep punctuation
  const mRepeat = tok.match(/^(\()?(.*?)(\))?(x\d+)?$/);
  if (!mRepeat) return tok;

  const preL = mRepeat[1] || '';
  let core = mRepeat[2] || '';
  const preR = mRepeat[3] || '';
  const rep  = mRepeat[4] || '';

  // split by underscores, commas
  const parts = core.split('_').map(seg => {
    return seg.split(',').map(piece => transposeChordSimple(piece, semis, pref)).join(',');
  }).join('_');

  return preL + parts + preR + rep;
}

function transposeChordSimple(ch, semis, pref){
  const s = ch.trim();
  if (!s) return s;
  // allow directives embedded
  const upper = s.toUpperCase();
  if (upper === 'N.C.' || upper === 'NC') return s;

  const prefix = ['$', 'o', 'O'].includes(s[0]) ? s[0] : '';
  const body = prefix ? s.slice(1) : s;

  const m = body.match(/^([A-G])([b#]?)(.*?)(?:\/([A-G])([b#]?))?$/);
  if (!m) return s;

  const root = m[1] + (m[2]||'');
  const qual = m[3]||'';
  const bass = m[4] ? (m[4] + (m[5]||'')) : '';

  const trRoot = transposeNote(root, semis, pref);
  const trBass = bass ? transposeNote(bass, semis, pref) : '';

  const transposed = trBass ? `${trRoot}${qual}/${trBass}` : `${trRoot}${qual}`;
  return `${prefix}${transposed}`;
}

function transposeWholeText(text, semis){
  const keyMatch = text.match(/^Key:\s*(.+)$/im);
  const key = keyMatch ? keyMatch[1].trim() : '';
  const pref = detectNotationPreferenceFromKeyOrText(key, text);

  const lines = text.split(/\r?\n/);
  const out = [];
  for (const line of lines){
    const m = line.match(/^Key:\s*(.+)$/i);
    if (m){
      const oldKey = m[1].trim();
      const trKey = transposeChordSimple(oldKey, semis, pref);
      out.push(`Key: ${trKey}`);
      continue;
    }

    // preserve marker lines and meta lines except chord payload
    if (/^(Title|Composer|Artist|Style|Tempo|Time)\s*:/i.test(line.trim())){
      out.push(line);
      continue;
    }
    const trimmed = line.trim();
    if (!trimmed){
      out.push(line);
      continue;
    }

    // marker lines
    if (/^[-:=;#\+]/.test(trimmed)){
      out.push(line);
      continue;
    }

    // chord lines: transpose tokens
    const tokens = tokenizeBars(line);
    const t2 = tokens.map(tok => transposeChordToken(tok, semis, pref));
    out.push(t2.join(' '));
  }
  return out.join('\n');
}

/* =========================================================
   Q1 FIX: Repeat Expansion Logic (CRITICAL)
   Expands repeat groups fully to maintain 4-bar-per-row grid
========================================================= */
function parseBarStructures(tokens){
  // Returns flat array of bar objects after expanding repeats.
  // Also consumes UG-style barline tokens: '|' (single) and repeat/final variants.
  const out = [];
  let i = 0;

  let pendingLeft = null;

  const setBoundary = (type) => {
    const prev = out[out.length - 1];
    if (prev && type !== 'repeat-start'){
      prev.rightBar = type;
    }
    pendingLeft = type === 'repeat-end' || type === 'final' ? null : type;
  };

  const readTimes = (tok) => {
    const m = (tok || '').match(/x(\d+)$/i);
    return m ? parseInt(m[1],10) : null;
  };

  const skipBarlines = () => {
    while (i < tokens.length && isBarlineToken(tokens[i])){
      setBoundary(mapBarlineToken(tokens[i]));
      i++;
    }
  };

  while (i < tokens.length){
    let tok = tokens[i];

    if (isBarlineToken(tok)){
      setBoundary(mapBarlineToken(tok));
      i++;
      continue;
    }

    if (/^".*"$/.test(tok) && out.length){
      const prev = out[out.length - 1];
      prev.token = `${prev.token || ''} ${tok}`.trim();
      i++;
      continue;
    }

    // Endings token - associate with next bar (skipping delimiters)
    if (/^\d+\.$/.test(tok)){
      const endingLabel = tok;
      i++;
      skipBarlines();
      if (i < tokens.length){
        const nextTok = tokens[i];
        out.push({
          type:'bar',
          token: nextTok,
          endingLabel,
          leftBar: pendingLeft || 'single',
          rightBar: 'single',
        });
        pendingLeft = null;
        i++;
      }
      continue;
    }

    // Repeat group ( ... )xN
    if (tok.startsWith('(')){
      const groupTokens = [];
      let times = 2;
      let closed = false;

      tok = tok.slice(1);
      if (tok) groupTokens.push(tok);

      i++;
      while (i < tokens.length){
        const t = tokens[i];

        if (isBarlineToken(t)){ i++; continue; }

        if (t.endsWith(')') || /\)x\d+$/i.test(t)){
          const before = t.replace(/\)x\d+$/i,'').replace(/\)$/,'');
          const after = t.match(/\)x(\d+)$/i);
          if (before) groupTokens.push(before);
          if (after) times = parseInt(after[1],10);
          const tIn = readTimes(before) || readTimes(t) || null;
          if (tIn) times = tIn;
          closed = true;
          i++;
          break;
        } else {
          groupTokens.push(t);
          i++;
        }
      }

      if (!closed){
        validationWarnings.push(`‚ö†Ô∏è Unclosed repeat parenthesis - auto-closing`);
      }

      for (let rep=0; rep<times; rep++){
        for (const gt of groupTokens){
          out.push({
            type:'bar',
            token: gt,
            leftBar: pendingLeft || 'single',
            rightBar: 'single',
          });
          pendingLeft = null;
        }
      }
      continue;
    }

    out.push({
      type:'bar',
      token: tok,
      leftBar: pendingLeft || 'single',
      rightBar: 'single',
    });
    pendingLeft = null;
    i++;
  }

  return out;
}


/* =========================================================
   Rendering (ChordSheet-style only)
========================================================= */
function formatChordQuality(quality){
  if (!quality) return '';
  let q = quality;

  // Half-diminished: m7b5 or √∏
  if (/^m7b5$/i.test(q) || /^√∏/i.test(q)){
    return '√∏7';
  }

  // Diminished
  q = q.replace(/^dim/i, '¬∞');

  // Augmented
  q = q.replace(/^aug/i, '+');

  // Major 7th / extended major chords - respect settings (require numeric extension)
  const maj7Re = /^(maj|ma|Œî)(\d.*)$/i;
  const maj7Match = q.match(maj7Re);
  if (maj7Match){
    const suffix = maj7Match[2] || '';
    if (fbSettings.maj7Style === 'triangle'){
      return 'Œî' + suffix;
    } else if (fbSettings.maj7Style === 'maj'){
      return 'maj' + suffix;
    } else {
      return 'MA' + suffix;
    }
  }

  // Minor chord - respect settings
  // Match minor at start: m, min, mi (but not maj)
  const minRe = /^(min|mi|m)(\d.*|$)/i;
  const minMatch = q.match(minRe);
  if (minMatch && !/^ma/i.test(q)){
    const suffix = minMatch[2] || '';
    if (fbSettings.minorStyle === 'min'){
      return 'min' + suffix;
    } else if (fbSettings.minorStyle === 'minus'){
      return '‚àí' + suffix;
    } else {
      return 'm' + suffix;
    }
  }

  return q;
}

/* Performance: memoize chord parsing ‚Äî same token returns cached result */
const _chordParseCache = new Map();
const CHORD_CACHE_MAX = 512;

function parseChordToken(token){
  const raw = token || '';
  const cacheKey = raw + '|' + fbSettings.maj7Style + '|' + fbSettings.minorStyle;
  if (_chordParseCache.has(cacheKey)) return _chordParseCache.get(cacheKey);

  const normalized = normalizeAccidentals(raw);
  const match = normalized.match(/^([A-G])([b#]?)(.*?)(?:\/([A-G])([b#]?))?$/);
  if (!match){ _chordParseCache.set(cacheKey, null); return null; }
  const root = match[1] + (match[2] || '');
  const quality = match[3] || '';
  const bass = match[4] ? (match[4] + (match[5] || '')) : '';
  const displayRoot = root.replace(/b/g, '‚ô≠').replace(/#/g, '‚ôØ');
  const displayBass = bass.replace(/b/g, '‚ô≠').replace(/#/g, '‚ôØ');
  const result = {
    root: displayRoot,
    quality: formatChordQuality(quality),
    bass: displayBass,
  };
  if (_chordParseCache.size > CHORD_CACHE_MAX) _chordParseCache.clear();
  _chordParseCache.set(cacheKey, result);
  return result;
}

function renderChordToken(token){
  const parsed = parseChordToken(token);
  if (!parsed) return `<span class="chord">${escapeHtml(token)}</span>`;
  const quality = parsed.quality ? `<span class="chord-quality">${escapeHtml(parsed.quality)}</span>` : '';
  const bass = parsed.bass ? `<span class="chord-bass">${escapeHtml(parsed.bass)}</span>` : '';
  return `<span class="chord"><span class="chord-root">${escapeHtml(parsed.root)}</span>${quality}${bass}</span>`;
}

function renderBeatContent(rawBeat){
  const beat = (rawBeat || '').trim();
  if (!beat) return `<span class="beat"><span class="chord">&nbsp;</span></span>`;

  const annotationMatch = beat.match(/"([^"]+)"/);
  const annotation = annotationMatch ? annotationMatch[1] : '';
  const beatWithoutAnnotation = beat.replace(/"[^"]+"/g, '').trim();

  const renderSymbol = (symbol) => `<span class="musicSymbol">${symbol}</span>`;
  const symbolMap = {
    '$': 'ùÑã',
    'segno': 'ùÑã',
    'o': 'ùÑå',
    'O': 'ùÑå',
    'coda': 'ùÑå',
    'fermata': 'ùÑê',
  };

  let chordHtml = '';
  const normalizedBeat = beatWithoutAnnotation.trim();
  const prefixSymbol = normalizedBeat[0];
  const trailingChord = normalizedBeat.slice(1).trim();

  if (!normalizedBeat){
    chordHtml = `<span class="chord">&nbsp;</span>`;
  } else if (normalizedBeat === '%'){
    chordHtml = `<span class="musicSymbol repeatSymbol">ùÑé</span>`;
  } else if (normalizedBeat === '%%'){
    chordHtml = `<span class="musicSymbol repeatSymbol">ùÑè</span>`;
  } else if (symbolMap[normalizedBeat]){
    chordHtml = renderSymbol(symbolMap[normalizedBeat]);
  } else if (symbolMap[prefixSymbol] && trailingChord){
    chordHtml = `${renderSymbol(symbolMap[prefixSymbol])}${renderChordToken(trailingChord)}`;
  } else if (normalizedBeat.toUpperCase() === 'N.C.' || normalizedBeat.toUpperCase() === 'NC'){
    chordHtml = `<span class="chord">${escapeHtml(normalizedBeat)}</span>`;
  } else if (normalizedBeat.toLowerCase() === 'fine'){
    chordHtml = `<span class="musicSymbol"><em>fine</em></span>`;
  } else if (normalizedBeat.toLowerCase().startsWith('d.s')){
    chordHtml = `<span class="musicSymbol"><em>${escapeHtml(normalizedBeat)}</em></span>`;
  } else {
    chordHtml = renderChordToken(normalizedBeat);
  }

  const annotationHtml = annotation ? `<span class="beatAnnotation">${escapeHtml(annotation)}</span>` : '';
  return `<span class="beat">${annotationHtml}${chordHtml}</span>`;
}

function renderBarline(type){
  const t = type || 'single';
  const hidden = fbSettings.barLines === 'hidden' && t === 'single';
  const cls = hidden ? 'barline hidden' : `barline ${t}`;
  if (t === 'repeat-start' || t === 'repeat-end'){
    return `<div class="${cls}"><span class="dot-top"></span><span class="dot-bot"></span></div>`;
  }
  return `<div class="${cls}"></div>`;
}

function renderEndingSegments(segments){
  return segments.map((segment) => {
    const startCol = 2 + segment.start * 2;
    const endCol = 2 + segment.end * 2 + 1;
    return `
      <div class="endingBracket" style="grid-column:${startCol} / ${endCol};">
        <span class="endingLabel">${escapeHtml(segment.label)}.</span>
      </div>`;
  }).join('');
}

// Track rehearsal letters for auto-assignment
let rehearsalLetterIndex = 0;
const REHEARSAL_LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

function renderTimeSig(timeStr){
  // Render time signature as stacked fraction-style
  const m = (timeStr || '').match(/^(\d+)\/(\d+)$/);
  if (!m) return `<div class="timeSig">${escapeHtml(timeStr)}</div>`;
  return `<div class="timeSig" style="display:flex;flex-direction:column;align-items:center;line-height:0.95;font-size:calc(24px * var(--fb-font-scale));">
    <span>${escapeHtml(m[1])}</span>
    <span>${escapeHtml(m[2])}</span>
  </div>`;
}

function renderDoc(doc){
  validationWarnings = [];
  rehearsalLetterIndex = 0;

  let html = '';
  if (doc.title || doc.style || doc.key || doc.time || doc.tempo || doc.composer){
    // ChordSheet.com style: annotation line in parentheses above title
    const metaBits = [];
    if (doc.style) metaBits.push(doc.style);
    if (doc.key) metaBits.push(`Key of ${doc.key}`);
    const metaStr = metaBits.length ? metaBits.join(', ') : '';
    const metaLine = metaStr ? `<div class="headerMeta">(${escapeHtml(metaStr)})</div>` : '';
    const composerLine = doc.composer ? `<div class="headerComposer">${escapeHtml(doc.composer)}</div>` : '';
    const tempoLine = doc.tempo ? `<div class="tempoLine">‚ô©=${escapeHtml(doc.tempo)}</div>` : '';
    const timeSig = doc.time ? renderTimeSig(doc.time) : '';
    html += `
      <div class="sheetHeader">
        <div class="headerInfo">
          ${metaLine}
          ${doc.title ? `<div class="songTitle">${escapeHtml(doc.title)}</div>` : ''}
          ${composerLine}
        </div>
        <div class="headerRight">
          ${tempoLine}
          ${timeSig}
        </div>
      </div>`;
  }

  for (const block of doc.blocks){
    if (block.type === 'pagebreak'){
      html += `<div class="pageBreak"></div>`;
      continue;
    }
    if (block.type === 'marker'){
      html += renderSectionMarker(block);
      continue;
    }
    if (block.type === 'bars'){
      html += renderBars(block.tokens);
      continue;
    }
  }

  if (!doc.blocks.length){
    html += `<div style="color:#666; font-size:14px; text-align:center; padding: 40px 10px;">
      Import a file or paste CSMPN to preview.
    </div>`;
  }

  // Page footer
  if (fbSettings.footer === 'visible' && doc.blocks.length){
    const now = new Date().toISOString().slice(0,10);
    const pageBreaks = doc.blocks.filter(b => b.type === 'pagebreak').length;
    const totalPages = pageBreaks + 1;
    html += `<div class="sheetFooter">
      <span>ChordSheet CSMPN Builder</span>
      <span>page 1 of ${totalPages}</span>
      <span>last edited ${now}</span>
    </div>`;
  }

  if (validationWarnings.length){
    const warnMsg = validationWarnings.join('\n');
    setStatus(warnMsg, 'warning');
  }

  return html;
}

function renderSectionMarker(block){
  const t = escapeHtml(block.text || '');

  if (block.marker === '-' || block.marker === ':'){
    // Fake book style: show rehearsal letter + section name in label boxes
    const letter = REHEARSAL_LETTERS[rehearsalLetterIndex] || '';
    rehearsalLetterIndex++;
    let letterHtml = letter ? `<span class="rehearsalLetter">${letter}</span><br>` : '';
    return `<div class="sectionBlock">${letterHtml}<span class="labelBox">${t}</span></div>`;
  }

  if (block.marker === '='){
    // Section divider with label - show as = label
    const letter = REHEARSAL_LETTERS[rehearsalLetterIndex] || '';
    rehearsalLetterIndex++;
    let letterHtml = letter ? `<span class="rehearsalLetter">${letter}</span><br>` : '';
    return `<div class="sectionBlock">${letterHtml}<span class="labelBox">${t}</span></div>`;
  }

  if (block.marker === ';'){
    return `<div class="annotation">${t}</div>`;
  }
  if (block.marker === '#'){
    return `<div class="annotation"><span style="font-size:0.85em">#</span> ${t}</div>`;
  }
  return '';
}

/* Performance: cache grid templates ‚Äî only 7 possible values (2-8 bars) */
const _gridTemplateCache = {};
function buildGridTemplate(barsPerRow){
  if (_gridTemplateCache[barsPerRow]) return _gridTemplateCache[barsPerRow];
  const cols = ['14px'];
  for (let i = 0; i < barsPerRow; i++){
    cols.push('minmax(0, 1fr)');
    cols.push('14px');
  }
  const result = cols.join(' ');
  _gridTemplateCache[barsPerRow] = result;
  return result;
}

function renderBars(tokens){
  const bars = parseBarStructures(tokens);
  const bpr = fbSettings.barsPerRow;
  const gridTemplate = buildGridTemplate(bpr);
  const alignClass = fbSettings.chordAlign === 'center' ? ' center-align' : '';

  let html = `<div class="barsBlock">`;
  let activeEnding = null;

  for (let i = 0; i < bars.length; i += bpr){
    const row = bars.slice(i, i + bpr);

    // Pad to barsPerRow
    while (row.length < bpr){
      row.push({ token: '', leftBar: 'single', rightBar: 'single' });
    }

    const segments = [];
    let currentLabel = activeEnding;
    let startIndex = currentLabel ? 0 : null;

    row.forEach((bar, idx) => {
      if (bar.endingLabel){
        if (currentLabel !== null && idx > 0){
          segments.push({ label: currentLabel, start: startIndex, end: idx - 1 });
        }
        currentLabel = bar.endingLabel.replace('.', '').trim();
        startIndex = idx;
      }
    });
    if (currentLabel !== null && startIndex !== null){
      segments.push({ label: currentLabel, start: startIndex, end: row.length - 1 });
    }
    activeEnding = currentLabel;
    if (row.some((bar) => ['repeat-end', 'final'].includes(bar.rightBar))){
      activeEnding = null;
    }

    html += `<div class="barlineRow" style="grid-template-columns:${gridTemplate}">`;
    html += renderBarline(row[0]?.leftBar || 'single');

    row.forEach((bar) => {
      html += renderMeasure(bar.token || '', alignClass);
      html += renderBarline(bar.rightBar || 'single');
    });

    html += renderEndingSegments(segments);
    html += `</div>`;
  }

  html += `</div>`;
  return html;
}

function renderMeasure(measureText, alignClass){
  const cls = alignClass || '';
  const raw = (measureText || '').trim();
  if(!raw){
    return `<div class="measure${cls}"><div class="beats"><span class="beat"></span></div></div>`;
  }
  const beats = raw.split('_').map(s => s.trim()).filter(Boolean);
  const beatHtml = (beats.length ? beats : [raw]).map((b) => renderBeatContent(b)).join('');
  return `<div class="measure${cls}"><div class="beats">${beatHtml}</div></div>`;
}


function updatePreview(){
  const text = sourceEl.value || '';
  const keyMatch = text.match(/^Key:\s*(.+)$/im);
  const key = keyMatch ? keyMatch[1].trim() : '';
  notationPreference = detectNotationPreferenceFromKeyOrText(key, text);

  const doc = parseCSMPN(text);
  previewEl.innerHTML = renderDoc(doc);
}

/* =========================================================
   Q3 FIX: Enhanced PDF Import with X-Coordinate Clustering
   Detects split bars using spatial positioning
========================================================= */
const fileInput = document.getElementById('fileInput');

document.getElementById('btnImport').addEventListener('click', () => {
  fileInput.value = '';
  fileInput.click();
});

fileInput.addEventListener('change', async () => {
  const file = fileInput.files && fileInput.files[0];
  if (!file) return;
  try{
    setStatus(`Importing ${file.name}...`);
    const name = file.name.toLowerCase();
    const type = (file.type || '').toLowerCase();

    if (name.endsWith('.pdf')){
      const csmpn = await importUGProPDF(file);
      sourceEl.value = csmpn;
      extractHeaderFromText(csmpn);
      updatePreview();
      return;
    }

    const text = await file.text();

    if (name.endsWith('.abc') || (type.includes('text/plain') && /(^|\n)\s*K\s*:/i.test(text))){
      try {
        const song = mineABCToSongModel(text);
        const csmpn = song.toCSMPN({ barsPerRow: fbSettings.barsPerRow });
        sourceEl.value = csmpn;
        extractHeaderFromText(csmpn);
        updatePreview();
        setStatus('Imported ABC.');
      } catch (abcErr) {
        console.warn(abcErr);
        setStatus(`ABC import failed: ${abcErr?.message || abcErr}`, 'error');
        throw abcErr;
      }
      return;
    }

    if (name.endsWith('.musicxml') || name.endsWith('.xml') || type.includes('musicxml') || type.includes('xml')){
      const song = importMusicXML(text);
      if (song instanceof SongModel){
        const csmpn = song.toCSMPN({ barsPerRow: fbSettings.barsPerRow });
        sourceEl.value = csmpn;
        extractHeaderFromText(csmpn);
        updatePreview();
        setStatus('Imported MusicXML.');
      }
      return;
    }

    // txt
    const csmpn = detectChordPro(text) ? importChordPro(text) : importUGText(text);
    sourceEl.value = csmpn;
    extractHeaderFromText(csmpn);
    updatePreview();
    setStatus('Imported text.');
  }catch(err){
    console.error(err);
    if (!String(err?.message || '').startsWith('ABC import failed:')){
      setStatus(`Import failed: ${err?.message || err}`, 'error');
    }
  }
});

function detectChordPro(text){
  return /\{\s*(title|key|tempo|time)\s*:/i.test(text);
}

function importUGText(text){
  // UG Pro TXT exports can be noisy: headers, blank lines, "times two", duplicate repeats, etc.
  // Goal: produce chord-only CSMPN with 4 bars per line, preserving repeat intent when explicit.
  text = (text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");

  const repeatTokenToN = (t) => {
    if (!t) return null;
    const s = String(t).trim();
    let m = s.match(/^\(\s*x\s*(\d+)\s*\)$/i); // (x2)
    if (m) return parseInt(m[1], 10);
    m = s.match(/^x\s*(\d+)$/i); // x2
    if (m) return parseInt(m[1], 10);
    m = s.match(/^(\d+)\s*x$/i); // 2x
    if (m) return parseInt(m[1], 10);
    return null;
  };

  const parseTimesPhrase = (tokens) => {
    if (!tokens || tokens.length < 2) return null;
    if (String(tokens[0]).toLowerCase() !== "times") return null;
    const v = String(tokens[1]).toLowerCase();
    const map = {one:1,two:2,three:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10};
    if (v in map) return map[v];
    if (/^\d+$/.test(v)) return parseInt(v, 10);
    return null;
  };

  const lines = text.split("\n").map(l => l.trim()).filter(Boolean);

  const out = [];
  for (const line of lines){
    const raw = line.trim();
    if (!raw) continue;

    // Section headings: common UG / chord dump patterns
    let m = raw.match(/^\[(.+?)\]$/); // [Chorus]
    if (m){ out.push(`= ${m[1].trim()}`); continue; }
    m = raw.match(/^([-=])\s*(.+)$/); // - Intro / = Verse (preserve marker type)
    if (m){ out.push(`${m[1]} ${m[2].trim()}`); continue; }
    m = raw.match(/^(#{1,6})\s*(.+)$/); // Markdown
    if (m){ out.push(`= ${m[2].trim()}`); continue; }

    // Standalone repeat marker line applies to previous chord line
    const standaloneN = repeatTokenToN(raw) || parseTimesPhrase(raw.split(/\s+/));
    if (standaloneN && out.length){
      const prev = (out[out.length-1] || "").trim();
      if (prev && !/^[=:#;]/.test(prev) && !/^\(.*\)x\d+$/i.test(prev)){
        out[out.length-1] = `(${prev})x${standaloneN}`;
      }
      continue;
    }

    // Tokenize
    let toks = raw.split(/\s+/).filter(Boolean);

    // Strip common UG "times N" that can appear after a chord line
    let repeatN = repeatTokenToN(toks[toks.length-1]);
    if (!repeatN && toks.length >= 2){
      repeatN = parseTimesPhrase(toks.slice(-2));
    }

    // Remove trailing repeat tokens from chord candidates
    if (repeatN){
      if (repeatTokenToN(toks[toks.length-1])) toks = toks.slice(0, -1);
      else if (parseTimesPhrase(toks.slice(-2))) toks = toks.slice(0, -2);
    }

    // Determine if this is chord-dominant
    const chordLike = toks.reduce((acc,t)=>acc + (isChordLikeToken(t) ? 1 : 0), 0);
    if (!toks.length || (chordLike / toks.length) < 0.6) continue;

    // Normalize chords
    const chords = toks.map(t => normalizeChordToken(t)).filter(Boolean);
    if (!chords.length) continue;

    // Convert to 4-bars-per-line CSMPN; if repeatN is present, wrap as a single repeat block
    let block = toCSMPNBars(chords).trim();
    if (repeatN && repeatN > 1){
      // Collapse newlines inside the repeat block for safer syntax: (A B C D)x2
      block = block.replace(/\n+/g, " ").trim();
      out.push(`(${block})x${repeatN}`);
    } else {
      out.push(block);
    }
  }

  return out.join("\n").trim();
}

function importChordPro(text){
  const lines = text.replace(/\r/g,'').split('\n');
  const out = [];
  for (const line0 of lines){
    const line = normalizeAccidentals(line0);

    // directives
    const m = line.match(/^\{\s*([a-z_]+)\s*:\s*(.*?)\s*\}$/i);
    if (m){
      const k = m[1].toLowerCase();
      const v = m[2].trim();
      if (k === 'title') out.unshift(`Title: ${v}`);
      if (k === 'composer' || k === 'artist') out.unshift(`Composer: ${v}`);
      if (k === 'key') out.unshift(`Key: ${v}`);
      if (k === 'time') out.unshift(`Time: ${v}`);
      if (k === 'tempo') out.unshift(`Tempo: ${v}`);
      continue;
    }
    if (!line.trim()) continue;

    // section markers
    const sectionMatch = line.trim().match(/^\{\s*start_of_(chorus|verse|bridge)\s*\}$/i);
    if (sectionMatch){
      out.push(`: ${sectionMatch[1].toUpperCase()}`);
      continue;
    }

    // extract chords in []
    const chords = [];
    const re = /\[([^\]]+)\]/g;
    let mm;
    while ((mm = re.exec(line)) !== null){
      const c = mm[1].trim();
      if (c) chords.push(c);
    }
    if (chords.length){
      out.push(toCSMPNBars(chords));
    }
  }
  setStatus(`Imported ChordPro.`);
  return out.join('\n').replace(/\n{3,}/g,'\n\n');
}


function mineABCToSongModel(abcText){
  const song = new SongModel();
  const text = (abcText || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  const lines = text.split('\n');

  song.meta.title = firstABCHeaderValue(lines, 'T');
  song.meta.composer = firstABCHeaderValue(lines, 'C');
  song.meta.time = firstABCHeaderValue(lines, 'M') || '4/4';
  song.meta.key = normalizeABCKey(firstABCHeaderValue(lines, 'K'));
  song.meta.tempo = parseABCTempo(firstABCHeaderValue(lines, 'Q'));

  const sectionMap = new Map();
  let currentSection = ensureABCSection(sectionMap, 'Main');

  const hasMusicLikeContent = lines.some((line) => {
    const trimmed = (line || '').trim();
    if (!trimmed) return false;
    if (/^[A-Za-z]:/.test(trimmed)) return false;
    return /[A-Ga-gz"|]/.test(trimmed);
  });

  for (const line0 of lines){
    const line = (line0 || '').trim();
    if (!line || line.startsWith('%')) continue;

    const partMatch = line.match(/^P\s*:\s*(.+)$/i);
    if (partMatch){
      currentSection = ensureABCSection(sectionMap, partMatch[1]);
      continue;
    }

    if (/^[A-Za-z]\s*:/.test(line)) continue;

    const measures = line.split(/\|+/).map((m) => m.trim());
    for (const measure of measures){
      if (!measure) continue;
      const chordMatches = [...measure.matchAll(/"([^"]+)"/g)]
        .map((m) => normalizeChordToken(m[1] || ''))
        .filter(Boolean);
      if (!chordMatches.length){
        if ((/\|\s*:\s*$/.test(line) || /^\s*:\s*\|/.test(line)) && currentSection.bars.length){
          currentSection.bars.push('%');
        }
        continue;
      }
      currentSection.bars.push(chordMatches.length === 1 ? chordMatches[0] : chordMatches.join('_'));
    }

    if (/\|:/.test(line)) currentSection.bars.push('|:');
    if (/:\|/.test(line)) currentSection.bars.push(':|');
  }

  let totalBars = 0;
  for (const sec of sectionMap.values()) totalBars += sec.bars.length;

  if (totalBars < 4 && hasMusicLikeContent){
    try {
      const parsedBars = fallbackMineABCWithAbcjs(text);
      if (parsedBars.length){
        if (!currentSection.bars.length) currentSection = ensureABCSection(sectionMap, 'Main');
        currentSection.bars.push(...parsedBars);
      }
    } catch (err) {
      console.warn('ABCJS parse fallback warning:', err);
    }
  }

  song.sections = [...sectionMap.values()].filter((sec) => sec.bars.length);
  if (!song.sections.length){
    song.sections = [{ label: '- Main', bars: [] }];
  }
  return song;
}

function firstABCHeaderValue(lines, letter){
  const re = new RegExp(`^${letter}\\s*:\\s*(.+)$`, 'i');
  for (const line0 of lines){
    const line = (line0 || '').trim();
    const m = line.match(re);
    if (m) return m[1].trim();
  }
  return '';
}

function normalizeABCKey(rawKey){
  const key = (rawKey || '').trim();
  if (!key) return '';
  const m = key.match(/^([A-Ga-g])([#b]?)(.*)$/);
  if (!m) return key;
  const root = m[1].toUpperCase();
  const acc = m[2] || '';
  const rest = (m[3] || '').trim();
  if (!rest) return `${root}${acc}`;
  if (/^(m|min|minor)$/i.test(rest)) return `${root}${acc}m`;
  return `${root}${acc}${rest}`;
}

function parseABCTempo(qValue){
  const q = (qValue || '').trim();
  if (!q) return '';
  const m = q.match(/=\s*(\d{2,3})/);
  if (m) return String(parseInt(m[1], 10));
  const n = q.match(/\b(\d{2,3})\b/);
  return n ? String(parseInt(n[1], 10)) : '';
}

function ensureABCSection(sectionMap, labelRaw){
  const cleaned = (labelRaw || 'Main').replace(/^[-:=]+\s*/, '').trim() || 'Main';
  const key = cleaned.toLowerCase();
  if (!sectionMap.has(key)){
    sectionMap.set(key, { label: `- ${cleaned}`, bars: [] });
  }
  return sectionMap.get(key);
}

function fallbackMineABCWithAbcjs(abcText){
  const bars = [];
  if (!window.ABCJS || typeof window.ABCJS.renderAbc !== 'function') return bars;

  const hidden = document.getElementById('abc-hidden');
  if (!hidden) return bars;

  const tunes = window.ABCJS.renderAbc('abc-hidden', abcText, { add_classes: true });
  if (!Array.isArray(tunes)) return bars;

  for (const tune of tunes){
    const lines = tune?.lines || [];
    for (const line of lines){
      const staffs = line?.staff || [];
      for (const staff of staffs){
        const voices = staff?.voices || [];
        for (const voice of voices){
          for (const event of voice){
            const chord = event?.chord?.find((c) => c?.name)?.name || event?.gchord;
            if (chord){
              bars.push(normalizeChordToken(String(chord)));
            }
          }
        }
      }
    }
  }

  if (!bars.length){
    console.warn('ABCJS fallback parse produced no chord annotations; proceeding with text-mined ABC bars.');
  }
  return bars.filter(Boolean);
}

function importMusicXML(xmlText){
  try{
    const parser = new DOMParser();
    const xml = parser.parseFromString(xmlText, 'application/xml');
    const parseError = xml.querySelector('parsererror');
    if (parseError){
      throw new Error(parseError.textContent?.trim() || 'Invalid XML');
    }

    const song = new SongModel();
    song.meta.title =
      xml.querySelector('work > work-title')?.textContent?.trim() ||
      xml.querySelector('movement-title')?.textContent?.trim() ||
      xml.querySelector('credit credit-words')?.textContent?.trim() ||
      '';

    song.meta.composer =
      xml.querySelector("identification creator[type='composer']")?.textContent?.trim() ||
      xml.querySelector('identification creator')?.textContent?.trim() ||
      '';

    const firstAttributes = xml.querySelector('measure attributes');
    const timeBeats = firstAttributes?.querySelector('time beats')?.textContent?.trim();
    const timeBeatType = firstAttributes?.querySelector('time beat-type')?.textContent?.trim();
    if (timeBeats && timeBeatType){
      song.meta.time = `${timeBeats}/${timeBeatType}`;
    }

    const keyFifths = firstAttributes?.querySelector('key fifths')?.textContent?.trim();
    const keyMode = firstAttributes?.querySelector('key mode')?.textContent?.trim();
    song.meta.key = mapMusicXMLFifthsToKey(keyFifths, keyMode);

    const tempoNode = xml.querySelector('sound[tempo]') || xml.querySelector('direction sound[tempo]');
    const tempoValue = tempoNode?.getAttribute('tempo');
    if (tempoValue){
      const tempoNum = Number(tempoValue);
      song.meta.tempo = Number.isFinite(tempoNum) ? String(Math.round(tempoNum)) : '';
    }

    const measures = [...xml.querySelectorAll('measure')];
    const bars = [];
    for (const meas of measures){
      const harmonies = [...meas.querySelectorAll('harmony')];
      const chords = harmonies.map((h) => normalizeChordToken(harmonyToChord(h))).filter(Boolean);
      if (!chords.length){
        bars.push('%');
      } else if (chords.length === 1){
        bars.push(chords[0]);
      } else {
        bars.push(chords.join('_'));
      }
    }

    song.sections.push({ label: '- Main', bars });
    setStatus(`Imported MusicXML: ${measures.length} measure(s).`);
    return song;
  }catch(err){
    console.warn('MusicXML import failed:', err);
    setStatus(`MusicXML import failed: ${err?.message || err}`, 'error');
    throw err;
  }
}

function harmonyToChord(h){
  const step = h.querySelector("root root-step")?.textContent?.trim();
  const alter = h.querySelector("root root-alter")?.textContent?.trim();
  if (!step) return '';
  const acc = alter === '1' ? '#' : (alter === '-1' ? 'b' : '');
  const kindText = h.querySelector("kind")?.getAttribute("text")?.trim() || '';
  const kind = h.querySelector("kind")?.textContent?.trim() || '';
  const bassStep = h.querySelector("bass bass-step")?.textContent?.trim();
  const bassAlter = h.querySelector("bass bass-alter")?.textContent?.trim();
  const bassAcc = bassAlter === '1' ? '#' : (bassAlter === '-1' ? 'b' : '');

  let qual = kindText || kind || '';
  // map a few common MusicXML kinds to chord quality
  const map = {
    'major': '',
    'minor': 'm',
    'dominant': '7',
    'major-seventh': 'maj7',
    'minor-seventh': 'm7',
    'diminished': 'dim',
    'diminished-seventh': 'dim7',
    'augmented': 'aug',
    'half-diminished': 'm7b5'
  };
  if (qual in map) qual = map[qual];

  let chord = `${step}${acc}${qual}`;
  if (bassStep) chord += `/${bassStep}${bassAcc}`;
  return chord;
}

function stripTokenDecorators(t){
  return (t || '')
    .replace(/^\(+/,'')
    .replace(/\)+$/,'')
    .replace(/x\d+$/i,'')
    .trim();
}

// isChordToken: alias used throughout for basic chord detection.
function isChordToken(tok){
  return isChordLikeToken(tok);
}

// Stricter chord token detection to avoid false positives from PDF text (e.g., section labels).
function isChordLikeToken(tok){
  if (!tok) return false;
  let t = normalizeAccidentals(tok)
    .replace(/\u200B/g,'')
    .trim();

  if (t === '%' || t === '%%' || /^%\d+$/.test(t)) return true;
  if (t === '*') return true;
  const upper = t.toUpperCase();
  if (upper === 'N.C.' || upper === 'NC') return true;

  t = stripTokenDecorators(t);
  if (!t) return false;

  const m = t.match(/^([A-G])([b#]?)(.*)$/);
  if (!m) return false;

  const rest = m[3] || '';
  if (!rest) return true;

  const rl = rest.toLowerCase();

  const startsOk =
    /^[0-9#b\/()+.,-]/.test(rest) ||
    rl.startsWith('m') ||
    rl.startsWith('maj') ||
    rl.startsWith('min') ||
    rl.startsWith('dim') ||
    rl.startsWith('aug') ||
    rl.startsWith('sus') ||
    rl.startsWith('add') ||
    rl.startsWith('alt') ||
    rl.startsWith('omit') ||
    rl.startsWith('no');

  if (!startsOk) return false;

  if (/^[a-z]+$/i.test(rest) && rest.length > 3){
    if (!/^(maj|min|dim|aug|sus|add|alt|omit|no|m)$/.test(rl)) return false;
  }

  return /^[A-Za-z0-9#b\/()+.,-Œî√∏√ò¬∞¬∫]*$/.test(rest);
}

function isChordLikeTokenPDF(tok){
  if (!isChordLikeToken(tok)) return false;
  const t = stripTokenDecorators(normalizeAccidentals(tok));
  if (/^[A-G][a-z]{4,}$/i.test(t) && !/[0-9#b]/.test(t)) return false;
  return true;
}



// normalizeChordToken: clean up a raw chord token for CSMPN output.
function normalizeChordToken(tok){
  if (!tok) return '';
  let t = normalizeAccidentals(tok).trim();
  t = stripTokenDecorators(t);
  if (!t) return '';
  if (!isChordLikeToken(t) && t !== '%' && t !== '%%') return '';
  return t;
}

function toCSMPNBars(chords){
  // chords array -> lines of 4 bars
  const toks = chords.map(c => normalizeAccidentals(c)).filter(Boolean);
  const out = [];
  for (let i=0;i<toks.length;i+=4){
    out.push(toks.slice(i,i+4).join(' '));
  }
  return out.join('\n');
}


/* =========================================================
   PDF Import (UG Pro / ChordSheet PDFs)
   - Uses PDF.js text extraction
   - Prefers barline reconstruction when PDFs contain | / ‚Äñ / «Å
   - Falls back to spatial clustering for "floating chord glyph" PDFs
========================================================= */
async function importUGProPDF(file){
  if (!window.pdfjsLib) throw new Error("PDF.js not loaded.");
  statusEl.textContent = "Reading PDF‚Ä¶";
  const arrayBuffer = await file.arrayBuffer();
  const pdfOpts = { data: arrayBuffer };
  // If the worker cannot be configured (common on iOS Safari), fall back to no-worker mode.
  try {
    if (!pdfjsLib?.GlobalWorkerOptions?.workerSrc) pdfOpts.disableWorker = true;
  } catch (e) {
    pdfOpts.disableWorker = true;
  }
  const loadingTask = pdfjsLib.getDocument(pdfOpts);
  const pdf = await loadingTask.promise;

  const meta = { title:"", composer:"", style:"", tempo:"", time:"", key:"" };
  const bodyLines = [];
  let pendingBars = [];

  const flushBars = () => {
    while (pendingBars.length){
      bodyLines.push(pendingBars.splice(0,4).join(" "));
    }
  };

  const normLine = (s) => (s ?? "").toString()
    .replace(/\u00A0/g, " ")
    .replace(/[«Å‚à•]/g, "||")
    .replace(/[‚Äú‚Äù]/g, "\"")
    .replace(/[‚Äò‚Äô]/g, "'")
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim();

  const isBarToken = (t) => /^(\|{1,2})$/.test(t);

  const splitTokens = (line) => {
    // Ensure barlines are tokenized
    let s = normLine(line);
    s = s.replace(/(\|{1,2})/g, " $1 ");
    return s.split(" ").filter(Boolean);
  };

  const looksLikeSection = (line, tokens, chordCount) => {
    if (!line) return false;
    if (chordCount > 0) return false;
    if (line.length > 48) return false;
    // common section words or "Chorus1" style
    if (/^(intro|verse|chorus|bridge|solo|tag|ending|outro|interlude|pre[-\s]?chorus|turnaround)\b/i.test(line)) return true;
    if (/^(chorus|verse|bridge|solo)\s*\d+$/i.test(line)) return true;
    // ALL CAPS markers like DOUBLE-TIME
    if (/^[A-Z][A-Z0-9\-\s]{3,}$/.test(line) && !/TITLE|COMPOSER|STYLE|TEMPO|TIME|KEY/.test(line)) return true;
    // "ENDXXXX" marker
    if (/^END[A-Z0-9\-]+$/.test(line)) return true;
    return false;
  };

  const parseHeaderFromLine = (line) => {
    const m1 = line.match(/^\s*Title:\s*(.*)$/i);
    if (m1) { meta.title = m1[1].trim(); return true; }
    const m2 = line.match(/^\s*(Composer|Artist):\s*(.*)$/i);
    if (m2) { meta.composer = m2[2].trim(); return true; }
    const m3 = line.match(/^\s*Style:\s*(.*)$/i);
    if (m3) { meta.style = m3[1].trim(); return true; }
    const m4 = line.match(/^\s*Tempo:\s*(.*)$/i);
    if (m4) { meta.tempo = m4[1].trim(); return true; }
    const m5 = line.match(/^\s*Time:\s*(.*)$/i);
    if (m5) { meta.time = m5[1].trim(); return true; }
    const m6 = line.match(/^\s*Key:\s*(.*)$/i);
    if (m6) { meta.key = m6[1].trim(); return true; }
    return false;
  };

  for (let p = 1; p <= pdf.numPages; p++){
    statusEl.textContent = `Parsing PDF‚Ä¶ page ${p}/${pdf.numPages}`;
    const page = await pdf.getPage(p);
    const tc = await page.getTextContent();
    const items = tc.items
      .map(it => ({
        str: (it.str ?? "").toString(),
        x: it.transform[4] ?? 0,
        y: it.transform[5] ?? 0
      }))
      .filter(it => it.str && it.str.trim());

    // Cluster by y into "visual lines"
    const buckets = new Map();
    for (const it of items){
      const yk = Math.round(it.y * 2) / 2; // 0.5pt buckets
      if (!buckets.has(yk)) buckets.set(yk, []);
      buckets.get(yk).push(it);
    }

    const yKeys = Array.from(buckets.keys()).sort((a,b) => b-a); // top-to-bottom
    for (const yk of yKeys){
      const lineItems = buckets.get(yk).sort((a,b) => a.x-b.x);
      // Join while preserving short gaps; PDF.js tends to split pipes and chords
      const rawLine = lineItems.map(it => it.str).join(" ");
      const line = normLine(rawLine);
      if (!line) continue;

      // header lines
      if (parseHeaderFromLine(line)) continue;

      const tokens = splitTokens(line);
      const chordTokens = tokens.filter(t => isChordToken(t));
      const chordCount = chordTokens.length;

      // If line has no chords: maybe title / section / ignore
      if (chordCount === 0){
        // candidate title line near top of doc
        if (!meta.title && line.length <= 80 && !line.includes(":") && !/^(page\s*\d+)/i.test(line)){
          meta.title = line;
          continue;
        }
        if (looksLikeSection(line, tokens, chordCount)){
          flushBars();
          let label = line;
          if (/^END([A-Z0-9\-]+)$/.test(line)){
            label = "End " + line.replace(/^END/i,"").replace(/_/g," ");
          }
          bodyLines.push(`- ${label}`);
          continue;
        }
        continue;
      }

      // chord line: build bars
      let bars = [];
      if (tokens.some(t => isBarToken(t))){
        let seg = [];
        for (const t of tokens){
          if (isBarToken(t)){
            if (seg.length){
              bars.push(seg.join("_"));
              seg = [];
            } else {
              // consecutive bars -> empty bar; skip
            }
            continue;
          }
          if (isChordToken(t)) seg.push(t);
        }
        if (seg.length) bars.push(seg.join("_"));
      } else {
        // No explicit bars: assume each chord is a bar
        bars = chordTokens.slice();
      }

      // Append bars
      for (const b of bars){
        if (!b) continue;
        pendingBars.push(b);
      }
    }
  }

  flushBars();

  // Apply normalization / validation to meta and sync UI
  const hdrText = [
    meta.title ? `Title: ${meta.title}` : "",
    meta.composer ? `Composer: ${meta.composer}` : "",
    meta.style ? `Style: ${meta.style}` : "",
    meta.tempo ? `Tempo: ${meta.tempo}` : "",
    meta.time ? `Time: ${meta.time}` : "",
    meta.key ? `Key: ${meta.key}` : ""
  ].filter(Boolean).join("\n");

  // This will sanitize and populate form fields.
  extractHeaderFromText(hdrText, true);

  const hdrVals = readHeaderInputs();
  const hdrLines = [];
  if (hdrVals.title) hdrLines.push(`Title: ${hdrVals.title}`);
  if (hdrVals.composer) hdrLines.push(`Composer: ${hdrVals.composer}`);
  if (hdrVals.style) hdrLines.push(`Style: ${hdrVals.style}`);
  if (hdrVals.tempo) hdrLines.push(`Tempo: ${hdrVals.tempo}`);
  if (hdrVals.time) hdrLines.push(`Time: ${hdrVals.time}`);
  if (hdrVals.key) hdrLines.push(`Key: ${hdrVals.key}`);
  let out = hdrLines.join("\n");
  if (out) out += "\n\n";
  out += bodyLines.join("\n");

  const chordBars = bodyLines.join(" ").split(/\s+/).filter(t => isChordToken(t) || t.includes("_") || t === "%");
  statusEl.textContent = `PDF import: ${chordBars.length} bar(s) extracted from ${pdf.numPages} page(s).`;

  return out.trim();
}

/* =========================================================
   Export / Print / Copy
========================================================= */
document.getElementById('btnTransposeDown').addEventListener('click', () => doTranspose(-1));
document.getElementById('btnTransposeUp').addEventListener('click', () => doTranspose(1));
document.getElementById('btnTransposeReset').addEventListener('click', () => { currentTranspose = 0; updatePreview(); setStatus('Transpose reset.'); });

function doTranspose(delta){
  currentTranspose += delta;
  const tr = transposeWholeText(sourceEl.value, delta);
  sourceEl.value = tr;
  extractHeaderFromText(tr);
  updatePreview();
  setStatus(`Transposed ${currentTranspose >= 0 ? '+' : ''}${currentTranspose} semitone(s).`);
}

document.getElementById('btnPrint').addEventListener('click', () => {
  setStatus('Opening print dialog...');
  window.print();
});

/* =========================================================
   Q4 FIX: jsPDF Download Button for iOS One-Tap Export
========================================================= */
document.getElementById('btnDownloadPdf').addEventListener('click', async () => {
  try{
    document.body.classList.add('exporting');
    setStatus('Rendering PDF‚Ä¶');
    const canvas = await html2canvas(previewEl, {
      scale: 2,
      backgroundColor: '#ffffff',
      logging: false,
      useCORS: true
    });

    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;

    const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'letter' });
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 36; // 0.5 inch

    const imgProps = pdf.getImageProperties(imgData);
    const imgWidth = pageWidth - margin * 2;
    const imgHeight = (imgProps.height * imgWidth) / imgProps.width;

    let heightLeft = imgHeight;
    let position = margin;

    pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);

    heightLeft -= (pageHeight - margin * 2);
    while (heightLeft > 0){
      pdf.addPage();
      position = margin - (imgHeight - heightLeft);
      pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);
      heightLeft -= (pageHeight - margin * 2);
    }

    const filename = safeFilename(hdr.title.value?.trim() || 'chart') + '.pdf';
    const blob = pdf.output('blob');
    const file = new File([blob], filename, { type: 'application/pdf' });
    const shared = await tryShareFile(file);
    if(!shared) downloadBlob(blob, filename);
    setStatus(shared ? 'PDF ready (shared).' : 'PDF downloaded.');
  } catch (e){
    console.error(e);
    setStatus('PDF export failed: ' + (e?.message || e), 'error');
  } finally {
    document.body.classList.remove('exporting');
  }
});

document.getElementById('btnPng').addEventListener('click', async () => {
  try{
    document.body.classList.add('exporting');
    setStatus('Rendering PNG...');
    const canvas = await html2canvas(previewEl, {scale: 2, backgroundColor: '#ffffff'});
    const filename = safeFilename(hdr.title.value?.trim() || 'chordsheet') + '.png';

    await new Promise((resolve, reject) => {
      canvas.toBlob(async (blob) => {
        try{
          if(!blob) throw new Error('PNG blob is empty');
          const file = new File([blob], filename, { type: 'image/png' });
          const shared = await tryShareFile(file);
          if(!shared) downloadBlob(blob, filename);
          setStatus(shared ? 'PNG ready (shared).' : 'PNG downloaded.');
          resolve();
        }catch(e){
          reject(e);
        }
      }, 'image/png');
    });
  }catch(err){
    console.error(err);
    setStatus(`PNG export failed: ${err?.message || err}`, true);
  }finally{
    document.body.classList.remove('exporting');
  }
});


document.getElementById('btnCopy').addEventListener('click', async () => {
  try{
    await navigator.clipboard.writeText(sourceEl.value || '');
    setStatus('CSMPN copied to clipboard.');
  }catch(err){
    setStatus('Copy failed (clipboard permissions).', true);
  }
});

/* =========================================================
   ChordPro Export (inspired by chord-chart-studio/chord-mark-converters)
========================================================= */
function exportToChordPro(text){
  const doc = parseCSMPN(text);
  const lines = [];
  if (doc.title) lines.push(`{title: ${doc.title}}`);
  if (doc.composer) lines.push(`{composer: ${doc.composer}}`);
  if (doc.key) lines.push(`{key: ${doc.key}}`);
  if (doc.time) lines.push(`{time: ${doc.time}}`);
  if (doc.tempo) lines.push(`{tempo: ${doc.tempo}}`);
  if (lines.length) lines.push('');

  for (const block of doc.blocks){
    if (block.type === 'marker'){
      const sectionName = (block.text || '').toLowerCase();
      if (block.marker === '-' || block.marker === ':'){
        lines.push(`{start_of_${sectionName.includes('chorus') ? 'chorus' : sectionName.includes('bridge') ? 'bridge' : 'verse'}: ${block.text}}`);
      } else if (block.marker === '='){
        lines.push(`{comment: ${block.text}}`);
      } else {
        lines.push(`{comment: ${block.text}}`);
      }
      continue;
    }
    if (block.type === 'bars'){
      const chordLine = block.tokens
        .filter(t => !isBarlineToken(t))
        .map(t => {
          const stripped = stripTokenDecorators(t);
          if (!stripped || stripped === '%' || stripped === '%%') return `[${t}]`;
          return `[${stripped}]`;
        })
        .join(' ');
      lines.push(chordLine);
    }
  }
  return lines.join('\n');
}

document.getElementById('btnExportChordPro').addEventListener('click', () => {
  try {
    const chordPro = exportToChordPro(sourceEl.value);
    const filename = safeFilename(hdr.title.value?.trim() || 'chart') + '.chopro';
    const blob = new Blob([chordPro], { type: 'text/plain;charset=utf-8' });
    downloadBlob(blob, filename);
    setStatus('Exported as ChordPro (.chopro).');
  } catch(e) {
    setStatus('ChordPro export failed: ' + (e?.message || e), 'error');
  }
});

/* =========================================================
   Song Library (inspired by chord-chart-studio localStorage persistence)
========================================================= */
function getSongLibrary(){
  try {
    const raw = localStorage.getItem('csmpn_library');
    return raw ? JSON.parse(raw) : [];
  } catch(_){ return []; }
}

function saveSongLibrary(library){
  try { localStorage.setItem('csmpn_library', JSON.stringify(library)); } catch(_){}
}

document.getElementById('btnSave').addEventListener('click', () => {
  const text = sourceEl.value || '';
  const headerData = extractHeaderFromText(text, false);
  const songTitle = headerData.title || 'Untitled';

  const library = getSongLibrary();
  const existing = library.findIndex(s => s.title === songTitle);
  const entry = {
    title: songTitle,
    content: text,
    savedAt: new Date().toISOString(),
  };

  if (existing >= 0){
    library[existing] = entry;
  } else {
    library.push(entry);
  }
  saveSongLibrary(library);
  setStatus(`Saved "${songTitle}" to library (${library.length} song(s)).`);
});

document.getElementById('btnLoad').addEventListener('click', () => {
  const library = getSongLibrary();
  if (!library.length){
    setStatus('No saved songs in library.', 'warning');
    return;
  }

  // Build a simple song picker
  const names = library.map((s, i) => `${i + 1}. ${s.title} (${s.savedAt?.slice(0,10) || 'unknown'})`);
  const choice = prompt('Select a song to load:\\n\\n' + names.join('\\n') + '\\n\\nEnter number:');
  if (!choice) return;
  const idx = parseInt(choice, 10) - 1;
  if (idx < 0 || idx >= library.length){
    setStatus('Invalid selection.', 'warning');
    return;
  }
  sourceEl.value = library[idx].content;
  extractHeaderFromText(library[idx].content);
  updatePreview();
  setStatus(`Loaded "${library[idx].title}" from library.`);
});

/* =========================================================
   Keyboard Shortcuts (inspired by chord-chart-studio UI patterns)
========================================================= */
document.addEventListener('keydown', (e) => {
  // Ctrl/Cmd+S: Save song
  if ((e.ctrlKey || e.metaKey) && e.key === 's'){
    e.preventDefault();
    document.getElementById('btnSave').click();
  }
  // Ctrl/Cmd+P: Print
  if ((e.ctrlKey || e.metaKey) && e.key === 'p'){
    e.preventDefault();
    window.print();
  }
  // Ctrl/Cmd+Up: Transpose up
  if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowUp'){
    e.preventDefault();
    doTranspose(1);
  }
  // Ctrl/Cmd+Down: Transpose down
  if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowDown'){
    e.preventDefault();
    doTranspose(-1);
  }
});

/* =========================================================
   Init
========================================================= */
sourceEl.value = `Title: Sin City Blues
Style: Slow Blues Swing
Tempo: 90
Time: 12/8
Key: Bb

- Intro
|: Bb7 Bb7_A7_D7
Eb6 Eo7_Go7 Bo7
Bb7 G7 C7 F9_F13
Bb6 Eb9 Bb7 F+ :|

- Verse 1
|: Bb7 % Eb7 %
Bb7 B7 Bb7 % :|

- Pre-Chorus
|: Eb7 Eb7_Eo7
Bb7_Cm7 Dm7_Dbm7 :|

- Chorus 1
|: F9 F
Bb7_G7 C7_F7 :|

- Verse 2
|: Bb7 Eb7
Bb7 B7 Bb7 % :|

- Pre-Chorus 2
|: Eb7 Eb7_Eo7
Bb7_Cm7 Dm7_Dbm7 :|

- Chorus 2
|: Cm7_Dm7 Ebmaj7_Eo7
F9_F13 Bb6_Eb9
Bb_Bb7 :|

= Bridge
|: Eb7 Eb7_Eo7
Bb7_Bb7 Bb7_B7_C7_Db7_D7
Eb7 Eo7_Go7_Bbo7
Bb7_Bbo7 Ao7_G7
Cm7_Dm7 Ebmaj7_Eo7
F9_F13 Bb7_G7
C7_F7 :|

- Verse 3
|: Bb7 % Eb7 %
Bb7_B7 Bb7 % :|

- Pre-Chorus 3
|: Eb7 Eb7_Eo7
Bb7_Cm7 Dm7_Dbm7 :|

= 1st Ending
|: Cm7_Dm7 Ebmaj7_Eo7
F9_F13 Bb7_Bb6
Bb7_A7_Ab7_G7 :|

= 2nd Ending
|: Cm7_Dm7 Ebmaj7_Eo7
F9_F13 :|

= CODA
|: Bb7_Bb6_Eb9 Bb_B13_Bb7 :|
`;

loadFBSettings();
applyFBSettings();
extractHeaderFromText(sourceEl.value);
updatePreview();
setStatus('Ready. v1.8 ‚Äî Fake Book formatting.');

// --- Optional self-tests (run manually in console): window.runCSMPNSelfTests() ---
// v1.8.0: Fake Book Edition
window.runCSMPNSelfTests = function(){
  const results = [];
  const assert = (name, cond) => results.push({ name, pass: !!cond });
  try{
    // Header extraction sanity
    const h = extractHeaderFromText("Title: Sin City Blues\nComposer: Czemba\nStyle: Swing\nTempo: 81\nTime: 4/4\nKey: Bb", false);
    assert("header.title", h.title === "Sin City Blues");
    assert("header.key", h.key === "Bb");
    assert("header.tempo", h.tempo === "81");

    // Reject chord-poisoned key
    const h2 = extractHeaderFromText("Key: G G7sus4", false);
    assert("reject chordy key", h2.key === "");

    // UG Pro normalization
    const n = normalizeUGProText("Bb7 | Eb7 | x2 x2\n(times two)\n");
    assert("normalize times two", n.includes("x2"));
    assert("dedupe x2", !/x2\s+x2/i.test(n));

    // Barline delimiter normalization
    const b = normalizeBarlineDelimiters("«Å Bb7 | % |");
    assert("normalize unicode bars", b.includes("||"));

    // BUG FIX: Double barlines not destroyed by single-pipe replacement
    const b2 = normalizeBarlineDelimiters("Bb7 || Eb7");
    assert("double barline preserved", b2.includes("||") && !b2.includes("| |"));

    // BUG FIX: Repeat barlines preserved
    const b3 = normalizeBarlineDelimiters("|: Bb7 Eb7 :|");
    assert("repeat-start preserved", b3.includes("|:"));
    assert("repeat-end preserved", b3.includes(":|"));

    // BUG FIX: formatChordQuality ‚Äî 'maj' alone (no 7) should NOT be styled as maj7
    const q1 = formatChordQuality('maj');
    assert("bare maj not treated as maj7", q1 === 'maj');
    const q2 = formatChordQuality('maj7');
    assert("maj7 styled correctly", q2 === 'MA7' || q2 === 'maj7' || q2 === 'Œî7');
    const q3 = formatChordQuality('ma9');
    assert("ma9 styled correctly", q3 === 'MA9' || q3 === 'maj9' || q3 === 'Œî9');

    // BUG FIX: notation preference false match on words
    const pref1 = detectNotationPreferenceFromKeyOrText('', 'Above the bridge');
    assert("notation pref not fooled by words", pref1 === 'sharp');
    const pref2 = detectNotationPreferenceFromKeyOrText('', 'Bb7 Eb7');
    assert("notation pref detects flat chords", pref2 === 'flat');

    // BUG FIX: importUGText preserves marker types
    const ug1 = importUGText("- Intro\nBb7 Eb7 Cm7 F7\n= Bridge\nG7 C7 Am7 D7");
    assert("importUGText preserves - marker", ug1.includes("- Intro"));
    assert("importUGText preserves = marker", ug1.includes("= Bridge"));

    // Transposition sanity
    assert("transpose Bb+1=B", transposeNote('Bb', 1, 'sharp') === 'B');
    assert("transpose C-1=B", transposeNote('C', -1, 'sharp') === 'B');
    assert("transpose F#+1=G", transposeNote('F#', 1, 'sharp') === 'G');

    // SongModel serialization + MusicXML mining
    const songModel = new SongModel();
    songModel.meta.title = 'SongModel Test';
    songModel.sections.push({ label: 'Verse', bars: ['C', 'G', 'Am', 'F', 'Dm'] });
    const smText = songModel.toCSMPN({ barsPerRow: 4 });
    assert('SongModel prefixes plain section labels', smText.includes('- Verse'));
    assert('SongModel chunks by barsPerRow', smText.includes('C G Am F\nDm'));

    const xmlSong = importMusicXML(`<?xml version="1.0" encoding="UTF-8"?><score-partwise version="3.1"><work><work-title>XML Tune</work-title></work><identification><creator type="composer">Jane Doe</creator></identification><part id="P1"><measure number="1"><attributes><divisions>1</divisions><key><fifths>-1</fifths><mode>major</mode></key><time><beats>4</beats><beat-type>4</beat-type></time></attributes><harmony><root><root-step>B</root-step><root-alter>-1</root-alter></root><kind text="7">dominant</kind></harmony></measure><measure number="2"><harmony><root><root-step>E</root-step><root-alter>-1</root-alter></root><kind>major</kind></harmony><harmony><root><root-step>F</root-step></root><kind>minor-seventh</kind></harmony></measure></part></score-partwise>`);
    assert('importMusicXML returns SongModel', xmlSong instanceof SongModel);
    assert('MusicXML title mined', xmlSong.meta.title === 'XML Tune');
    assert('MusicXML key mined', xmlSong.meta.key === 'Bb');
    assert('MusicXML bar split with _', xmlSong.sections[0]?.bars[1] === 'Eb_Fm7');

    // parseCSMPN basic
    const doc = parseCSMPN("Title: Test\nKey: C\n- Verse\nC G Am F");
    assert("parseCSMPN title", doc.title === "Test");
    assert("parseCSMPN key", doc.key === "C");
    assert("parseCSMPN has marker block", doc.blocks[0]?.type === "marker");
    assert("parseCSMPN has bars block", doc.blocks[1]?.type === "bars");

    // ChordPro export
    const cp = exportToChordPro("Title: Test\nKey: C\n- Verse\nC G Am F");
    assert("chordPro export title", cp.includes("{title: Test}"));
    assert("chordPro export key", cp.includes("{key: C}"));
    assert("chordPro export chords", cp.includes("[C]") && cp.includes("[G]"));

    // isChordToken tests
    assert("isChordToken Bb7", isChordToken("Bb7"));
    assert("isChordToken Cmaj7", isChordToken("Cmaj7"));
    assert("isChordToken N.C.", isChordToken("N.C."));
    assert("isChordToken %", isChordToken("%"));
    assert("!isChordToken 'the'", !isChordToken("the"));
    assert("!isChordToken 'Verse'", !isChordToken("Verse"));

    // Page count in footer
    const docPages = parseCSMPN("Title: T\n- V1\nC G Am F\n+\n- V2\nD A Bm G");
    assert("page break detected", docPages.blocks.filter(b=>b.type==='pagebreak').length === 1);

  }catch(e){
    results.push({ name: "exception", pass: false, error: e?.message || String(e) });
  }
  console.table(results);
  const passed = results.filter(r => r.pass).length;
  const total = results.length;
  console.log(`Self-tests: ${passed}/${total} passed` + (passed === total ? ' ‚úì' : ' ‚úó FAILURES'));
  return results;
};

</script>
</body>
</html>
