<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ChordSheet CSMPN Builder v1.6.4.2</title>

<!-- PDF.js (required for UG Pro PDF text extraction) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- html2canvas for image/PDF capture -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- jsPDF for optional PDF export (print remains the primary PDF workflow) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<style>
  :root{
    --bg:#f5f5f5;
    --card:#ffffff;
    --ink:#111111;
    --muted:#5b5b5b;
    --accent:#2563eb;
    --accent2:#111827;
    --border:#d9d9d9;
    --radius:14px;
  }

  *{ box-sizing:border-box; }

  body{
    margin:0;
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
    background:var(--bg);
    color:var(--ink);
  }

  .app{
    max-width:1200px;
    margin:0 auto;
    padding:12px;
  }

  .topbar{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
    margin-bottom:12px;
  }

  .title{
    font-weight:800;
    font-size:20px;
    margin-bottom:10px;
  }

  .row{
    display:grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap:10px;
    margin-bottom:10px;
  }

  .field label{
    display:block;
    font-size:12px;
    color:var(--muted);
    margin-bottom:4px;
    font-weight:700;
  }
  .field input{
    width:100%;
    padding:10px 10px;
    border:1px solid var(--border);
    border-radius:10px;
    font-size:16px;
    background:#fff;
  }

  .btnrow{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    margin:10px 0 8px 0;
  }
  button{
    border:0;
    border-radius:12px;
    padding:12px 14px;
    font-weight:800;
    font-size:16px;
    cursor:pointer;
  }
  button.accent{ background:var(--accent); color:white; }
  button.secondary{ background:var(--accent2); color:white; }

  .tips{
    margin-top:8px;
    font-size:13px;
    color:var(--muted);
    line-height:1.35;
  }
  .tips ul{ margin:8px 0 0 18px; }

  .status{
    margin-top:10px;
    padding:10px 12px;
    border-radius:12px;
    background:#eef2ff;
    border:1px solid #c7d2fe;
    font-weight:700;
  }
  .status.warn{
    background:#fff7ed;
    border-color:#fdba74;
  }
  .status.err{
    background:#fef2f2;
    border-color:#fca5a5;
  }

  .grid{
    display:grid;
    grid-template-columns: 1fr;
    gap:12px;
  }

  .card{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
  }

  textarea{
    width:100%;
    min-height:320px;
    resize:vertical;
    padding:12px;
    border:1px solid var(--border);
    border-radius:12px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:14px;
    line-height:1.35;
    background:#fff;
  }

  .previewWrap{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
  }

  .sheet{
    background:#fff;
    border:1px solid #e5e5e5;
    border-radius:12px;
    padding:18px;
    box-shadow: 0 1px 0 rgba(0,0,0,0.04);
    max-width: 8.5in;
    margin: 0 auto;
  }

  /* ===== ChordSheet layout & typography ===== */
  .sheetHeader{
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    gap:16px;
    border-bottom:2px solid #111;
    padding-bottom:8px;
    margin-bottom:16px;
  }

  .headerInfo{
    display:flex;
    flex-direction:column;
    gap:6px;
  }

  .headerMeta{
    font-size:14px;
    font-style:italic;
    color:#222;
  }

  .songTitle{
    font-size:42px;
    font-weight:900;
    margin:0;
    letter-spacing:-0.02em;
    text-transform:uppercase;
  }

  .headerComposer{
    font-size:14px;
    font-weight:600;
  }

  .headerRight{
    text-align:right;
    min-width:120px;
  }

  .tempoLine{
    font-size:18px;
    font-weight:700;
  }

  .timeSig{
    font-size:18px;
    font-weight:700;
  }

  .sectionText{
    margin:18px 0 6px 0;
    font-size:18px;
    font-weight:900;
  }

  .labelBox{
    display:inline-block;
    border:2px solid #111;
    padding:2px 8px;
    border-radius:4px;
    font-size:16px;
    font-weight:700;
  }

  .dividerRow{
    display:flex;
    align-items:center;
    gap:12px;
    margin:18px 0 8px 0;
  }

  .dividerRow .rule{
    flex:1;
    height:2px;
    background:#111;
  }

  .barlineRow{
    display:grid;
    grid-template-columns: 14px minmax(0, 1fr) 14px minmax(0, 1fr) 14px minmax(0, 1fr) 14px minmax(0, 1fr) 14px;
    align-items:center;
    gap:0;
    margin: 12px 0 6px 0;
    padding-top:8px;
    position:relative;
  }

  .barline{
    position:relative;
    height:2.2em;
  }

  .barline::before,
  .barline::after{
    content:'';
    position:absolute;
    top:0;
    bottom:0;
    border-left:2px solid #111;
  }

  .barline.single::before{
    left:50%;
  }

  .barline.double::before{
    left:40%;
  }

  .barline.double::after{
    left:60%;
  }

  .barline.final::before{
    left:40%;
  }

  .barline.final::after{
    left:65%;
    border-left-width:4px;
  }

  .barline.repeat-start::before{
    left:30%;
    border-left-width:4px;
  }

  .barline.repeat-start::after{
    left:60%;
  }

  .barline.repeat-start span,
  .barline.repeat-end span{
    position:absolute;
    right:2px;
    top:45%;
    width:6px;
    height:6px;
    border-radius:50%;
    background:#111;
    box-shadow:0 12px 0 #111;
  }

  .barline.repeat-start span{
    right:0;
  }

  .barline.repeat-end::before{
    left:40%;
  }

  .barline.repeat-end::after{
    left:70%;
    border-left-width:4px;
  }

  .barline.repeat-end span{
    left:0;
  }

  .measure{
    display:flex;
    align-items:flex-end;
    justify-content:flex-start;
    min-height:2.2em;
    padding:0 6px;
    white-space:nowrap;
  }

  .beats{
    display:inline-flex;
    gap:0.6rem;
    align-items:flex-end;
    flex-wrap:wrap;
  }

  .beat{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:2px;
  }

  .beatAnnotation{
    font-size:12px;
    font-style:italic;
    color:#111;
  }

  .chord{
    display:inline-flex;
    align-items:flex-start;
    font-family: "Georgia", "Times New Roman", serif;
    font-weight:700;
    font-size:22px;
    line-height:1;
  }

  .chord-root{
    font-weight:800;
    font-size:24px;
  }

  .chord-quality{
    font-size:14px;
    font-variant:small-caps;
    margin-left:2px;
    margin-top:2px;
  }

  .chord-bass{
    font-size:14px;
    margin-left:3px;
  }

  .chord-bass::before{
    content:"/";
    margin-right:2px;
  }

  .musicSymbol{
    font-size:22px;
    font-family:"Georgia","Times New Roman",serif;
  }

  .repeatSymbol{
    font-size:24px;
  }

  .endingBracket{
    grid-row:1;
    align-self:start;
    justify-self:stretch;
    margin-top:-16px;
    border-top:2px solid #111;
    height:14px;
    position:relative;
  }

  .endingBracket::before{
    content:'';
    position:absolute;
    left:0;
    top:-2px;
    height:14px;
    border-left:2px solid #111;
  }

  .endingLabel{
    position:absolute;
    top:-20px;
    left:4px;
    font-size:12px;
    font-weight:700;
    background:#fff;
    padding:0 4px;
  }

  .annotation{
    margin:8px 0;
    font-size:15px;
    color:#111;
  }

  .pageBreak{ page-break-before: always; break-before: page; height:1px; }

  /* Desktop: side-by-side editor and preview */
  @media (min-width: 980px){
    .grid{ grid-template-columns: 1fr 1fr; }
    textarea{ min-height: 520px; }
    .previewWrap{ position: sticky; top: 12px; align-self: start; }
  }

  /* Print: show only the sheet */
  
/* Export fidelity: flatten UI chrome for PDF/PNG captures */
body.exporting .card{
  border: none !important;
  box-shadow: none !important;
  border-radius: 0 !important;
  padding: 0 !important;
  margin: 0 !important;
}
body.exporting #renderTarget{
  padding: 0 !important;
  margin: 0 !important;
  background: #fff !important;
}
body.exporting .sheet{
  padding: 36px 42px !important; /* ~0.5in */
}

/* Chord-sheet.com-like typography (preview + export) */
.songTitle{
  font-size: 48px !important;
  font-weight: 900 !important;
  letter-spacing: -0.5px;
}
.sectionText{
  font-size: 22px !important;
  font-weight: 900 !important;
  margin: 18px 0 8px 0 !important;
}

@media print{
    body{ background:white; }
    .topbar, .card.editorCard, .tips, .status, .btnrow { display:none !important; }
    .app{ max-width:none; padding:0; }
    .previewWrap{ border:0; padding:0; }
    .sheet{ border-radius:0; padding:18px; box-shadow:none; }
    @page { size: letter; margin: 0.5in; }
    .sheet{ max-width:none; margin:0; border:0; }
  }
</style>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="title">ChordSheet CSMPN Builder v1.6.4.2</div>

    <div class="row">
      <div class="field"><label>Title</label><input id="hdrTitle" placeholder="Song title"></div>
      <div class="field"><label>Composer / Artist</label><input id="hdrComposer" placeholder="Artist / composer"></div>
      <div class="field"><label>Key</label><input id="hdrKey" placeholder="e.g., Bb"></div>
      <div class="field"><label>Time</label><input id="hdrTime" placeholder="e.g., 4/4"></div>
      <div class="field"><label>Tempo</label><input id="hdrTempo" placeholder="e.g., 120"></div>
      <div class="field"><label>Style</label><input id="hdrStyle" placeholder="e.g., Swing"></div>
    </div>

    <div class="btnrow">
      <button class="accent" id="btnImport">Import File ‚Üí CSMPN</button>
      <button class="secondary" id="btnTransposeDown">Transpose -1</button>
      <button class="secondary" id="btnTransposeUp">Transpose +1</button>
      <button class="secondary" id="btnTransposeReset">Reset Transpose</button>
      <button class="accent" id="btnPrint">Print / Save PDF</button>
      <button class="secondary" id="btnDownloadPdf">Download PDF (iOS)</button>
      <button class="secondary" id="btnPng">Save Image (PNG)</button>
      <button class="secondary" id="btnCopy">Copy CSMPN</button>
    </div>

    <div class="tips">
      <strong>How to use:</strong>
      <ul>
        <li>Import a PDF/TXT/XML, or paste CSMPN in the editor.</li>
        <li>Each chord token is a bar; four bars render per row automatically.</li>
        <li>Use <code>_</code> to split a bar (e.g., <code>Bb_Eb7</code>), <code>%</code> to repeat a bar, and <code>(... )x2</code> for repeats.</li>
        <li>Endings: <code>1. Gm7 C7 2. F7 Bb</code> renders with labels above bars.</li>
        <li>Print is the primary PDF workflow; "Download PDF (iOS)" provides one-tap mobile export.</li>
        <li>You can paste/import barline charts using "|" and "«Å" ‚Äì they will be interpreted as measure separators.
If a PDF import yields no chords, it may be image-only (no selectable text).</li>
      </ul>
    </div>

    <div id="status" class="status">Ready. v1.6 - PDF import fixes applied.</div>

    <!-- hidden file input -->
    <input id="fileInput" type="file" accept=".pdf,.txt,.xml,.musicxml" style="display:none" />
  </div>

  <div class="grid">
    <div class="card editorCard">
      <label>CSMPN Source (ChordSheet-compatible)</label>
      <textarea id="source"></textarea>
    </div>

    <div class="previewWrap">
      <div id="preview" class="sheet">
        <div style="color:#666; font-size:14px; text-align:center; padding: 40px 10px;">
          Import a file or paste CSMPN to preview.
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================================================
   Core constants / helpers
========================================================= */
const sourceEl = document.getElementById('source');
const previewEl = document.getElementById('preview');
const statusEl = document.getElementById('status');

// PDF.js worker config (required when loading PDF.js from a CDN on GitHub Pages)
if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
  try {
    // Some Safari/iOS builds treat workerSrc as read-only. Guard and fail soft.
    if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    }
  } catch (e) {
    console.warn('pdf.js workerSrc assignment skipped:', e);
  }
}

const hdr = {
  title: document.getElementById('hdrTitle'),
  composer: document.getElementById('hdrComposer'),
  key: document.getElementById('hdrKey'),
  time: document.getElementById('hdrTime'),
  tempo: document.getElementById('hdrTempo'),
  style: document.getElementById('hdrStyle'),
};

let currentTranspose = 0;
let notationPreference = 'sharp'; // recomputed from key/text
let validationWarnings = []; // Q5: Track validation issues

function setStatus(msg, type='info'){
  // Back-compat: older call sites passed boolean (true=error)
  if (type === true) type = 'error';
  if (type === false) type = 'info';

  try{
    window.__csmpnLog = window.__csmpnLog || [];
    window.__csmpnLog.push({ t: new Date().toISOString(), type, msg: String(msg), ua: navigator.userAgent });
    // Keep last ~500 entries
    if (window.__csmpnLog.length > 500) window.__csmpnLog = window.__csmpnLog.slice(-500);
  }catch(e){}

  statusEl.textContent = msg;
  statusEl.classList.remove('err', 'warn');
  if (type === 'error') statusEl.classList.add('err');
  if (type === 'warning') statusEl.classList.add('warn');
}

function escapeHtml(s){
  return (s ?? '').toString()
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'","&#039;");
}

function safeFilename(name, fallback='chart'){
  const base = (name || fallback).toString().trim() || fallback;
  return base
    .replace(/[\\\/\:*?"<>|]+/g,'-')
    .replace(/\s+/g,' ')
    .trim()
    .slice(0, 80);
}

async function tryShareFile(file){
  try{
    if (navigator.canShare && navigator.canShare({ files: [file] })) {
      await navigator.share({ files: [file], title: file.name });
      return true;
    }
  }catch(_e){}
  return false;
}

function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.rel = 'noopener';
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}



function normalizeAccidentals(s){
  return (s ?? '')
    .replace(/‚ô≠/g,'b')
    .replace(/‚ôØ/g,'#')
    .replace(/\u00A0/g,' ')
    .trim();
}

/* =========================================================
   Phase-1 fixes: Header <-> Source bidirectional sync
========================================================= */
function extractHeaderFromText(text, writeToInputs=true){
  // Extracts header metadata from CSMPN-like source and (optionally) syncs the form fields.
  // Defensive: avoids poisoning header fields with chord lines / section labels.
  const norm = (s) => (s ?? "").toString()
    .replace(/\u00A0/g, " ")
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim();

  const looksChordy = (s) => {
    const t = norm(s);
    if (!t) return false;
    if (/[|«Å]/.test(t) || /%/.test(t)) return true;
    const toks = t.split(" ").filter(Boolean);
    let chordCount = 0;
    for (const tok of toks){
      if (isChordToken(tok)) chordCount++;
    }
    // If it contains multiple chord tokens, it's likely not a human header value.
    return chordCount >= 2;
  };

  const normalizeField = (field, raw) => {
    let v = norm(raw);
    if (!v) return "";
    // Strip stray trailing punctuation
    v = v.replace(/^[\-\u2013\u2014]+/, "").trim();

    if (field === "key"){
      // Accept common key spellings: Bb, F#, C#m, Abm, etc.
      v = v.replace(/\s+/g, "");
      v = v.replace(/minor$/i, "m").replace(/min$/i, "m");
      // Reject obviously bad values
      if (!/^[A-G](?:#|b)?(?:m)?$/i.test(v)) return "";
      return v;
    }
    if (field === "time"){
      v = v.replace(/\s+/g, "");
      if (!/^\d{1,2}\/\d{1,2}$/.test(v)) return "";
      return v;
    }
    if (field === "tempo"){
      const m = v.match(/(\d{1,3})/);
      if (!m) return "";
      const n = parseInt(m[1], 10);
      if (!(n >= 20 && n <= 320)) return "";
      return String(n);
    }

    // title/composer/style: reject chord-like garbage or label-only values
    if (/^(title|composer|artist|style|tempo|time|key)\s*:?$/i.test(v)) return "";
    if (looksChordy(v)) return "";
    // Cap ridiculous lengths (often PDF garbage)
    if (v.length > 120) v = v.slice(0, 120).trim();
    return v;
  };

  const getLineValue = (labelRe) => {
    const m = text.match(labelRe);
    return m ? m[1] : "";
  };

  const hdr = {
    title: normalizeField("title", getLineValue(/^\s*Title:\s*(.*)$/im)),
    composer: normalizeField("composer", getLineValue(/^\s*(?:Composer|Artist):\s*(.*)$/im)),
    style: normalizeField("style", getLineValue(/^\s*Style:\s*(.*)$/im)),
    tempo: normalizeField("tempo", getLineValue(/^\s*Tempo:\s*(.*)$/im)),
    time: normalizeField("time", getLineValue(/^\s*Time:\s*(.*)$/im)),
    key: normalizeField("key", getLineValue(/^\s*Key:\s*(.*)$/im)),
  };

  // If no explicit Title: and first non-empty line looks like a title, adopt it.
  if (!hdr.title){
    const first = (text.split(/\r?\n/).map(l => l.trim()).find(l => l) || "");
    // Avoid promoting section/marker lines (e.g., "- Intro", "= Verse") to Title.
    const looksLikeMarker = (s) => /^[-=:#;\[]\s*/.test((s||"").trim());
    if (first && !looksLikeMarker(first) && !first.includes(":") && !looksChordy(first) && first.length <= 80){
      hdr.title = normalizeField("title", first);
    }
  }

  if (writeToInputs){
    // Reference the outer-scope `hdr` DOM element map (defined at top of script).
    // The local `hdr` here holds extracted string values; the outer one holds <input> elements.
    const elMap = {
      title: document.getElementById('hdrTitle'),
      composer: document.getElementById('hdrComposer'),
      style: document.getElementById('hdrStyle'),
      tempo: document.getElementById('hdrTempo'),
      time: document.getElementById('hdrTime'),
      key: document.getElementById('hdrKey'),
    };
    for (const k of Object.keys(elMap)){
      const v = hdr[k] || "";
      if (elMap[k] && elMap[k].value !== v) elMap[k].value = v;
    }
  }
  return hdr;
}

function applyHeaderToText(){
  const lines = sourceEl.value.split(/\r?\n/);
  const meta = {
    Title: hdr.title.value.trim(),
    Composer: hdr.composer.value.trim(),
    Key: hdr.key.value.trim(),
    Time: hdr.time.value.trim(),
    Tempo: hdr.tempo.value.trim(),
    Style: hdr.style.value.trim(),
  };

  // remove existing meta lines
  const keep = [];
  for (const line of lines){
    if (/^(Title|Composer|Artist|Key|Time|Tempo|Style)\s*:/i.test(line.trim())) continue;
    keep.push(line);
  }

  const metaLines = [];
  if (meta.Title) metaLines.push(`Title: ${meta.Title}`);
  if (meta.Composer) metaLines.push(`Composer: ${meta.Composer}`);
  if (meta.Style) metaLines.push(`Style: ${meta.Style}`);
  if (meta.Tempo) metaLines.push(`Tempo: ${meta.Tempo}`);
  if (meta.Time) metaLines.push(`Time: ${meta.Time}`);
  if (meta.Key) metaLines.push(`Key: ${meta.Key}`);

  // ensure a blank line after headers if content exists
  const body = keep.join('\n').trimStart();
  const combined = metaLines.join('\n') + (metaLines.length ? '\n\n' : '') + body;

  sourceEl.value = combined.replace(/\n{3,}/g,'\n\n');
}

// readHeaderInputs: read current values from the header form fields.
function readHeaderInputs(){
  return {
    title: hdr.title.value.trim(),
    composer: hdr.composer.value.trim(),
    key: hdr.key.value.trim(),
    time: hdr.time.value.trim(),
    tempo: hdr.tempo.value.trim(),
    style: hdr.style.value.trim(),
  };
}

for (const k of Object.keys(hdr)){
  hdr[k].addEventListener('input', () => {
    applyHeaderToText();
    updatePreview();
  });
}

sourceEl.addEventListener('input', () => {
  extractHeaderFromText(sourceEl.value);
  updatePreview();
});

/* =========================================================
   CSMPN parsing
========================================================= */
function detectNotationPreferenceFromKeyOrText(key, text){
  const k = (key||'').toLowerCase();
  if (k.includes('b')) return 'flat';
  if (k.includes('#')) return 'sharp';
  // fallback: inspect chord tokens
  if (/[A-G][b]/.test(text)) return 'flat';
  if (/[A-G]#/.test(text)) return 'sharp';
  return 'sharp';
}

// ---------------------------------------------------------
// Transposition helpers
// ---------------------------------------------------------
const NOTE_INDEX = new Map([
  ['C',0],['B#',0],
  ['C#',1],['DB',1],
  ['D',2],
  ['D#',3],['EB',3],
  ['E',4],['FB',4],
  ['F',5],['E#',5],
  ['F#',6],['GB',6],
  ['G',7],
  ['G#',8],['AB',8],
  ['A',9],
  ['A#',10],['BB',10],
  ['B',11],['CB',11],
]);

const NOTES_SHARP = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const NOTES_FLAT  = ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];

function transposeNote(note, semis, pref){
  const n = normalizeAccidentals(note).toUpperCase().replace(/\s+/g,'');
  const idx = NOTE_INDEX.get(n);
  if (idx === undefined) return note;

  const t = (idx + (semis % 12) + 12) % 12;
  const arr = (pref === 'flat') ? NOTES_FLAT : NOTES_SHARP;
  return arr[t];
}


function parseCSMPN(text){
  const raw = (text || '').replace(/\r/g,'');
  const lines = raw.split('\n');

  const doc = {
    title: '',
    composer: '',
    style: '',
    tempo: '',
    time: '',
    key: '',
    blocks: []
  };

  const metaRE = /^(Title|Composer|Artist|Style|Tempo|Time|Key)\s*:\s*(.*)$/i;

  // First pass: meta extraction
  const contentLines = [];
  for (const line of lines){
    const m = line.match(metaRE);
    if (m){
      const field = m[1].toLowerCase();
      const val = m[2].trim();
      if (field === 'title') doc.title = val;
      else if (field === 'composer' || field === 'artist') doc.composer = val;
      else if (field === 'style') doc.style = val;
      else if (field === 'tempo') doc.tempo = val;
      else if (field === 'time') doc.time = val;
      else if (field === 'key') doc.key = val;
      continue;
    }
    contentLines.push(line);
  }

  for (const line0 of contentLines){
    const line = line0.trim();
    if (!line) continue;

    // page break
    if (line.startsWith('+')){
      doc.blocks.push({type:'pagebreak'});
      continue;
    }

    // marker lines
    const lead = line[0];
    if (lead === '-' || lead === ':' || lead === '=' || lead === ';' || lead === '#'){
      doc.blocks.push({type:'marker', marker: lead, text: line.slice(1).trim()});
      continue;
    }

    // chord line
    const tokens = tokenizeBars(line0);
    if (tokens.length){
      doc.blocks.push({type:'bars', tokens});
    }
  }

  return doc;
}

function normalizeBarlineDelimiters(line){
  // Accept UG/ChordSheet barline characters and normalize for tokenization
  // «Å / ‚Äñ / ‚à• are treated as double barlines
  return (line || '')
    .replace(/[«Å‚Äñ‚à•]/g, '||')
    .replace(/\|\|:/g, ' ||: ')
    .replace(/:\|\|/g, ' :|| ')
    .replace(/\|:/g, ' |: ')
    .replace(/:\|/g, ' :| ')
    .replace(/\|\]/g, ' |] ')
    .replace(/\|\|/g, ' || ')
    .replace(/\|/g, ' | ')
    .replace(/\s+/g, ' ')
    .trim();
}


function normalizeUGProText(text){
  // Normalizes Ultimate Guitar / UG Pro text exports.
  let t = (text ?? "").toString();
  t = t.replace(/\r\n?/g, "\n");
  t = t.replace(/\u00A0/g, " ");
  t = t.replace(/[\u200B-\u200D\uFEFF]/g, ""); // zero-width
  // Normalize "times" repeat phrasing to xN
  t = t.replace(/\b(times)\s*(two|2)\b/gi, "x2");
  t = t.replace(/\b(times)\s*(three|3)\b/gi, "x3");
  t = t.replace(/\b(times)\s*(four|4)\b/gi, "x4");
  // Normalize unicode bars
  t = t.replace(/[«Å‚à•]/g, "||");
  // Collapse duplicate repeat tokens
  t = t.replace(/\b(x[234])(\s+\1)+\b/gi, "$1");
  // UG sometimes emits "x2 x2)" etc
  t = t.replace(/(\)\s*)\b(x[234])\b\s*\b\2\b/gi, "$1$2");
  // Normalize common quote types
  t = t.replace(/[‚Äú‚Äù]/g, "\"").replace(/[‚Äò‚Äô]/g, "'");
  return t.trim();
}

function tokenizeBars(line){
  // tokenization: keep quoted annotations intact; also supports UG-style barlines
  const s = normalizeBarlineDelimiters(line);
  if (!s) return [];
  const out = [];
  let cur = '';
  let inQuote = false;

  for (let i=0;i<s.length;i++){
    const ch = s[i];
    if (ch === '"'){
      inQuote = !inQuote;
      cur += ch;
      continue;
    }
    if (!inQuote && /\s/.test(ch)){
      if (cur){
        out.push(cur);
        cur = '';
      }
      continue;
    }
    cur += ch;
  }
  if (cur) out.push(cur);

  // If any token still contains barlines (rare PDF extraction cases), explode them.
  const exploded = [];
  for (const t of out){
    if (t.includes('|') && !isBarlineToken(t)){
      let buf = '';
      let i = 0;
      while (i < t.length){
        if (t[i] === '|'){
          if (buf){ exploded.push(buf); buf=''; }
          if (i+1 < t.length && t[i+1] === '|'){
            exploded.push('||'); i += 2; continue;
          } else {
            exploded.push('|'); i += 1; continue;
          }
        }
        buf += t[i];
        i++;
      }
      if (buf) exploded.push(buf);
    } else {
      exploded.push(t);
    }
  }

  return exploded;
}

function isBarlineToken(tok){
  return ['|', '||', '|:', ':|', '||:', ':||', '|]'].includes(tok);
}

function mapBarlineToken(tok){
  switch (tok){
    case '||':
      return 'double';
    case '|:':
    case '||:':
      return 'repeat-start';
    case ':|':
    case ':||':
      return 'repeat-end';
    case '|]':
      return 'final';
    default:
      return 'single';
  }
}

function transposeChordToken(tok, semis, pref){
  // structural tokens
  if (!tok) return tok;
  const upper = tok.toUpperCase();
  if (tok === '%' || tok === '%%' || /^%\d+$/.test(tok)) return tok;
  if (tok === '*' || isBarlineToken(tok)) return tok;
  if (upper === 'N.C.' || upper === 'NC') return tok;
  if (/^\d+\.$/.test(tok)) return tok; // endings marker token itself
  if (tok.startsWith('"') && tok.endsWith('"')) return tok; // annotation token

  // handle repeats: keep punctuation
  const mRepeat = tok.match(/^(\()?(.*?)(\))?(x\d+)?$/);
  if (!mRepeat) return tok;

  const preL = mRepeat[1] || '';
  let core = mRepeat[2] || '';
  const preR = mRepeat[3] || '';
  const rep  = mRepeat[4] || '';

  // split by underscores, commas
  const parts = core.split('_').map(seg => {
    return seg.split(',').map(piece => transposeChordSimple(piece, semis, pref)).join(',');
  }).join('_');

  return preL + parts + preR + rep;
}

function transposeChordSimple(ch, semis, pref){
  const s = ch.trim();
  if (!s) return s;
  // allow directives embedded
  const upper = s.toUpperCase();
  if (upper === 'N.C.' || upper === 'NC') return s;

  const prefix = ['$', 'o', 'O'].includes(s[0]) ? s[0] : '';
  const body = prefix ? s.slice(1) : s;

  const m = body.match(/^([A-G])([b#]?)(.*?)(?:\/([A-G])([b#]?))?$/);
  if (!m) return s;

  const root = m[1] + (m[2]||'');
  const qual = m[3]||'';
  const bass = m[4] ? (m[4] + (m[5]||'')) : '';

  const trRoot = transposeNote(root, semis, pref);
  const trBass = bass ? transposeNote(bass, semis, pref) : '';

  const transposed = trBass ? `${trRoot}${qual}/${trBass}` : `${trRoot}${qual}`;
  return `${prefix}${transposed}`;
}

function transposeWholeText(text, semis){
  const keyMatch = text.match(/^Key:\s*(.+)$/im);
  const key = keyMatch ? keyMatch[1].trim() : '';
  const pref = detectNotationPreferenceFromKeyOrText(key, text);

  const lines = text.split(/\r?\n/);
  const out = [];
  for (const line of lines){
    const m = line.match(/^Key:\s*(.+)$/i);
    if (m){
      const oldKey = m[1].trim();
      const trKey = transposeChordSimple(oldKey, semis, pref);
      out.push(`Key: ${trKey}`);
      continue;
    }

    // preserve marker lines and meta lines except chord payload
    if (/^(Title|Composer|Artist|Style|Tempo|Time)\s*:/i.test(line.trim())){
      out.push(line);
      continue;
    }
    const trimmed = line.trim();
    if (!trimmed){
      out.push(line);
      continue;
    }

    // marker lines
    if (/^[-:=;#\+]/.test(trimmed)){
      out.push(line);
      continue;
    }

    // chord lines: transpose tokens
    const tokens = tokenizeBars(line);
    const t2 = tokens.map(tok => transposeChordToken(tok, semis, pref));
    out.push(t2.join(' '));
  }
  return out.join('\n');
}

/* =========================================================
   Q1 FIX: Repeat Expansion Logic (CRITICAL)
   Expands repeat groups fully to maintain 4-bar-per-row grid
========================================================= */
function parseBarStructures(tokens){
  // Returns flat array of bar objects after expanding repeats.
  // Also consumes UG-style barline tokens: '|' (single) and repeat/final variants.
  const out = [];
  let i = 0;

  let pendingLeft = null;

  const setBoundary = (type) => {
    const prev = out[out.length - 1];
    if (prev && type !== 'repeat-start'){
      prev.rightBar = type;
    }
    pendingLeft = type === 'repeat-end' || type === 'final' ? null : type;
  };

  const readTimes = (tok) => {
    const m = (tok || '').match(/x(\d+)$/i);
    return m ? parseInt(m[1],10) : null;
  };

  const skipBarlines = () => {
    while (i < tokens.length && isBarlineToken(tokens[i])){
      setBoundary(mapBarlineToken(tokens[i]));
      i++;
    }
  };

  while (i < tokens.length){
    let tok = tokens[i];

    if (isBarlineToken(tok)){
      setBoundary(mapBarlineToken(tok));
      i++;
      continue;
    }

    if (/^".*"$/.test(tok) && out.length){
      const prev = out[out.length - 1];
      prev.token = `${prev.token || ''} ${tok}`.trim();
      i++;
      continue;
    }

    // Endings token - associate with next bar (skipping delimiters)
    if (/^\d+\.$/.test(tok)){
      const endingLabel = tok;
      i++;
      skipBarlines();
      if (i < tokens.length){
        const nextTok = tokens[i];
        out.push({
          type:'bar',
          token: nextTok,
          endingLabel,
          leftBar: pendingLeft || 'single',
          rightBar: 'single',
        });
        pendingLeft = null;
        i++;
      }
      continue;
    }

    // Repeat group ( ... )xN
    if (tok.startsWith('(')){
      const groupTokens = [];
      let times = 2;
      let closed = false;

      tok = tok.slice(1);
      if (tok) groupTokens.push(tok);

      i++;
      while (i < tokens.length){
        const t = tokens[i];

        if (isBarlineToken(t)){ i++; continue; }

        if (t.endsWith(')') || /\)x\d+$/i.test(t)){
          const before = t.replace(/\)x\d+$/i,'').replace(/\)$/,'');
          const after = t.match(/\)x(\d+)$/i);
          if (before) groupTokens.push(before);
          if (after) times = parseInt(after[1],10);
          const tIn = readTimes(before) || readTimes(t) || null;
          if (tIn) times = tIn;
          closed = true;
          i++;
          break;
        } else {
          groupTokens.push(t);
          i++;
        }
      }

      if (!closed){
        validationWarnings.push(`‚ö†Ô∏è Unclosed repeat parenthesis - auto-closing`);
      }

      for (let rep=0; rep<times; rep++){
        for (const gt of groupTokens){
          out.push({
            type:'bar',
            token: gt,
            leftBar: pendingLeft || 'single',
            rightBar: 'single',
          });
          pendingLeft = null;
        }
      }
      continue;
    }

    out.push({
      type:'bar',
      token: tok,
      leftBar: pendingLeft || 'single',
      rightBar: 'single',
    });
    pendingLeft = null;
    i++;
  }

  return out;
}


/* =========================================================
   Rendering (ChordSheet-style only)
========================================================= */
function formatChordQuality(quality){
  if (!quality) return '';
  let q = quality;
  q = q.replace(/^maj/i, 'MA');
  q = q.replace(/^ma/i, 'MA');
  q = q.replace(/dim/i, '¬∞');
  q = q.replace(/aug/i, '+');
  return q;
}

function parseChordToken(token){
  const raw = token || '';
  const normalized = normalizeAccidentals(raw);
  const match = normalized.match(/^([A-G])([b#]?)(.*?)(?:\/([A-G])([b#]?))?$/);
  if (!match) return null;
  const root = match[1] + (match[2] || '');
  const quality = match[3] || '';
  const bass = match[4] ? (match[4] + (match[5] || '')) : '';
  const displayRoot = root.replace(/b/g, '‚ô≠').replace(/#/g, '‚ôØ');
  const displayBass = bass.replace(/b/g, '‚ô≠').replace(/#/g, '‚ôØ');
  return {
    root: displayRoot,
    quality: formatChordQuality(quality),
    bass: displayBass,
  };
}

function renderChordToken(token){
  const parsed = parseChordToken(token);
  if (!parsed) return `<span class="chord">${escapeHtml(token)}</span>`;
  const quality = parsed.quality ? `<span class="chord-quality">${escapeHtml(parsed.quality)}</span>` : '';
  const bass = parsed.bass ? `<span class="chord-bass">${escapeHtml(parsed.bass)}</span>` : '';
  return `<span class="chord"><span class="chord-root">${escapeHtml(parsed.root)}</span>${quality}${bass}</span>`;
}

function renderBeatContent(rawBeat){
  const beat = (rawBeat || '').trim();
  if (!beat) return `<span class="beat"><span class="chord">&nbsp;</span></span>`;

  const annotationMatch = beat.match(/"([^"]+)"/);
  const annotation = annotationMatch ? annotationMatch[1] : '';
  const beatWithoutAnnotation = beat.replace(/"[^"]+"/g, '').trim();

  const renderSymbol = (symbol) => `<span class="musicSymbol">${symbol}</span>`;
  const symbolMap = {
    '$': 'ùÑã',
    'segno': 'ùÑã',
    'o': 'ùÑå',
    'O': 'ùÑå',
    'coda': 'ùÑå',
    'fermata': 'ùÑê',
  };

  let chordHtml = '';
  const normalizedBeat = beatWithoutAnnotation.trim();
  const prefixSymbol = normalizedBeat[0];
  const trailingChord = normalizedBeat.slice(1).trim();

  if (!normalizedBeat){
    chordHtml = `<span class="chord">&nbsp;</span>`;
  } else if (normalizedBeat === '%'){
    chordHtml = `<span class="musicSymbol repeatSymbol">ùÑé</span>`;
  } else if (normalizedBeat === '%%'){
    chordHtml = `<span class="musicSymbol repeatSymbol">ùÑè</span>`;
  } else if (symbolMap[normalizedBeat]){
    chordHtml = renderSymbol(symbolMap[normalizedBeat]);
  } else if (symbolMap[prefixSymbol] && trailingChord){
    chordHtml = `${renderSymbol(symbolMap[prefixSymbol])}${renderChordToken(trailingChord)}`;
  } else if (normalizedBeat.toUpperCase() === 'N.C.' || normalizedBeat.toUpperCase() === 'NC'){
    chordHtml = `<span class="chord">${escapeHtml(normalizedBeat)}</span>`;
  } else if (normalizedBeat.toLowerCase() === 'fine'){
    chordHtml = `<span class="musicSymbol"><em>fine</em></span>`;
  } else if (normalizedBeat.toLowerCase().startsWith('d.s')){
    chordHtml = `<span class="musicSymbol"><em>${escapeHtml(normalizedBeat)}</em></span>`;
  } else {
    chordHtml = renderChordToken(normalizedBeat);
  }

  const annotationHtml = annotation ? `<span class="beatAnnotation">${escapeHtml(annotation)}</span>` : '';
  return `<span class="beat">${annotationHtml}${chordHtml}</span>`;
}

function renderBarline(type){
  const t = type || 'single';
  const dots = t === 'repeat-start' || t === 'repeat-end' ? '<span></span>' : '';
  return `<div class="barline ${t}">${dots}</div>`;
}

function renderEndingSegments(segments){
  return segments.map((segment) => {
    const startCol = 2 + segment.start * 2;
    const endCol = 2 + segment.end * 2 + 1;
    return `
      <div class="endingBracket" style="grid-column:${startCol} / ${endCol};">
        <span class="endingLabel">${escapeHtml(segment.label)}.</span>
      </div>`;
  }).join('');
}

function renderDoc(doc){
  // Q5 VALIDATION: Reset warnings
  validationWarnings = [];

  let html = '';
  if (doc.title || doc.style || doc.key || doc.time || doc.tempo || doc.composer){
    const metaBits = [];
    if (doc.style) metaBits.push(doc.style);
    if (doc.key) metaBits.push(`Key of ${doc.key}`);
    const metaLine = metaBits.length ? `<div class="headerMeta">${escapeHtml(metaBits.join(', '))}</div>` : '';
    const composerLine = doc.composer ? `<div class="headerComposer">${escapeHtml(doc.composer)}</div>` : '';
    const tempoLine = doc.tempo ? `<div class="tempoLine">‚ô©=${escapeHtml(doc.tempo)}</div>` : '';
    const timeLine = doc.time ? `<div class="timeSig">${escapeHtml(doc.time)}</div>` : '';
    html += `
      <div class="sheetHeader">
        <div class="headerInfo">
          ${metaLine}
          ${doc.title ? `<div class="songTitle">${escapeHtml(doc.title)}</div>` : ''}
          ${composerLine}
        </div>
        <div class="headerRight">
          ${tempoLine}
          ${timeLine}
        </div>
      </div>`;
  }

  for (const block of doc.blocks){
    if (block.type === 'pagebreak'){
      html += `<div class="pageBreak"></div>`;
      continue;
    }
    if (block.type === 'marker'){
      const t = escapeHtml(block.text || '');
      if (block.marker === '-'){
        html += `<div class="sectionText"><span class="labelBox">${t}</span></div>`;
      } else if (block.marker === ':'){
        html += `<div class="sectionText"><span class="labelBox">${t}</span></div>`;
      } else if (block.marker === '='){
        html += `<div class="dividerRow"><span class="labelBox">${t}</span><div class="rule"></div></div>`;
      } else if (block.marker === ';'){
        html += `<div class="annotation">${t}</div>`;
      } else if (block.marker === '#'){
        html += `<div class="annotation"><span class="small">#</span> ${t}</div>`;
      }
      continue;
    }
    if (block.type === 'bars'){
      html += renderBars(block.tokens);
      continue;
    }
  }

  if (!doc.blocks.length){
    html += `<div style="color:#666; font-size:14px; text-align:center; padding: 40px 10px;">
      Import a file or paste CSMPN to preview.
    </div>`;
  }

  // Q5 VALIDATION: Display warnings if any
  if (validationWarnings.length){
    const warnMsg = validationWarnings.join('\n');
    setStatus(warnMsg, 'warning');
  }

  return html;
}

function renderBars(tokens){
  const bars = parseBarStructures(tokens);

  let html = `<div class="barsBlock">`;
  let activeEnding = null;

  // Render in groups of 4 bars per row (musician-friendly).
  for (let i = 0; i < bars.length; i += 4){
    const row = bars.slice(i, i + 4);

    // Pad to 4
    while (row.length < 4){
      row.push({ token: '', leftBar: 'single', rightBar: 'single' });
    }

    const segments = [];
    let currentLabel = activeEnding;
    let startIndex = currentLabel ? 0 : null;

    row.forEach((bar, idx) => {
      if (bar.endingLabel){
        if (currentLabel !== null && idx > 0){
          segments.push({ label: currentLabel, start: startIndex, end: idx - 1 });
        }
        currentLabel = bar.endingLabel.replace('.', '').trim();
        startIndex = idx;
      }
    });
    if (currentLabel !== null && startIndex !== null){
      segments.push({ label: currentLabel, start: startIndex, end: row.length - 1 });
    }
    activeEnding = currentLabel;
    if (row.some((bar) => ['repeat-end', 'final'].includes(bar.rightBar))){
      activeEnding = null;
    }

    html += `<div class="barlineRow">`;
    html += renderBarline(row[0]?.leftBar || 'single');

    row.forEach((bar) => {
      html += renderMeasure(bar.token || '');
      html += renderBarline(bar.rightBar || 'single');
    });

    html += renderEndingSegments(segments);
    html += `</div>`;
  }

  html += `</div>`;
  return html;
}

function renderMeasure(measureText){
  const raw = (measureText || '').trim();
  if(!raw){
    return `<div class="measure"><div class="beats"><span class="beat"></span></div></div>`;
  }
  const beats = raw.split('_').map(s => s.trim()).filter(Boolean);
  const beatHtml = (beats.length ? beats : [raw]).map((b) => renderBeatContent(b)).join('');
  return `<div class="measure"><div class="beats">${beatHtml}</div></div>`;
}


function updatePreview(){
  const text = sourceEl.value || '';
  const keyMatch = text.match(/^Key:\s*(.+)$/im);
  const key = keyMatch ? keyMatch[1].trim() : '';
  notationPreference = detectNotationPreferenceFromKeyOrText(key, text);

  const doc = parseCSMPN(text);
  previewEl.innerHTML = renderDoc(doc);
}

/* =========================================================
   Q3 FIX: Enhanced PDF Import with X-Coordinate Clustering
   Detects split bars using spatial positioning
========================================================= */
const fileInput = document.getElementById('fileInput');

document.getElementById('btnImport').addEventListener('click', () => {
  fileInput.value = '';
  fileInput.click();
});

fileInput.addEventListener('change', async () => {
  const file = fileInput.files && fileInput.files[0];
  if (!file) return;
  try{
    setStatus(`Importing ${file.name}...`);
    const name = file.name.toLowerCase();
    if (name.endsWith('.pdf')){
      const csmpn = await importUGProPDF(file);
      sourceEl.value = csmpn;
      extractHeaderFromText(csmpn);
      updatePreview();
      return;
    }
    if (name.endsWith('.xml') || name.endsWith('.musicxml')){
      const text = await file.text();
      const csmpn = importMusicXML(text);
      sourceEl.value = csmpn;
      extractHeaderFromText(csmpn);
      updatePreview();
      setStatus('Imported MusicXML.');
      return;
    }
    // txt
    const text = await file.text();
    const csmpn = detectChordPro(text) ? importChordPro(text) : importUGText(text);
    sourceEl.value = csmpn;
    extractHeaderFromText(csmpn);
    updatePreview();
    setStatus('Imported text.');
  }catch(err){
    console.error(err);
    setStatus(`Import failed: ${err?.message || err}`, true);
  }
});

function detectChordPro(text){
  return /\{\s*(title|key|tempo|time)\s*:/i.test(text);
}

function importUGText(text){
  // UG Pro TXT exports can be noisy: headers, blank lines, "times two", duplicate repeats, etc.
  // Goal: produce chord-only CSMPN with 4 bars per line, preserving repeat intent when explicit.
  text = (text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");

  const repeatTokenToN = (t) => {
    if (!t) return null;
    const s = String(t).trim();
    let m = s.match(/^\(\s*x\s*(\d+)\s*\)$/i); // (x2)
    if (m) return parseInt(m[1], 10);
    m = s.match(/^x\s*(\d+)$/i); // x2
    if (m) return parseInt(m[1], 10);
    m = s.match(/^(\d+)\s*x$/i); // 2x
    if (m) return parseInt(m[1], 10);
    return null;
  };

  const parseTimesPhrase = (tokens) => {
    if (!tokens || tokens.length < 2) return null;
    if (String(tokens[0]).toLowerCase() !== "times") return null;
    const v = String(tokens[1]).toLowerCase();
    const map = {one:1,two:2,three:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10};
    if (v in map) return map[v];
    if (/^\d+$/.test(v)) return parseInt(v, 10);
    return null;
  };

  const lines = text.split("\n").map(l => l.trim()).filter(Boolean);

  const out = [];
  for (const line of lines){
    const raw = line.trim();
    if (!raw) continue;

    // Section headings: common UG / chord dump patterns
    let m = raw.match(/^\[(.+?)\]$/); // [Chorus]
    if (m){ out.push(`= ${m[1].trim()}`); continue; }
    m = raw.match(/^[-=]\s*(.+)$/); // - Intro / = Verse
    if (m){ out.push(`= ${m[1].trim()}`); continue; }
    m = raw.match(/^(#{1,6})\s*(.+)$/); // Markdown
    if (m){ out.push(`= ${m[2].trim()}`); continue; }

    // Standalone repeat marker line applies to previous chord line
    const standaloneN = repeatTokenToN(raw) || parseTimesPhrase(raw.split(/\s+/));
    if (standaloneN && out.length){
      const prev = (out[out.length-1] || "").trim();
      if (prev && !/^[=:#;]/.test(prev) && !/^\(.*\)x\d+$/i.test(prev)){
        out[out.length-1] = `(${prev})x${standaloneN}`;
      }
      continue;
    }

    // Tokenize
    let toks = raw.split(/\s+/).filter(Boolean);

    // Strip common UG "times N" that can appear after a chord line
    let repeatN = repeatTokenToN(toks[toks.length-1]);
    if (!repeatN && toks.length >= 2){
      repeatN = parseTimesPhrase(toks.slice(-2));
    }

    // Remove trailing repeat tokens from chord candidates
    if (repeatN){
      if (repeatTokenToN(toks[toks.length-1])) toks = toks.slice(0, -1);
      else if (parseTimesPhrase(toks.slice(-2))) toks = toks.slice(0, -2);
    }

    // Determine if this is chord-dominant
    const chordLike = toks.reduce((acc,t)=>acc + (isChordLikeToken(t) ? 1 : 0), 0);
    if (!toks.length || (chordLike / toks.length) < 0.6) continue;

    // Normalize chords
    const chords = toks.map(t => normalizeChordToken(t)).filter(Boolean);
    if (!chords.length) continue;

    // Convert to 4-bars-per-line CSMPN; if repeatN is present, wrap as a single repeat block
    let block = toCSMPNBars(chords).trim();
    if (repeatN && repeatN > 1){
      // Collapse newlines inside the repeat block for safer syntax: (A B C D)x2
      block = block.replace(/\n+/g, " ").trim();
      out.push(`(${block})x${repeatN}`);
    } else {
      out.push(block);
    }
  }

  return out.join("\n").trim();
}

function importChordPro(text){
  const lines = text.replace(/\r/g,'').split('\n');
  const out = [];
  for (const line0 of lines){
    const line = normalizeAccidentals(line0);

    // directives
    const m = line.match(/^\{\s*([a-z_]+)\s*:\s*(.*?)\s*\}$/i);
    if (m){
      const k = m[1].toLowerCase();
      const v = m[2].trim();
      if (k === 'title') out.unshift(`Title: ${v}`);
      if (k === 'composer' || k === 'artist') out.unshift(`Composer: ${v}`);
      if (k === 'key') out.unshift(`Key: ${v}`);
      if (k === 'time') out.unshift(`Time: ${v}`);
      if (k === 'tempo') out.unshift(`Tempo: ${v}`);
      continue;
    }
    if (!line.trim()) continue;

    // section markers
    const sectionMatch = line.trim().match(/^\{\s*start_of_(chorus|verse|bridge)\s*\}$/i);
    if (sectionMatch){
      out.push(`: ${sectionMatch[1].toUpperCase()}`);
      continue;
    }

    // extract chords in []
    const chords = [];
    const re = /\[([^\]]+)\]/g;
    let mm;
    while ((mm = re.exec(line)) !== null){
      const c = mm[1].trim();
      if (c) chords.push(c);
    }
    if (chords.length){
      out.push(toCSMPNBars(chords));
    }
  }
  setStatus(`Imported ChordPro.`);
  return out.join('\n').replace(/\n{3,}/g,'\n\n');
}

function importMusicXML(xmlText){
  const parser = new DOMParser();
  const xml = parser.parseFromString(xmlText, "application/xml");
  const title = xml.querySelector("work > work-title")?.textContent?.trim() || '';
  const composer = xml.querySelector("identification creator[type='composer']")?.textContent?.trim() || '';
  const keyFifths = xml.querySelector("key fifths")?.textContent?.trim();
  const timeBeats = xml.querySelector("time beats")?.textContent?.trim();
  const timeBeatType = xml.querySelector("time beat-type")?.textContent?.trim();

  const out = [];
  if (title) out.push(`Title: ${title}`);
  if (composer) out.push(`Composer: ${composer}`);
  if (timeBeats && timeBeatType) out.push(`Time: ${timeBeats}/${timeBeatType}`);

  // measures
  const measures = [...xml.querySelectorAll("measure")];
  const bars = [];
  for (const meas of measures){
    const harmonies = [...meas.querySelectorAll("harmony")];
    if (!harmonies.length){
      bars.push('%'); // simile (or *), conservative
      continue;
    }
    // take first harmony as bar chord; if multiple, split bar
    const chords = harmonies.map(h => harmonyToChord(h)).filter(Boolean);
    if (chords.length === 1) bars.push(chords[0]);
    else bars.push(chords.join('_'));
  }

  // chunk into 4 per line
  for (let i=0;i<bars.length;i+=4){
    out.push(bars.slice(i,i+4).join(' '));
  }
  setStatus(`Imported MusicXML: ${measures.length} measure(s).`);
  return out.join('\n');
}

function harmonyToChord(h){
  const step = h.querySelector("root root-step")?.textContent?.trim();
  const alter = h.querySelector("root root-alter")?.textContent?.trim();
  if (!step) return '';
  const acc = alter === '1' ? '#' : (alter === '-1' ? 'b' : '');
  const kindText = h.querySelector("kind")?.getAttribute("text")?.trim() || '';
  const kind = h.querySelector("kind")?.textContent?.trim() || '';
  const bassStep = h.querySelector("bass bass-step")?.textContent?.trim();
  const bassAlter = h.querySelector("bass bass-alter")?.textContent?.trim();
  const bassAcc = bassAlter === '1' ? '#' : (bassAlter === '-1' ? 'b' : '');

  let qual = kindText || kind || '';
  // map a few common MusicXML kinds to chord quality
  const map = {
    'major': '',
    'minor': 'm',
    'dominant': '7',
    'major-seventh': 'maj7',
    'minor-seventh': 'm7',
    'diminished': 'dim',
    'diminished-seventh': 'dim7',
    'augmented': 'aug',
    'half-diminished': 'm7b5'
  };
  if (qual in map) qual = map[qual];

  let chord = `${step}${acc}${qual}`;
  if (bassStep) chord += `/${bassStep}${bassAcc}`;
  return chord;
}

function stripTokenDecorators(t){
  return (t || '')
    .replace(/^\(+/,'')
    .replace(/\)+$/,'')
    .replace(/x\d+$/i,'')
    .trim();
}

// isChordToken: alias used throughout for basic chord detection.
function isChordToken(tok){
  return isChordLikeToken(tok);
}

// Stricter chord token detection to avoid false positives from PDF text (e.g., section labels).
function isChordLikeToken(tok){
  if (!tok) return false;
  let t = normalizeAccidentals(tok)
    .replace(/\u200B/g,'')
    .trim();

  if (t === '%' || t === '%%' || /^%\d+$/.test(t)) return true;
  if (t === '*') return true;
  const upper = t.toUpperCase();
  if (upper === 'N.C.' || upper === 'NC') return true;

  t = stripTokenDecorators(t);
  if (!t) return false;

  const m = t.match(/^([A-G])([b#]?)(.*)$/);
  if (!m) return false;

  const rest = m[3] || '';
  if (!rest) return true;

  const rl = rest.toLowerCase();

  const startsOk =
    /^[0-9#b\/()+.,-]/.test(rest) ||
    rl.startsWith('m') ||
    rl.startsWith('maj') ||
    rl.startsWith('min') ||
    rl.startsWith('dim') ||
    rl.startsWith('aug') ||
    rl.startsWith('sus') ||
    rl.startsWith('add') ||
    rl.startsWith('alt') ||
    rl.startsWith('omit') ||
    rl.startsWith('no');

  if (!startsOk) return false;

  if (/^[a-z]+$/i.test(rest) && rest.length > 3){
    if (!/^(maj|min|dim|aug|sus|add|alt|omit|no|m)$/.test(rl)) return false;
  }

  return /^[A-Za-z0-9#b\/()+.,-Œî√∏√ò¬∞¬∫]*$/.test(rest);
}

function isChordLikeTokenPDF(tok){
  if (!isChordLikeToken(tok)) return false;
  const t = stripTokenDecorators(normalizeAccidentals(tok));
  if (/^[A-G][a-z]{4,}$/i.test(t) && !/[0-9#b]/.test(t)) return false;
  return true;
}



// normalizeChordToken: clean up a raw chord token for CSMPN output.
function normalizeChordToken(tok){
  if (!tok) return '';
  let t = normalizeAccidentals(tok).trim();
  t = stripTokenDecorators(t);
  if (!t) return '';
  if (!isChordLikeToken(t) && t !== '%' && t !== '%%') return '';
  return t;
}

function toCSMPNBars(chords){
  // chords array -> lines of 4 bars
  const toks = chords.map(c => normalizeAccidentals(c)).filter(Boolean);
  const out = [];
  for (let i=0;i<toks.length;i+=4){
    out.push(toks.slice(i,i+4).join(' '));
  }
  return out.join('\n');
}


/* =========================================================
   PDF Import (UG Pro / ChordSheet PDFs)
   - Uses PDF.js text extraction
   - Prefers barline reconstruction when PDFs contain | / ‚Äñ / «Å
   - Falls back to spatial clustering for "floating chord glyph" PDFs
========================================================= */
async function importUGProPDF(file){
  if (!window.pdfjsLib) throw new Error("PDF.js not loaded.");
  statusEl.textContent = "Reading PDF‚Ä¶";
  const arrayBuffer = await file.arrayBuffer();
  const pdfOpts = { data: arrayBuffer };
  // If the worker cannot be configured (common on iOS Safari), fall back to no-worker mode.
  try {
    if (!pdfjsLib?.GlobalWorkerOptions?.workerSrc) pdfOpts.disableWorker = true;
  } catch (e) {
    pdfOpts.disableWorker = true;
  }
  const loadingTask = pdfjsLib.getDocument(pdfOpts);
  const pdf = await loadingTask.promise;

  const meta = { title:"", composer:"", style:"", tempo:"", time:"", key:"" };
  const bodyLines = [];
  let pendingBars = [];

  const flushBars = () => {
    while (pendingBars.length){
      bodyLines.push(pendingBars.splice(0,4).join(" "));
    }
  };

  const normLine = (s) => (s ?? "").toString()
    .replace(/\u00A0/g, " ")
    .replace(/[«Å‚à•]/g, "||")
    .replace(/[‚Äú‚Äù]/g, "\"")
    .replace(/[‚Äò‚Äô]/g, "'")
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim();

  const isBarToken = (t) => /^(\|{1,2})$/.test(t);

  const splitTokens = (line) => {
    // Ensure barlines are tokenized
    let s = normLine(line);
    s = s.replace(/(\|{1,2})/g, " $1 ");
    return s.split(" ").filter(Boolean);
  };

  const looksLikeSection = (line, tokens, chordCount) => {
    if (!line) return false;
    if (chordCount > 0) return false;
    if (line.length > 48) return false;
    // common section words or "Chorus1" style
    if (/^(intro|verse|chorus|bridge|solo|tag|ending|outro|interlude|pre[-\s]?chorus|turnaround)\b/i.test(line)) return true;
    if (/^(chorus|verse|bridge|solo)\s*\d+$/i.test(line)) return true;
    // ALL CAPS markers like DOUBLE-TIME
    if (/^[A-Z][A-Z0-9\-\s]{3,}$/.test(line) && !/TITLE|COMPOSER|STYLE|TEMPO|TIME|KEY/.test(line)) return true;
    // "ENDXXXX" marker
    if (/^END[A-Z0-9\-]+$/.test(line)) return true;
    return false;
  };

  const parseHeaderFromLine = (line) => {
    const m1 = line.match(/^\s*Title:\s*(.*)$/i);
    if (m1) { meta.title = m1[1].trim(); return true; }
    const m2 = line.match(/^\s*(Composer|Artist):\s*(.*)$/i);
    if (m2) { meta.composer = m2[2].trim(); return true; }
    const m3 = line.match(/^\s*Style:\s*(.*)$/i);
    if (m3) { meta.style = m3[1].trim(); return true; }
    const m4 = line.match(/^\s*Tempo:\s*(.*)$/i);
    if (m4) { meta.tempo = m4[1].trim(); return true; }
    const m5 = line.match(/^\s*Time:\s*(.*)$/i);
    if (m5) { meta.time = m5[1].trim(); return true; }
    const m6 = line.match(/^\s*Key:\s*(.*)$/i);
    if (m6) { meta.key = m6[1].trim(); return true; }
    return false;
  };

  for (let p = 1; p <= pdf.numPages; p++){
    statusEl.textContent = `Parsing PDF‚Ä¶ page ${p}/${pdf.numPages}`;
    const page = await pdf.getPage(p);
    const tc = await page.getTextContent();
    const items = tc.items
      .map(it => ({
        str: (it.str ?? "").toString(),
        x: it.transform[4] ?? 0,
        y: it.transform[5] ?? 0
      }))
      .filter(it => it.str && it.str.trim());

    // Cluster by y into "visual lines"
    const buckets = new Map();
    for (const it of items){
      const yk = Math.round(it.y * 2) / 2; // 0.5pt buckets
      if (!buckets.has(yk)) buckets.set(yk, []);
      buckets.get(yk).push(it);
    }

    const yKeys = Array.from(buckets.keys()).sort((a,b) => b-a); // top-to-bottom
    for (const yk of yKeys){
      const lineItems = buckets.get(yk).sort((a,b) => a.x-b.x);
      // Join while preserving short gaps; PDF.js tends to split pipes and chords
      const rawLine = lineItems.map(it => it.str).join(" ");
      const line = normLine(rawLine);
      if (!line) continue;

      // header lines
      if (parseHeaderFromLine(line)) continue;

      const tokens = splitTokens(line);
      const chordTokens = tokens.filter(t => isChordToken(t));
      const chordCount = chordTokens.length;

      // If line has no chords: maybe title / section / ignore
      if (chordCount === 0){
        // candidate title line near top of doc
        if (!meta.title && line.length <= 80 && !line.includes(":") && !/^(page\s*\d+)/i.test(line)){
          meta.title = line;
          continue;
        }
        if (looksLikeSection(line, tokens, chordCount)){
          flushBars();
          let label = line;
          if (/^END([A-Z0-9\-]+)$/.test(line)){
            label = "End " + line.replace(/^END/i,"").replace(/_/g," ");
          }
          bodyLines.push(`- ${label}`);
          continue;
        }
        continue;
      }

      // chord line: build bars
      let bars = [];
      if (tokens.some(t => isBarToken(t))){
        let seg = [];
        for (const t of tokens){
          if (isBarToken(t)){
            if (seg.length){
              bars.push(seg.join("_"));
              seg = [];
            } else {
              // consecutive bars -> empty bar; skip
            }
            continue;
          }
          if (isChordToken(t)) seg.push(t);
        }
        if (seg.length) bars.push(seg.join("_"));
      } else {
        // No explicit bars: assume each chord is a bar
        bars = chordTokens.slice();
      }

      // Append bars
      for (const b of bars){
        if (!b) continue;
        pendingBars.push(b);
      }
    }
  }

  flushBars();

  // Apply normalization / validation to meta and sync UI
  const hdrText = [
    meta.title ? `Title: ${meta.title}` : "",
    meta.composer ? `Composer: ${meta.composer}` : "",
    meta.style ? `Style: ${meta.style}` : "",
    meta.tempo ? `Tempo: ${meta.tempo}` : "",
    meta.time ? `Time: ${meta.time}` : "",
    meta.key ? `Key: ${meta.key}` : ""
  ].filter(Boolean).join("\n");

  // This will sanitize and populate form fields.
  extractHeaderFromText(hdrText, true);

  const hdrVals = readHeaderInputs();
  const hdrLines = [];
  if (hdrVals.title) hdrLines.push(`Title: ${hdrVals.title}`);
  if (hdrVals.composer) hdrLines.push(`Composer: ${hdrVals.composer}`);
  if (hdrVals.style) hdrLines.push(`Style: ${hdrVals.style}`);
  if (hdrVals.tempo) hdrLines.push(`Tempo: ${hdrVals.tempo}`);
  if (hdrVals.time) hdrLines.push(`Time: ${hdrVals.time}`);
  if (hdrVals.key) hdrLines.push(`Key: ${hdrVals.key}`);
  let out = hdrLines.join("\n");
  if (out) out += "\n\n";
  out += bodyLines.join("\n");

  const chordBars = bodyLines.join(" ").split(/\s+/).filter(t => isChordToken(t) || t.includes("_") || t === "%");
  statusEl.textContent = `PDF import: ${chordBars.length} bar(s) extracted from ${pdf.numPages} page(s).`;

  return out.trim();
}

/* =========================================================
   Export / Print / Copy
========================================================= */
document.getElementById('btnTransposeDown').addEventListener('click', () => doTranspose(-1));
document.getElementById('btnTransposeUp').addEventListener('click', () => doTranspose(1));
document.getElementById('btnTransposeReset').addEventListener('click', () => { currentTranspose = 0; updatePreview(); setStatus('Transpose reset.'); });

function doTranspose(delta){
  currentTranspose += delta;
  const tr = transposeWholeText(sourceEl.value, delta);
  sourceEl.value = tr;
  extractHeaderFromText(tr);
  updatePreview();
  setStatus(`Transposed ${currentTranspose >= 0 ? '+' : ''}${currentTranspose} semitone(s).`);
}

document.getElementById('btnPrint').addEventListener('click', () => {
  setStatus('Opening print dialog...');
  window.print();
});

/* =========================================================
   Q4 FIX: jsPDF Download Button for iOS One-Tap Export
========================================================= */
document.getElementById('btnDownloadPdf').addEventListener('click', async () => {
  try{
    document.body.classList.add('exporting');
    setStatus('Rendering PDF‚Ä¶');
    const canvas = await html2canvas(previewEl, {
      scale: 2,
      backgroundColor: '#ffffff',
      logging: false,
      useCORS: true
    });

    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;

    const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'letter' });
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 36; // 0.5 inch

    const imgProps = pdf.getImageProperties(imgData);
    const imgWidth = pageWidth - margin * 2;
    const imgHeight = (imgProps.height * imgWidth) / imgProps.width;

    let heightLeft = imgHeight;
    let position = margin;

    pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);

    heightLeft -= (pageHeight - margin * 2);
    while (heightLeft > 0){
      pdf.addPage();
      position = margin - (imgHeight - heightLeft);
      pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);
      heightLeft -= (pageHeight - margin * 2);
    }

    const filename = safeFilename(hdr.title.value?.trim() || 'chart') + '.pdf';
    const blob = pdf.output('blob');
    const file = new File([blob], filename, { type: 'application/pdf' });
    const shared = await tryShareFile(file);
    if(!shared) downloadBlob(blob, filename);
    setStatus(shared ? 'PDF ready (shared).' : 'PDF downloaded.');
  } catch (e){
    console.error(e);
    setStatus('PDF export failed: ' + (e?.message || e), 'error');
  } finally {
    document.body.classList.remove('exporting');
  }
});

document.getElementById('btnPng').addEventListener('click', async () => {
  try{
    document.body.classList.add('exporting');
    setStatus('Rendering PNG...');
    const canvas = await html2canvas(previewEl, {scale: 2, backgroundColor: '#ffffff'});
    const filename = safeFilename(hdr.title.value?.trim() || 'chordsheet') + '.png';

    await new Promise((resolve, reject) => {
      canvas.toBlob(async (blob) => {
        try{
          if(!blob) throw new Error('PNG blob is empty');
          const file = new File([blob], filename, { type: 'image/png' });
          const shared = await tryShareFile(file);
          if(!shared) downloadBlob(blob, filename);
          setStatus(shared ? 'PNG ready (shared).' : 'PNG downloaded.');
          resolve();
        }catch(e){
          reject(e);
        }
      }, 'image/png');
    });
  }catch(err){
    console.error(err);
    setStatus(`PNG export failed: ${err?.message || err}`, true);
  }finally{
    document.body.classList.remove('exporting');
  }
});


document.getElementById('btnCopy').addEventListener('click', async () => {
  try{
    await navigator.clipboard.writeText(sourceEl.value || '');
    setStatus('CSMPN copied to clipboard.');
  }catch(err){
    setStatus('Copy failed (clipboard permissions).', true);
  }
});

/* =========================================================
   Init
========================================================= */
sourceEl.value = `Title: Sin City Blues
Composer: Czemba
Style: Jazz swing
Tempo: 81
Time: 4/4
Key: Bb

- Verse
Bb % Eb7 %
F7 Bb % %

: Chorus
(Bb_Eb7 F7_Bb)x2

= Bridge
1. Gm7 C7 2. F7 Bb

- Solo Section
Bb Eb7 F7 Bb
Gm7 C7 F7 Bb
`;

extractHeaderFromText(sourceEl.value);
updatePreview();
setStatus('Ready. v1.6 - PDF import fixes applied.');

// --- Optional self-tests (run manually in console): window.runCSMPNSelfTests() ---
window.runCSMPNSelfTests = function(){
  const results = [];
  const assert = (name, cond) => results.push({ name, pass: !!cond });
  try{
    // Header extraction sanity
    const h = extractHeaderFromText("Title: Sin City Blues\nComposer: Czemba\nStyle: Swing\nTempo: 81\nTime: 4/4\nKey: Bb", false);
    assert("header.title", h.title === "Sin City Blues");
    assert("header.key", h.key === "Bb");
    assert("header.tempo", h.tempo === "81");

    // Reject chord-poisoned key
    const h2 = extractHeaderFromText("Key: G G7sus4", false);
    assert("reject chordy key", h2.key === "");

    // UG Pro normalization
    const n = normalizeUGProText("Bb7 | Eb7 | x2 x2\n(times two)\n");
    assert("normalize times two", n.includes("x2"));
    assert("dedupe x2", !/x2\s+x2/i.test(n));

    // Barline delimiter normalization
    const b = normalizeBarlineDelimiters("«Å Bb7 | % |");
    assert("normalize unicode bars", b.includes("||"));

  }catch(e){
    results.push({ name: "exception", pass: false, error: e?.message || String(e) });
  }
  console.table(results);
  return results;
};

</script>
</body>
</html>
