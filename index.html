<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ChordSheet CSMPN Builder v1.2</title>

<!-- PDF.js (required for UG Pro PDF text extraction) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- html2canvas for image/PDF capture -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- jsPDF for optional PDF export (print remains the primary PDF workflow) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<style>
  :root{
    --bg:#f3f4f6;
    --card:#fff
  /* Flow barlines (inline barline layout) */
  .barlineRow{
    display:flex;
    align-items:stretch;
    border-top: 2px solid #111;
    border-bottom: 2px solid #111;
    margin: 10px 0;
  }
  .barSep{
    flex: 0 0 auto;
    display:flex;
    align-items:center;
    justify-content:center;
    padding: 8px 6px;
    font-weight: 900;
    font-size: 20px;
    line-height: 1;
    user-select:none;
  }
  .measure{
    flex: 1 1 0;
    min-width: 0;
    padding: 8px 10px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .measure .beats{
    width:100%;
    display:grid;
    grid-auto-flow:column;
    grid-auto-columns:1fr;
    gap: 10px;
    align-items:center;
    justify-items:center;
    white-space: nowrap;
    overflow:hidden;
    text-overflow: ellipsis;
  }
  .measure .beat{
    font-weight: 900;
  }
  @media (max-width: 520px){
    .barSep{ font-size: 18px; padding: 6px 4px; }
    .measure{ padding: 6px 8px; }
    .measure .beats{ gap: 8px; }
  }
fff;
    --ink:#111827;
    --muted:#6b7280;
    --line:#111827;
    --hair:#d1d5db;
    --soft:#eef2f7;
    --accent:#2563eb;
    --danger:#b91c1c;
    --warning:#f59e0b;
  }

  * { box-sizing: border-box; }
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
  }

  .app{
    max-width: 1100px;
    margin: 0 auto;
    padding: 12px;
  }

  .topbar{
    background: var(--card);
    border: 1px solid var(--hair);
    border-radius: 14px;
    padding: 12px;
    margin-bottom: 10px;
  }

  .title{
    font-weight: 800;
    font-size: 18px;
    margin: 0 0 10px 0;
  }

  .grid{
    display:grid;
    grid-template-columns: 1fr;
    gap: 10px;
  }

  .card{
    background: var(--card);
    border: 1px solid var(--hair);
    border-radius: 14px;
    padding: 12px;
  }

  .row{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:flex-end;
  }
  .field{
    min-width: 140px;
    flex: 1 1 160px;
  }
  label{
    display:block;
    font-size: 12px;
    color: var(--muted);
    margin-bottom: 4px;
  }
  input, select, textarea{
    width:100%;
    padding:10px;
    border: 1px solid var(--hair);
    border-radius: 10px;
    font-size: 14px;
    background: white;
    color: var(--ink);
  }
  textarea{
    min-height: 210px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    font-size: 13px;
    line-height: 1.35;
    resize: vertical;
  }

  .btnrow{
    display:flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
  }
  button{
    border: 0;
    border-radius: 10px;
    padding: 10px 12px;
    font-weight: 700;
    font-size: 14px;
    background: #111827;
    color: white;
    cursor: pointer;
  }
  button.secondary{ background: #374151; }
  button.accent{ background: var(--accent); }
  button.danger{ background: var(--danger); }
  button:disabled{ opacity: .55; cursor:not-allowed; }

  .status{
    margin-top: 10px;
    font-size: 13px;
    padding: 10px;
    border-radius: 10px;
    background: var(--soft);
    border: 1px solid var(--hair);
    color: var(--ink);
    white-space: pre-wrap;
  }
  .status.error{
    border-color: rgba(185,28,28,.35);
    background: rgba(185,28,28,.08);
    color: #7f1d1d;
  }
  .status.warning{
    border-color: rgba(245,158,11,.35);
    background: rgba(245,158,11,.08);
    color: #78350f;
  }

  /* ========= ChordSheet-style preview =========
     Goal: match ChordSheet.com look-and-feel (no boxed fakebook grid). */
  .previewWrap{
    background: var(--card);
    border: 1px solid var(--hair);
    border-radius: 14px;
    padding: 12px;
  }

  .sheet{
    background: white;
    border-radius: 12px;
    padding: 18px;
    color: #000;
  }

  .sheet h1{
    margin:0;
    font-size: 26px;
    font-weight: 800;
    letter-spacing: .2px;
  }

  .meta{
    margin-top: 6px;
    font-size: 14px;
  }
  .metaLine{
    margin: 2px 0;
  }
  .metaLabel{
    font-weight: 800;
  }

  .sectionText{
    margin: 14px 0 6px 0;
    font-size: 18px;
    font-weight: 800;
  }

  .labelBox{
    display:inline-block;
    border: 2px solid #111;
    padding: 6px 10px;
    border-radius: 2px;
    font-weight: 900;
    font-size: 18px;
    background: #fff;
  }

  .dividerRow{
    display:flex;
    align-items:center;
    gap: 10px;
    margin: 14px 0 6px 0;
  }
  .dividerRow .rule{
    height: 2px;
    background:#111;
    flex: 1 1 auto;
  }

  .barsBlock{
    margin-top: 6px;
  }

  .barRow{
    display:flex;
    gap: 0;
    margin: 10px 0;
  }

  /* Each bar is a "cell" with heavy barlines like ChordSheet */
  .bar{
    flex: 1 1 0;
    min-width: 0;
    border-top: 2px solid #111;
    border-bottom: 2px solid #111;
    border-right: 2px solid #111;
    padding: 10px 10px;
    display:flex;
    align-items:center;
    justify-content:flex-start;
    /* Handwritten-like feel on iOS */
    font-family: "MarkerFelt-Wide","MarkerFelt-Thin","Bradley Hand","Comic Sans MS",cursive;
    font-weight: 700;
    font-size: 22px;
    line-height: 1;
  }
  .barRow .bar:first-child{
    border-left: 2px solid #111;
  }

  /* Split bar segments (underscore glue) */
  .barSegments{
    width: 100%;
    display:flex;
    gap: 0;
    align-items:center;
  }
  .seg{
    flex: 1 1 0;
    min-width:0;
    padding: 0 6px;
    display:flex;
    justify-content:flex-start;
    align-items:center;
    white-space: nowrap;
    overflow:hidden;
    text-overflow: ellipsis;
  }
  .seg + .seg{
    border-left: 2px solid #111;
  }

  .small{
    font-size: 16px;
    font-weight: 800;
  }

  .endingLabel{
    position: relative;
    top: -10px;
    font-size: 14px;
    font-weight: 900;
    margin-right: 8px;
  }

  .annotation{
    margin: 8px 0;
    font-size: 15px;
    color:#111;
  }

  .pageBreak{
    page-break-before: always;
    break-before: page;
    height: 1px;
  }

  /* Tips: concise */
  .tips{
    margin-top: 8px;
    font-size: 13px;
    color: var(--muted);
    line-height: 1.35;
  }
  .tips ul{ margin: 8px 0 0 18px; }

  /* Mobile-first layout: stacked editor and preview */
  @media (min-width: 980px){
    .grid{ grid-template-columns: 1fr 1fr; }
    textarea{ min-height: 520px; }
    .previewWrap{ position: sticky; top: 12px; align-self: start; }
  }

  /* Print: show only the sheet */
  @media print{
    body{ background: white; }
    .topbar, .card.editorCard, .tips, .status, .btnrow { display:none !important; }
    .app{ max-width: none; padding: 0; }
    .previewWrap{ border: 0; padding: 0; }
    .sheet{ border-radius: 0; padding: 18px; }
  }

  .bar.doubleLeft{
    border-left: 6px double #111 !important;
  }
  .bar.doubleRight{
    border-right: 6px double #111 !important;
  }

  /* Make the preview naturally page-like and centered */
  .sheet{
    max-width: 8.5in;
    margin: 0 auto;
  }

  @media print{
    @page { size: letter; margin: 0.5in; }
    .sheet{ max-width: none; margin: 0; }
  }

</style>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="title">ChordSheet CSMPN Builder v1.2</div>

    <div class="row">
      <div class="field"><label>Title</label><input id="hdrTitle" placeholder="Song title"></div>
      <div class="field"><label>Composer / Artist</label><input id="hdrComposer" placeholder="Artist / composer"></div>
      <div class="field"><label>Key</label><input id="hdrKey" placeholder="e.g., Bb"></div>
      <div class="field"><label>Time</label><input id="hdrTime" placeholder="e.g., 4/4"></div>
      <div class="field"><label>Tempo</label><input id="hdrTempo" placeholder="e.g., 120"></div>
      <div class="field"><label>Style</label><input id="hdrStyle" placeholder="e.g., Swing"></div>
    </div>

    <div class="btnrow">
      <button class="accent" id="btnImport">Import File → CSMPN</button>
      <button class="secondary" id="btnTransposeDown">Transpose -1</button>
      <button class="secondary" id="btnTransposeUp">Transpose +1</button>
      <button class="secondary" id="btnTransposeReset">Reset Transpose</button>
      <button class="accent" id="btnPrint">Print / Save PDF</button>
      <button class="secondary" id="btnDownloadPdf">Download PDF (iOS)</button>
      <button class="secondary" id="btnPng">Save Image (PNG)</button>
      <button class="secondary" id="btnCopy">Copy CSMPN</button>
    </div>

    <div class="tips">
      <strong>How to use:</strong>
      <ul>
        <li>Import a PDF/TXT/XML, or paste CSMPN in the editor.</li>
        <li>Each chord token is a bar; four bars render per row automatically.</li>
        <li>Use <code>_</code> to split a bar (e.g., <code>Bb_Eb7</code>), <code>%</code> to repeat a bar, and <code>(... )x2</code> for repeats.</li>
        <li>Endings: <code>1. Gm7 C7 2. F7 Bb</code> renders with labels above bars.</li>
        <li>Print is the primary PDF workflow; "Download PDF (iOS)" provides one-tap mobile export.</li>
        <li>You can paste/import barline charts using "|" and "ǁ" – they will be interpreted as measure separators.
If a PDF import yields no chords, it may be image-only (no selectable text).</li>
      </ul>
    </div>

    <div id="status" class="status">Ready. v1.2 - All systems operational.</div>

    <!-- hidden file input -->
    <input id="fileInput" type="file" accept=".pdf,.txt,.xml,.musicxml" style="display:none" />
  </div>

  <div class="grid">
    <div class="card editorCard">
      <label>CSMPN Source (ChordSheet-compatible)</label>
      <textarea id="source"></textarea>
    </div>

    <div class="previewWrap">
      <div id="preview" class="sheet">
        <div style="color:#666; font-size:14px; text-align:center; padding: 40px 10px;">
          Import a file or paste CSMPN to preview.
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================================================
   Core constants / helpers
========================================================= */
const sourceEl = document.getElementById('source');
const previewEl = document.getElementById('preview');
const statusEl = document.getElementById('status');

const hdr = {
  title: document.getElementById('hdrTitle'),
  composer: document.getElementById('hdrComposer'),
  key: document.getElementById('hdrKey'),
  time: document.getElementById('hdrTime'),
  tempo: document.getElementById('hdrTempo'),
  style: document.getElementById('hdrStyle'),
};

let currentTranspose = 0;
let notationPreference = 'sharp'; // recomputed from key/text
let validationWarnings = []; // Q5: Track validation issues

function setStatus(msg, type='info'){
  // Back-compat: older call sites passed boolean (true=error)
  if (type === true) type = 'error';
  if (type === false) type = 'info';

  statusEl.textContent = msg;
  statusEl.classList.remove('error', 'warning');
  if (type === 'error') statusEl.classList.add('error');
  if (type === 'warning') statusEl.classList.add('warning');
}

function escapeHtml(s){
  return (s ?? '').toString()
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'","&#039;");
}

function safeFilename(name, fallback='chart'){
  const base = (name || fallback).toString().trim() || fallback;
  return base
    .replace(/[\\\/\:*?"<>|]+/g,'-')
    .replace(/\s+/g,' ')
    .trim()
    .slice(0, 80);
}

async function tryShareFile(file){
  try{
    if (navigator.canShare && navigator.canShare({ files: [file] })) {
      await navigator.share({ files: [file], title: file.name });
      return true;
    }
  }catch(_e){}
  return false;
}

function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.rel = 'noopener';
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}



function normalizeAccidentals(s){
  return (s ?? '')
    .replace(/♭/g,'b')
    .replace(/♯/g,'#')
    .replace(/\u00A0/g,' ')
    .trim();
}

/* =========================================================
   Phase-1 fixes: Header <-> Source bidirectional sync
========================================================= */
function extractHeaderFromText(text){
  const get = (re) => {
    const m = text.match(re);
    return m ? m[1].trim() : '';
  };
  hdr.title.value    = get(/^Title:\s*(.+)$/im);
  hdr.composer.value = get(/^(?:Composer|Artist):\s*(.+)$/im);
  hdr.key.value      = get(/^Key:\s*(.+)$/im);
  hdr.time.value     = get(/^Time:\s*(.+)$/im);
  hdr.tempo.value    = get(/^Tempo:\s*(.+)$/im);
  hdr.style.value    = get(/^Style:\s*(.+)$/im);
}

function applyHeaderToText(){
  const lines = sourceEl.value.split(/\r?\n/);
  const meta = {
    Title: hdr.title.value.trim(),
    Composer: hdr.composer.value.trim(),
    Key: hdr.key.value.trim(),
    Time: hdr.time.value.trim(),
    Tempo: hdr.tempo.value.trim(),
    Style: hdr.style.value.trim(),
  };

  // remove existing meta lines
  const keep = [];
  for (const line of lines){
    if (/^(Title|Composer|Artist|Key|Time|Tempo|Style)\s*:/i.test(line.trim())) continue;
    keep.push(line);
  }

  const metaLines = [];
  if (meta.Title) metaLines.push(`Title: ${meta.Title}`);
  if (meta.Composer) metaLines.push(`Composer: ${meta.Composer}`);
  if (meta.Style) metaLines.push(`Style: ${meta.Style}`);
  if (meta.Tempo) metaLines.push(`Tempo: ${meta.Tempo}`);
  if (meta.Time) metaLines.push(`Time: ${meta.Time}`);
  if (meta.Key) metaLines.push(`Key: ${meta.Key}`);

  // ensure a blank line after headers if content exists
  const body = keep.join('\n').trimStart();
  const combined = metaLines.join('\n') + (metaLines.length ? '\n\n' : '') + body;

  sourceEl.value = combined.replace(/\n{3,}/g,'\n\n');
}

for (const k of Object.keys(hdr)){
  hdr[k].addEventListener('input', () => {
    applyHeaderToText();
    updatePreview();
  });
}

sourceEl.addEventListener('input', () => {
  extractHeaderFromText(sourceEl.value);
  updatePreview();
});

/* =========================================================
   CSMPN parsing
========================================================= */
function detectNotationPreferenceFromKeyOrText(key, text){
  const k = (key||'').toLowerCase();
  if (k.includes('b')) return 'flat';
  if (k.includes('#')) return 'sharp';
  // fallback: inspect chord tokens
  if (/[A-G][b]/.test(text)) return 'flat';
  if (/[A-G]#/.test(text)) return 'sharp';
  return 'sharp';
}

function parseCSMPN(text){
  const raw = (text || '').replace(/\r/g,'');
  const lines = raw.split('\n');

  const doc = {
    title: '',
    composer: '',
    style: '',
    tempo: '',
    time: '',
    key: '',
    blocks: []
  };

  const metaRE = /^(Title|Composer|Artist|Style|Tempo|Time|Key)\s*:\s*(.*)$/i;

  // First pass: meta extraction
  const contentLines = [];
  for (const line of lines){
    const m = line.match(metaRE);
    if (m){
      const field = m[1].toLowerCase();
      const val = m[2].trim();
      if (field === 'title') doc.title = val;
      else if (field === 'composer' || field === 'artist') doc.composer = val;
      else if (field === 'style') doc.style = val;
      else if (field === 'tempo') doc.tempo = val;
      else if (field === 'time') doc.time = val;
      else if (field === 'key') doc.key = val;
      continue;
    }
    contentLines.push(line);
  }

  for (const line0 of contentLines){
    const line = line0.trim();
    if (!line) continue;

    // page break
    if (line.startsWith('+')){
      doc.blocks.push({type:'pagebreak'});
      continue;
    }

    // marker lines
    const lead = line[0];
    if (lead === '-' || lead === ':' || lead === '=' || lead === ';' || lead === '#'){
      doc.blocks.push({type:'marker', marker: lead, text: line.slice(1).trim()});
      continue;
    }

    // chord line
    const tokens = tokenizeBars(line0);
    if (tokens.length){
      doc.blocks.push({type:'bars', tokens});
    }
  }

  return doc;
}

function normalizeBarlineDelimiters(line){
  // Accept UG/ChordSheet barline characters and normalize for tokenization
  // ǁ / ‖ / ∥ are treated as double barlines
  return (line || '')
    .replace(/[ǁ‖∥]/g, '||')
    .replace(/\|\|/g, ' || ')
    .replace(/\|/g, ' | ')
    .replace(/\s+/g, ' ')
    .trim();
}

function tokenizeBars(line){
  // tokenization: keep quoted annotations intact; also supports UG-style barlines
  const s = normalizeBarlineDelimiters(line);
  if (!s) return [];
  const out = [];
  let cur = '';
  let inQuote = false;

  for (let i=0;i<s.length;i++){
    const ch = s[i];
    if (ch === '"'){
      inQuote = !inQuote;
      cur += ch;
      continue;
    }
    if (!inQuote && /\s/.test(ch)){
      if (cur){
        out.push(cur);
        cur = '';
      }
      continue;
    }
    cur += ch;
  }
  if (cur) out.push(cur);

  // If any token still contains barlines (rare PDF extraction cases), explode them.
  const exploded = [];
  for (const t of out){
    if (t.includes('|') && t !== '|' && t !== '||'){
      let buf = '';
      let i = 0;
      while (i < t.length){
        if (t[i] === '|'){
          if (buf){ exploded.push(buf); buf=''; }
          if (i+1 < t.length && t[i+1] === '|'){
            exploded.push('||'); i += 2; continue;
          } else {
            exploded.push('|'); i += 1; continue;
          }
        }
        buf += t[i];
        i++;
      }
      if (buf) exploded.push(buf);
    } else {
      exploded.push(t);
    }
  }

  return exploded;
}

function transposeChordToken(tok, semis, pref){
  // structural tokens
  if (!tok) return tok;
  const upper = tok.toUpperCase();
  if (tok === '%' || tok === '%%' || /^%\d+$/.test(tok)) return tok;
  if (tok === '*' || tok === '||' || tok === '|' ) return tok;
  if (upper === 'N.C.' || upper === 'NC') return tok;
  if (/^\d+\.$/.test(tok)) return tok; // endings marker token itself
  if (tok.startsWith('"') && tok.endsWith('"')) return tok; // annotation token

  // handle repeats: keep punctuation
  const mRepeat = tok.match(/^(\()?(.*?)(\))?(x\d+)?$/);
  if (!mRepeat) return tok;

  const preL = mRepeat[1] || '';
  let core = mRepeat[2] || '';
  const preR = mRepeat[3] || '';
  const rep  = mRepeat[4] || '';

  // split by underscores, commas
  const parts = core.split('_').map(seg => {
    return seg.split(',').map(piece => transposeChordSimple(piece, semis, pref)).join(',');
  }).join('_');

  return preL + parts + preR + rep;
}

function transposeChordSimple(ch, semis, pref){
  const s = ch.trim();
  if (!s) return s;
  // allow directives embedded
  const upper = s.toUpperCase();
  if (upper === 'N.C.' || upper === 'NC') return s;

  const m = s.match(/^([A-G])([b#]?)(.*?)(?:\/([A-G])([b#]?))?$/);
  if (!m) return s;

  const root = m[1] + (m[2]||'');
  const qual = m[3]||'';
  const bass = m[4] ? (m[4] + (m[5]||'')) : '';

  const trRoot = transposeNote(root, semis, pref);
  const trBass = bass ? transposeNote(bass, semis, pref) : '';

  return trBass ? `${trRoot}${qual}/${trBass}` : `${trRoot}${qual}`;
}

function transposeWholeText(text, semis){
  const keyMatch = text.match(/^Key:\s*(.+)$/im);
  const key = keyMatch ? keyMatch[1].trim() : '';
  const pref = detectNotationPreferenceFromKeyOrText(key, text);

  const lines = text.split(/\r?\n/);
  const out = [];
  for (const line of lines){
    const m = line.match(/^Key:\s*(.+)$/i);
    if (m){
      const oldKey = m[1].trim();
      const trKey = transposeChordSimple(oldKey, semis, pref);
      out.push(`Key: ${trKey}`);
      continue;
    }

    // preserve marker lines and meta lines except chord payload
    if (/^(Title|Composer|Artist|Style|Tempo|Time)\s*:/i.test(line.trim())){
      out.push(line);
      continue;
    }
    const trimmed = line.trim();
    if (!trimmed){
      out.push(line);
      continue;
    }

    // marker lines
    if (/^[-:=;#\+]/.test(trimmed)){
      out.push(line);
      continue;
    }

    // chord lines: transpose tokens
    const tokens = tokenizeBars(line);
    const indent = tokens.indent || 0;
    const t2 = tokens.map(tok => transposeChordToken(tok, semis, pref));
    const prefix = indent ? ('X '.repeat(indent)) : '';
    out.push(prefix + t2.join(' '));
  }
  return out.join('\n');
}

/* =========================================================
   Q1 FIX: Repeat Expansion Logic (CRITICAL)
   Expands repeat groups fully to maintain 4-bar-per-row grid
========================================================= */
function parseBarStructures(tokens){
  // Returns flat array of bar objects after expanding repeats.
  // Also consumes UG-style barline tokens: '|' (single) and '||' (double).
  const out = [];
  let i = 0;

  let pendingDoubleLeft = false;

  const markDoubleBoundary = () => {
    const prev = out[out.length - 1];
    if (prev) prev.doubleRight = true;
    pendingDoubleLeft = true;
  };

  const readTimes = (tok) => {
    const m = (tok || '').match(/x(\d+)$/i);
    return m ? parseInt(m[1],10) : null;
  };

  const skipBarlines = () => {
    while (i < tokens.length && (tokens[i] === '|' || tokens[i] === '||')){
      if (tokens[i] === '||') markDoubleBoundary();
      i++;
    }
  };

  while (i < tokens.length){
    let tok = tokens[i];

    if (tok === '|'){ i++; continue; }
    if (tok === '||'){ markDoubleBoundary(); i++; continue; }

    // Endings token - associate with next bar (skipping delimiters)
    if (/^\d+\.$/.test(tok)){
      const endingLabel = tok;
      i++;
      skipBarlines();
      if (i < tokens.length){
        const nextTok = tokens[i];
        out.push({type:'bar', token: nextTok, endingLabel, doubleLeft: pendingDoubleLeft || false, doubleRight: false});
        pendingDoubleLeft = false;
        i++;
      }
      continue;
    }

    // Repeat group ( ... )xN
    if (tok.startsWith('(')){
      const groupTokens = [];
      let times = 2;
      let closed = false;

      tok = tok.slice(1);
      if (tok) groupTokens.push(tok);

      i++;
      while (i < tokens.length){
        const t = tokens[i];

        if (t === '|' ){ i++; continue; }
        if (t === '||'){ i++; continue; }

        if (t.endsWith(')') || /\)x\d+$/i.test(t)){
          const before = t.replace(/\)x\d+$/i,'').replace(/\)$/,'');
          const after = t.match(/\)x(\d+)$/i);
          if (before) groupTokens.push(before);
          if (after) times = parseInt(after[1],10);
          const tIn = readTimes(before) || readTimes(t) || null;
          if (tIn) times = tIn;
          closed = true;
          i++;
          break;
        } else {
          groupTokens.push(t);
          i++;
        }
      }

      if (!closed){
        validationWarnings.push(`⚠️ Unclosed repeat parenthesis - auto-closing`);
      }

      for (let rep=0; rep<times; rep++){
        for (const gt of groupTokens){
          out.push({type:'bar', token: gt, doubleLeft: pendingDoubleLeft || false, doubleRight: false});
          pendingDoubleLeft = false;
        }
      }
      continue;
    }

    out.push({type:'bar', token: tok, doubleLeft: pendingDoubleLeft || false, doubleRight: false});
    pendingDoubleLeft = false;
    i++;
  }

  return out;
}


/* =========================================================
   Rendering (ChordSheet-style only)
========================================================= */
function renderDoc(doc){
  // Q5 VALIDATION: Reset warnings
  validationWarnings = [];

  let html = '';
  if (doc.title){
    html += `<h1>${escapeHtml(doc.title)}</h1>`;
  }
  const meta = [];
  if (doc.composer) meta.push(`<div class="metaLine"><span class="metaLabel">Composer:</span> ${escapeHtml(doc.composer)}</div>`);
  if (doc.style) meta.push(`<div class="metaLine"><span class="metaLabel">Style:</span> ${escapeHtml(doc.style)}</div>`);
  if (doc.tempo) meta.push(`<div class="metaLine"><span class="metaLabel">Tempo:</span> ${escapeHtml(doc.tempo)}</div>`);
  if (doc.time) meta.push(`<div class="metaLine"><span class="metaLabel">Time:</span> ${escapeHtml(doc.time)}</div>`);
  if (doc.key) meta.push(`<div class="metaLine"><span class="metaLabel">Key:</span> ${escapeHtml(doc.key)}</div>`);
  if (meta.length){
    html += `<div class="meta">${meta.join('')}</div>`;
  }

  for (const block of doc.blocks){
    if (block.type === 'pagebreak'){
      html += `<div class="pageBreak"></div>`;
      continue;
    }
    if (block.type === 'marker'){
      const t = escapeHtml(block.text || '');
      if (block.marker === '-'){
        html += `<div class="sectionText">${t}</div>`;
      } else if (block.marker === ':'){
        html += `<div class="sectionText"><span class="labelBox">${t}</span></div>`;
      } else if (block.marker === '='){
        html += `<div class="dividerRow"><span class="labelBox">${t}</span><div class="rule"></div></div>`;
      } else if (block.marker === ';'){
        html += `<div class="annotation">${t}</div>`;
      } else if (block.marker === '#'){
        html += `<div class="annotation"><span class="small">#</span> ${t}</div>`;
      }
      continue;
    }
    if (block.type === 'bars'){
      html += renderBars(block.tokens);
      continue;
    }
  }

  if (!doc.blocks.length){
    html += `<div style="color:#666; font-size:14px; text-align:center; padding: 40px 10px;">
      Import a file or paste CSMPN to preview.
    </div>`;
  }

  // Q5 VALIDATION: Display warnings if any
  if (validationWarnings.length){
    const warnMsg = validationWarnings.join('\n');
    setStatus(warnMsg, 'warning');
  }

  return html;
}

function renderBars(tokens){
  const bars = parseBarStructures(tokens);
  const indent = tokens.indent || 0;
  let html = `<div class="barsBlock" style="margin-left:${indent * 22}px">`;

  // Render in groups of 4 bars per row (musician-friendly), but do not warn/pad noisily.
  for(let i = 0; i < bars.length; i += 4){
    const row = bars.slice(i, i + 4);
    while(row.length < 4) row.push({ text: '', doubleLeft: false });

    const startsDouble = !!row[0]?.doubleLeft;
    html += `<div class="barlineRow">`;
    html += `<span class="barSep">${startsDouble ? '||' : '|'}</span>`;

    for(const bar of row){
      html += renderMeasure(bar.text);
      html += `<span class="barSep">|</span>`;
    }

    html += `</div>`;
  }

  html += `</div>`;
  return html;
}

function renderMeasure(measureText){
  const raw = (measureText || '').trim();
  if(!raw){
    return `<div class="measure"><div class="beats"><span class="beat"></span></div></div>`;
  }
  const beats = raw.split('_').map(s => s.trim()).filter(Boolean);
  const beatHtml = (beats.length ? beats : [raw]).map(b => `<span class="beat">${escapeHtml(b)}</span>`).join('');
  return `<div class="measure"><div class="beats">${beatHtml}</div></div>`;
}


function renderBar(bar){
  const tok = bar.token ?? '';

  let endingHtml = '';
  if (bar.endingLabel){
    endingHtml = `<span class="endingLabel">${escapeHtml(bar.endingLabel)}</span>`;
  }

  const classes = [
    bar.doubleLeft ? 'doubleLeft' : '',
    bar.doubleRight ? 'doubleRight' : ''
  ].filter(Boolean).join(' ');

  const segs = tok.split('_').map(s => s.trim());

  for (const s of segs){
    if (s && s !== '*' && s !== '%' && s !== '%%' && !s.startsWith('"') && !isChordLikeToken(s)){
      validationWarnings.push(`⚠️ Unknown token "${s}" - rendering as-is`);
    }
  }

  const segHtml = segs.map(s => {
    if (!s || s === '*') return `<div class="seg"></div>`;
    if (s.startsWith('"') && s.endsWith('"')){
      return `<div class="seg small">${escapeHtml(s.slice(1,-1))}</div>`;
    }
    return `<div class="seg">${escapeHtml(s)}</div>`;
  }).join('');

  return `<div class="bar ${classes}">${endingHtml}<div class="barSegments">${segHtml || '<div class="seg"></div>'}</div></div>`;
}

function updatePreview(){
  const text = sourceEl.value || '';
  const keyMatch = text.match(/^Key:\s*(.+)$/im);
  const key = keyMatch ? keyMatch[1].trim() : '';
  notationPreference = detectNotationPreferenceFromKeyOrText(key, text);

  const doc = parseCSMPN(text);
  previewEl.innerHTML = renderDoc(doc);
}

/* =========================================================
   Q3 FIX: Enhanced PDF Import with X-Coordinate Clustering
   Detects split bars using spatial positioning
========================================================= */
const fileInput = document.getElementById('fileInput');

document.getElementById('btnImport').addEventListener('click', () => {
  fileInput.value = '';
  fileInput.click();
});

fileInput.addEventListener('change', async () => {
  const file = fileInput.files && fileInput.files[0];
  if (!file) return;
  try{
    setStatus(`Importing ${file.name}...`);
    const name = file.name.toLowerCase();
    if (name.endsWith('.pdf')){
      const csmpn = await importUGProPDF(file);
      sourceEl.value = csmpn;
      extractHeaderFromText(csmpn);
      updatePreview();
      return;
    }
    if (name.endsWith('.xml') || name.endsWith('.musicxml')){
      const text = await file.text();
      const csmpn = importMusicXML(text);
      sourceEl.value = csmpn;
      extractHeaderFromText(csmpn);
      updatePreview();
      setStatus('Imported MusicXML.');
      return;
    }
    // txt
    const text = await file.text();
    const csmpn = detectChordPro(text) ? importChordPro(text) : importUGText(text);
    sourceEl.value = csmpn;
    extractHeaderFromText(csmpn);
    updatePreview();
    setStatus('Imported text.');
  }catch(err){
    console.error(err);
    setStatus(`Import failed: ${err?.message || err}`, true);
  }
});

function detectChordPro(text){
  return /\{\s*(title|key|tempo|time)\s*:/i.test(text);
}

function importUGText(text){
  const lines = text.replace(/\r/g,'').split('\n');
  const out = [];
  for (const line0 of lines){
    const line = normalizeAccidentals(line0);
    if (!line.trim()) continue;

    // preserve bracket headings [Verse], etc.
    if (/^\[.*\]$/.test(line.trim())){
      out.push(`- ${line.trim().replace(/^[\[]|[\]]$/g,'')}`);
      continue;
    }

    // chord-line heuristic: majority of tokens look like chords or markers
    const toks = line.trim().split(/\s+/);
    const chordLike = toks.filter(isChordLikeToken).length;
    if (toks.length && chordLike / toks.length >= 0.7){
      out.push(toCSMPNBars(toks));
    }
  }

  if (!out.length){
    setStatus('No chord lines detected in text.', true);
    return '';
  }
  setStatus(`Imported UG text: ${out.length} line(s).`);
  return out.join('\n');
}

function importChordPro(text){
  const lines = text.replace(/\r/g,'').split('\n');
  const out = [];
  for (const line0 of lines){
    const line = normalizeAccidentals(line0);

    // directives
    const m = line.match(/^\{\s*([a-z_]+)\s*:\s*(.*?)\s*\}$/i);
    if (m){
      const k = m[1].toLowerCase();
      const v = m[2].trim();
      if (k === 'title') out.unshift(`Title: ${v}`);
      if (k === 'composer' || k === 'artist') out.unshift(`Composer: ${v}`);
      if (k === 'key') out.unshift(`Key: ${v}`);
      if (k === 'time') out.unshift(`Time: ${v}`);
      if (k === 'tempo') out.unshift(`Tempo: ${v}`);
      continue;
    }
    if (!line.trim()) continue;

    // section markers
    if (/^\{\s*start_of_(chorus|verse|bridge)\s*\}$/i.test(line.trim())){
      out.push(`: ${RegExp.$1.toUpperCase()}`);
      continue;
    }

    // extract chords in []
    const chords = [];
    const re = /\[([^\]]+)\]/g;
    let mm;
    while ((mm = re.exec(line)) !== null){
      const c = mm[1].trim();
      if (c) chords.push(c);
    }
    if (chords.length){
      out.push(toCSMPNBars(chords));
    }
  }
  setStatus(`Imported ChordPro.`);
  return out.join('\n').replace(/\n{3,}/g,'\n\n');
}

function importMusicXML(xmlText){
  const parser = new DOMParser();
  const xml = parser.parseFromString(xmlText, "application/xml");
  const title = xml.querySelector("work > work-title")?.textContent?.trim() || '';
  const composer = xml.querySelector("identification creator[type='composer']")?.textContent?.trim() || '';
  const keyFifths = xml.querySelector("key fifths")?.textContent?.trim();
  const timeBeats = xml.querySelector("time beats")?.textContent?.trim();
  const timeBeatType = xml.querySelector("time beat-type")?.textContent?.trim();

  const out = [];
  if (title) out.push(`Title: ${title}`);
  if (composer) out.push(`Composer: ${composer}`);
  if (timeBeats && timeBeatType) out.push(`Time: ${timeBeats}/${timeBeatType}`);

  // measures
  const measures = [...xml.querySelectorAll("measure")];
  const bars = [];
  for (const meas of measures){
    const harmonies = [...meas.querySelectorAll("harmony")];
    if (!harmonies.length){
      bars.push('%'); // simile (or *), conservative
      continue;
    }
    // take first harmony as bar chord; if multiple, split bar
    const chords = harmonies.map(h => harmonyToChord(h)).filter(Boolean);
    if (chords.length === 1) bars.push(chords[0]);
    else bars.push(chords.join('_'));
  }

  // chunk into 4 per line
  for (let i=0;i<bars.length;i+=4){
    out.push(bars.slice(i,i+4).join(' '));
  }
  setStatus(`Imported MusicXML: ${measures.length} measure(s).`);
  return out.join('\n');
}

function harmonyToChord(h){
  const step = h.querySelector("root root-step")?.textContent?.trim();
  const alter = h.querySelector("root root-alter")?.textContent?.trim();
  if (!step) return '';
  const acc = alter === '1' ? '#' : (alter === '-1' ? 'b' : '');
  const kindText = h.querySelector("kind")?.getAttribute("text")?.trim() || '';
  const kind = h.querySelector("kind")?.textContent?.trim() || '';
  const bassStep = h.querySelector("bass bass-step")?.textContent?.trim();
  const bassAlter = h.querySelector("bass bass-alter")?.textContent?.trim();
  const bassAcc = bassAlter === '1' ? '#' : (bassAlter === '-1' ? 'b' : '');

  let qual = kindText || kind || '';
  // map a few common MusicXML kinds to chord quality
  const map = {
    'major': '',
    'minor': 'm',
    'dominant': '7',
    'major-seventh': 'maj7',
    'minor-seventh': 'm7',
    'diminished': 'dim',
    'diminished-seventh': 'dim7',
    'augmented': 'aug',
    'half-diminished': 'm7b5'
  };
  if (map[qual]) qual = map[qual];

  let chord = `${step}${acc}${qual}`;
  if (bassStep) chord += `/${bassStep}${bassAcc}`;
  return chord;
}

function isChordLikeToken(tok){
  if (!tok) return false;
  const t = normalizeAccidentals(tok);
  if (t === '%' || t === '%%' || /^%\d+$/.test(t)) return true;
  if (t === '*' || t.toUpperCase()==='N.C.' || t.toUpperCase()==='NC') return true;
  // root chord
  return /^\(?[A-G](?:b|#)?[a-zA-Z0-9+()#b/.,_-]*\)?(?:x\d+)?$/.test(t);
}

function toCSMPNBars(chords){
  // chords array -> lines of 4 bars
  const toks = chords.map(c => normalizeAccidentals(c)).filter(Boolean);
  const out = [];
  for (let i=0;i<toks.length;i+=4){
    out.push(toks.slice(i,i+4).join(' '));
  }
  return out.join('\n');
}

async function importUGProPDF(file){
  // Strategy:
  // 1) Reconstruct full text lines (best for ChordSheet/UG PDFs that contain '|' barlines).
  // 2) If that fails, fall back to spatial chord clustering (best for UG Pro PDFs with isolated chord glyphs).
  const arrayBuffer = await file.arrayBuffer();
  const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
  const pdf = await loadingTask.promise;

  const allItems = [];
  const reconstructedLines = [];

  for (let p=1; p<=pdf.numPages; p++){
    const page = await pdf.getPage(p);
    const tc = await page.getTextContent();

    const items = tc.items.map(it => {
      const [a,b,c,d,e,f] = it.transform;
      return {
        page: p,
        str: (it.str || '').trim(),
        x: e,
        y: f
      };
    }).filter(it => it.str);

    allItems.push(...items);

    // Cluster into lines by Y
    const buckets = new Map();
    for (const it of items){
      const yKey = Math.round(it.y / 4) * 4; // tolerance
      const key = `${p}:${yKey}`;
      if (!buckets.has(key)) buckets.set(key, []);
      buckets.get(key).push(it);
    }
    const sortedBuckets = Array.from(buckets.entries())
      .sort((a,b) => {
        const ya = parseFloat(a[0].split(':')[1]);
        const yb = parseFloat(b[0].split(':')[1]);
        return yb - ya; // top to bottom
      });

    for (const [k, arr] of sortedBuckets){
      arr.sort((a,b) => a.x - b.x);
      const line = arr.map(x => x.str).join(' ').replace(/\s+/g,' ').trim();
      if (line) reconstructedLines.push(line);
    }
  }

  const hasBarlines = reconstructedLines.some(l => /[|ǁ‖∥]/.test(l));
  if (hasBarlines){
    const csmpn = ugLinesToCSMPN(reconstructedLines);
    if (csmpn && csmpn.trim().length > 20){
      setStatus(`PDF import: parsed ${pdf.numPages} page(s) using text-line reconstruction.`, 'warning');
      return csmpn;
    }
  }

  // Fall back: spatial chord clustering
  const chordItems = allItems
    .map(it => ({...it, str: it.str.replace(/\s+/g,'') }))
    .filter(it => isChordLikeToken(it.str) || (it.str && it.str.includes('|') && /[A-G]/.test(it.str)));

  if (!chordItems.length){
    setStatus('PDF import: no selectable chord text detected. This PDF is likely image-only (scanned).', 'error');
    return '';
  }

  chordItems.sort((a,b) => (a.page-b.page) || (b.y-a.y) || (a.x-b.x));

  const bars = [];
  let splitBarsDetected = 0;

  for (let i=0; i<chordItems.length; i++){
    const current = chordItems[i];

    // Explode embedded barlines in a single token (common in some PDFs)
    if (current.str.includes('|')){
      const parts = tokenizeBars(current.str).filter(t => t !== '|' && t !== '||');
      for (const p of parts) bars.push(p);
      continue;
    }

    // Detect split bars by grouping close-Y neighbors
    const cluster = [current];
    for (let j=i+1; j<chordItems.length; j++){
      const next = chordItems[j];
      if (next.page === current.page &&
          Math.abs(next.y - current.y) < 10 &&
          Math.abs(next.x - current.x) > 5){
        cluster.push(next);
      } else {
        break;
      }
    }

    if (cluster.length > 1){
      const splitBar = cluster.map(c => c.str).join('_');
      bars.push(splitBar);
      splitBarsDetected++;
      i += (cluster.length - 1);
    } else {
      bars.push(current.str);
    }
  }

  const out = [];
  out.push('Title:');
  out.push('Composer:');
  out.push('Time:');
  out.push('Key:');
  out.push('');

  for (let i=0;i<bars.length;i+=4){
    out.push(bars.slice(i,i+4).join(' '));
  }

  const statusMsg = `PDF import: ${bars.length} bar(s) extracted from ${pdf.numPages} page(s).${splitBarsDetected ? `\n${splitBarsDetected} split bar(s) auto-detected.` : ''}\nReview layout and manually add _ for any missed multi-chord bars.`;
  setStatus(statusMsg, 'warning');
  return out.join('\n');
}

// Convert barline-delimited text lines from UG/ChordSheet-like PDFs into CSMPN
function ugLinesToCSMPN(lines){
  const blocks = [];

  let title = '';
  let composer = '';
  let key = '';
  let time = '';
  let tempo = '';
  let style = '';

  const isHeaderLine = (ln) => /^(title|composer|artist|key|tempo|time|style)\s*:/i.test(ln);

  let sawAnyBars = false;

  // First pass: pull header-ish fields
  for (let raw of lines){
    const ln = (raw || '').replace(/\s+/g,' ').trim();
    if (!ln) continue;

    if (/^powered by/i.test(ln)) continue;

    if (!title && !ln.includes(':') && ln.length <= 50 && /^[A-Za-z0-9][A-Za-z0-9 '\-()]+$/.test(ln)){
      title = ln;
      continue;
    }
    if (/^composer\s*:/i.test(ln)) { composer = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^artist\s*:/i.test(ln))   { composer = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^key\s*:/i.test(ln))      { key = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^time\s*:/i.test(ln))     { time = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^tempo\s*:/i.test(ln))    { tempo = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^style\s*:/i.test(ln))    { style = ln.split(':').slice(1).join(':').trim(); continue; }
  }

  // Second pass: build blocks
  for (let raw of lines){
    let ln = (raw || '').replace(/\s+/g,' ').trim();
    if (!ln) continue;
    if (/^powered by/i.test(ln)) continue;
    if (isHeaderLine(ln)) continue;

    if (/[|ǁ‖∥]/.test(ln)){
      const hasChordLetters = /\b[A-G](?:#|b)?/.test(ln);
      if (!hasChordLetters){
        blocks.push(`- ${ln.replace(/^[\-:;=]\s*/,'')}`);
        continue;
      }

      sawAnyBars = true;
      const startsDouble = /^[ǁ‖∥]|^\|\|/.test(ln);

      // Normalize double barline char to leading ||
      ln = ln.replace(/^[ǁ‖∥]/,'||').trim();
      ln = ln.replace(/^\|\|/,'||').trim();
      ln = ln.replace(/[ǁ‖∥]/g,'||');

      const measures = ln.split('|').map(x => x.trim()).filter(Boolean);

      const bars = [];
      if (startsDouble) bars.push('||');

      for (const m of measures){
        const parts = m.split(/\s+/).filter(Boolean);
        if (!parts.length) continue;
        bars.push(parts.length === 1 ? parts[0] : parts.join('_'));
      }

      if (bars.length){
        blocks.push(bars.join(' '));
      }
      continue;
    }

    // Non-barlined text: treat as section/annotation
    if (/^(intro|verse|chorus|bridge|pre-?chorus|tag|outro|turnaround|solo)/i.test(ln)){
      blocks.push(`- ${ln}`);
    } else {
      blocks.push(`; ${ln}`);
    }
  }

  if (!sawAnyBars) return '';

  const header = [];
  header.push(`Title: ${title || ''}`.trimEnd());
  header.push(`Composer: ${composer || ''}`.trimEnd());
  if (style) header.push(`Style: ${style}`);
  if (tempo) header.push(`Tempo: ${tempo}`);
  if (time) header.push(`Time: ${time}`);
  if (key) header.push(`Key: ${key}`);
  header.push('');

  return header.concat(blocks).join('\n');
}

/* =========================================================
   Export / Print / Copy
========================================================= */
document.getElementById('btnTransposeDown').addEventListener('click', () => doTranspose(-1));
document.getElementById('btnTransposeUp').addEventListener('click', () => doTranspose(1));
document.getElementById('btnTransposeReset').addEventListener('click', () => { currentTranspose = 0; updatePreview(); setStatus('Transpose reset.'); });

function doTranspose(delta){
  currentTranspose += delta;
  const tr = transposeWholeText(sourceEl.value, delta);
  sourceEl.value = tr;
  extractHeaderFromText(tr);
  updatePreview();
  setStatus(`Transposed ${currentTranspose >= 0 ? '+' : ''}${currentTranspose} semitone(s).`);
}

document.getElementById('btnPrint').addEventListener('click', () => {
  setStatus('Opening print dialog...');
  window.print();
});

/* =========================================================
   Q4 FIX: jsPDF Download Button for iOS One-Tap Export
========================================================= */
document.getElementById('btnDownloadPdf').addEventListener('click', async () => {
  try{
    setStatus('Rendering PDF…');
    const canvas = await html2canvas(previewEl, {
      scale: 2,
      backgroundColor: '#ffffff',
      logging: false,
      useCORS: true
    });

    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;

    const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'letter' });
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 36; // 0.5 inch

    const imgProps = pdf.getImageProperties(imgData);
    const imgWidth = pageWidth - margin * 2;
    const imgHeight = (imgProps.height * imgWidth) / imgProps.width;

    let heightLeft = imgHeight;
    let position = margin;

    pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);

    heightLeft -= (pageHeight - margin * 2);
    while (heightLeft > 0){
      pdf.addPage();
      position = margin - (imgHeight - heightLeft);
      pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);
      heightLeft -= (pageHeight - margin * 2);
    }

    const filename = safeFilename(docTitle || 'chart') + '.pdf';
    const blob = pdf.output('blob');
    const file = new File([blob], filename, { type: 'application/pdf' });
    const shared = await tryShareFile(file);
    if(!shared) downloadBlob(blob, filename);
    setStatus(shared ? 'PDF ready (shared).' : 'PDF downloaded.');
  } catch (e){
    console.error(e);
    setStatus('PDF export failed: ' + (e?.message || e), 'error');
  }
});

document.getElementById('btnPng').addEventListener('click', async () => {
  try{
    setStatus('Rendering PNG...');
    const canvas = await html2canvas(previewEl, {scale: 2, backgroundColor: '#ffffff'});
    const filename = safeFilename(hdr.title.value?.trim() || 'chordsheet') + '.png';

    await new Promise((resolve, reject) => {
      canvas.toBlob(async (blob) => {
        try{
          if(!blob) throw new Error('PNG blob is empty');
          const file = new File([blob], filename, { type: 'image/png' });
          const shared = await tryShareFile(file);
          if(!shared) downloadBlob(blob, filename);
          setStatus(shared ? 'PNG ready (shared).' : 'PNG downloaded.');
          resolve();
        }catch(e){
          reject(e);
        }
      }, 'image/png');
    });
  }catch(err){
    console.error(err);
    setStatus(`PNG export failed: ${err?.message || err}`, true);
  }
});


document.getElementById('btnCopy').addEventListener('click', async () => {
  try{
    await navigator.clipboard.writeText(sourceEl.value || '');
    setStatus('CSMPN copied to clipboard.');
  }catch(err){
    setStatus('Copy failed (clipboard permissions).', true);
  }
});

/* =========================================================
   Init
========================================================= */
sourceEl.value = `Title: Sin City Blues
Composer: Czemba
Style: Jazz swing
Tempo: 81
Time: 4/4
Key: Bb

- Verse
Bb % Eb7 %
F7 Bb % %

: Chorus
(Bb_Eb7 F7_Bb)x2

= Bridge
1. Gm7 C7 2. F7 Bb

- Solo Section
Bb Eb7 F7 Bb
Gm7 C7 F7 Bb
`;

extractHeaderFromText(sourceEl.value);
updatePreview();
setStatus('Ready. v1.2 - All systems operational.');
</script>
</body>
</html>
