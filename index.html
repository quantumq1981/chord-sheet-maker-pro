<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ChordSheet CSMPN Builder v1.4</title>

<!-- PDF.js (required for UG Pro PDF text extraction) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- html2canvas for image/PDF capture -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- jsPDF for optional PDF export (print remains the primary PDF workflow) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<style>
  :root{
    --bg:#f5f5f5;
    --card:#ffffff;
    --ink:#111111;
    --muted:#5b5b5b;
    --accent:#2563eb;
    --accent2:#111827;
    --border:#d9d9d9;
    --radius:14px;
  }

  *{ box-sizing:border-box; }

  body{
    margin:0;
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
    background:var(--bg);
    color:var(--ink);
  }

  .app{
    max-width:1200px;
    margin:0 auto;
    padding:12px;
  }

  .topbar{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
    margin-bottom:12px;
  }

  .title{
    font-weight:800;
    font-size:20px;
    margin-bottom:10px;
  }

  .row{
    display:grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap:10px;
    margin-bottom:10px;
  }

  .field label{
    display:block;
    font-size:12px;
    color:var(--muted);
    margin-bottom:4px;
    font-weight:700;
  }
  .field input{
    width:100%;
    padding:10px 10px;
    border:1px solid var(--border);
    border-radius:10px;
    font-size:16px;
    background:#fff;
  }

  .btnrow{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    margin:10px 0 8px 0;
  }
  button{
    border:0;
    border-radius:12px;
    padding:12px 14px;
    font-weight:800;
    font-size:16px;
    cursor:pointer;
  }
  button.accent{ background:var(--accent); color:white; }
  button.secondary{ background:var(--accent2); color:white; }

  .tips{
    margin-top:8px;
    font-size:13px;
    color:var(--muted);
    line-height:1.35;
  }
  .tips ul{ margin:8px 0 0 18px; }

  .status{
    margin-top:10px;
    padding:10px 12px;
    border-radius:12px;
    background:#eef2ff;
    border:1px solid #c7d2fe;
    font-weight:700;
  }
  .status.warn{
    background:#fff7ed;
    border-color:#fdba74;
  }
  .status.err{
    background:#fef2f2;
    border-color:#fca5a5;
  }

  .grid{
    display:grid;
    grid-template-columns: 1fr;
    gap:12px;
  }

  .card{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
  }

  textarea{
    width:100%;
    min-height:320px;
    resize:vertical;
    padding:12px;
    border:1px solid var(--border);
    border-radius:12px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:14px;
    line-height:1.35;
    background:#fff;
  }

  .previewWrap{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
  }

  .sheet{
    background:#fff;
    border:1px solid #e5e5e5;
    border-radius:12px;
    padding:18px;
    box-shadow: 0 1px 0 rgba(0,0,0,0.04);
    max-width: 8.5in;
    margin: 0 auto;
  }

  /* ===== Flow (barline) renderer ===== */
  .songTitle{
    font-size:42px;
    font-weight:900;
    margin:0 0 6px 0;
    letter-spacing:-0.02em;
  }

  .metaLine{ margin:2px 0; font-size:14px; }
  .metaLabel{ font-weight:900; }

  .sectionText{
    margin:14px 0 6px 0;
    font-size:18px;
    font-weight:900;
  }

  .barlineRow{
    display:flex;
    flex-wrap:wrap;          /* crucial for portrait phones */
    align-items:baseline;
    gap:0.45rem;
    margin: 8px 0;
  }

  .barSep{
    font-weight:900;
    font-size:18px;
    line-height:1;
  }

  .measure{
    display:inline-flex;
    align-items:baseline;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-weight:800;
    font-size:18px;
    line-height:1.2;
    white-space:nowrap;      /* keep chord tokens intact */
  }

  .measure.split{
    gap: 0.55rem;
  }

  .beats{
    display:inline-flex;
    gap: 0.55rem;
    align-items:baseline;
  }
  .beat{
    display:inline-block;
  }


  .endingLabel{
    font-weight:900;
    margin-right:6px;
  }

  .annotation{
    margin:8px 0;
    font-size:15px;
    color:#111;
  }

  .pageBreak{ page-break-before: always; break-before: page; height:1px; }

  /* Desktop: side-by-side editor and preview */
  @media (min-width: 980px){
    .grid{ grid-template-columns: 1fr 1fr; }
    textarea{ min-height: 520px; }
    .previewWrap{ position: sticky; top: 12px; align-self: start; }
  }

  /* Print: show only the sheet */
  @media print{
    body{ background:white; }
    .topbar, .card.editorCard, .tips, .status, .btnrow { display:none !important; }
    .app{ max-width:none; padding:0; }
    .previewWrap{ border:0; padding:0; }
    .sheet{ border-radius:0; padding:18px; box-shadow:none; }
    @page { size: letter; margin: 0.5in; }
    .sheet{ max-width:none; margin:0; border:0; }
  }
</style>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="title">ChordSheet CSMPN Builder v1.4</div>

    <div class="row">
      <div class="field"><label>Title</label><input id="hdrTitle" placeholder="Song title"></div>
      <div class="field"><label>Composer / Artist</label><input id="hdrComposer" placeholder="Artist / composer"></div>
      <div class="field"><label>Key</label><input id="hdrKey" placeholder="e.g., Bb"></div>
      <div class="field"><label>Time</label><input id="hdrTime" placeholder="e.g., 4/4"></div>
      <div class="field"><label>Tempo</label><input id="hdrTempo" placeholder="e.g., 120"></div>
      <div class="field"><label>Style</label><input id="hdrStyle" placeholder="e.g., Swing"></div>
    </div>

    <div class="btnrow">
      <button class="accent" id="btnImport">Import File → CSMPN</button>
      <button class="secondary" id="btnTransposeDown">Transpose -1</button>
      <button class="secondary" id="btnTransposeUp">Transpose +1</button>
      <button class="secondary" id="btnTransposeReset">Reset Transpose</button>
      <button class="accent" id="btnPrint">Print / Save PDF</button>
      <button class="secondary" id="btnDownloadPdf">Download PDF (iOS)</button>
      <button class="secondary" id="btnPng">Save Image (PNG)</button>
      <button class="secondary" id="btnCopy">Copy CSMPN</button>
    </div>

    <div class="tips">
      <strong>How to use:</strong>
      <ul>
        <li>Import a PDF/TXT/XML, or paste CSMPN in the editor.</li>
        <li>Each chord token is a bar; four bars render per row automatically.</li>
        <li>Use <code>_</code> to split a bar (e.g., <code>Bb_Eb7</code>), <code>%</code> to repeat a bar, and <code>(... )x2</code> for repeats.</li>
        <li>Endings: <code>1. Gm7 C7 2. F7 Bb</code> renders with labels above bars.</li>
        <li>Print is the primary PDF workflow; "Download PDF (iOS)" provides one-tap mobile export.</li>
        <li>You can paste/import barline charts using "|" and "ǁ" – they will be interpreted as measure separators.
If a PDF import yields no chords, it may be image-only (no selectable text).</li>
      </ul>
    </div>

    <div id="status" class="status">Ready. v1.4 - Render fixes applied.</div>

    <!-- hidden file input -->
    <input id="fileInput" type="file" accept=".pdf,.txt,.xml,.musicxml" style="display:none" />
  </div>

  <div class="grid">
    <div class="card editorCard">
      <label>CSMPN Source (ChordSheet-compatible)</label>
      <textarea id="source"></textarea>
    </div>

    <div class="previewWrap">
      <div id="preview" class="sheet">
        <div style="color:#666; font-size:14px; text-align:center; padding: 40px 10px;">
          Import a file or paste CSMPN to preview.
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================================================
   Core constants / helpers
========================================================= */
const sourceEl = document.getElementById('source');
const previewEl = document.getElementById('preview');
const statusEl = document.getElementById('status');

// PDF.js worker config (required when loading PDF.js from a CDN on GitHub Pages)
if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
}

const hdr = {
  title: document.getElementById('hdrTitle'),
  composer: document.getElementById('hdrComposer'),
  key: document.getElementById('hdrKey'),
  time: document.getElementById('hdrTime'),
  tempo: document.getElementById('hdrTempo'),
  style: document.getElementById('hdrStyle'),
};

let currentTranspose = 0;
let notationPreference = 'sharp'; // recomputed from key/text
let validationWarnings = []; // Q5: Track validation issues

function setStatus(msg, type='info'){
  // Back-compat: older call sites passed boolean (true=error)
  if (type === true) type = 'error';
  if (type === false) type = 'info';

  statusEl.textContent = msg;
  statusEl.classList.remove('err', 'warn');
  if (type === 'error') statusEl.classList.add('err');
  if (type === 'warning') statusEl.classList.add('warn');
}

function escapeHtml(s){
  return (s ?? '').toString()
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'","&#039;");
}

function safeFilename(name, fallback='chart'){
  const base = (name || fallback).toString().trim() || fallback;
  return base
    .replace(/[\\\/\:*?"<>|]+/g,'-')
    .replace(/\s+/g,' ')
    .trim()
    .slice(0, 80);
}

async function tryShareFile(file){
  try{
    if (navigator.canShare && navigator.canShare({ files: [file] })) {
      await navigator.share({ files: [file], title: file.name });
      return true;
    }
  }catch(_e){}
  return false;
}

function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.rel = 'noopener';
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}



function normalizeAccidentals(s){
  return (s ?? '')
    .replace(/♭/g,'b')
    .replace(/♯/g,'#')
    .replace(/\u00A0/g,' ')
    .trim();
}

/* =========================================================
   Phase-1 fixes: Header <-> Source bidirectional sync
========================================================= */
function extractHeaderFromText(text){
  const get = (re) => {
    const m = text.match(re);
    return m ? m[1].trim() : '';
  };
  hdr.title.value    = get(/^Title:\s*(.+)$/im);
  hdr.composer.value = get(/^(?:Composer|Artist):\s*(.+)$/im);
  hdr.key.value      = get(/^Key:\s*(.+)$/im);
  hdr.time.value     = get(/^Time:\s*(.+)$/im);
  hdr.tempo.value    = get(/^Tempo:\s*(.+)$/im);
  hdr.style.value    = get(/^Style:\s*(.+)$/im);
}

function applyHeaderToText(){
  const lines = sourceEl.value.split(/\r?\n/);
  const meta = {
    Title: hdr.title.value.trim(),
    Composer: hdr.composer.value.trim(),
    Key: hdr.key.value.trim(),
    Time: hdr.time.value.trim(),
    Tempo: hdr.tempo.value.trim(),
    Style: hdr.style.value.trim(),
  };

  // remove existing meta lines
  const keep = [];
  for (const line of lines){
    if (/^(Title|Composer|Artist|Key|Time|Tempo|Style)\s*:/i.test(line.trim())) continue;
    keep.push(line);
  }

  const metaLines = [];
  if (meta.Title) metaLines.push(`Title: ${meta.Title}`);
  if (meta.Composer) metaLines.push(`Composer: ${meta.Composer}`);
  if (meta.Style) metaLines.push(`Style: ${meta.Style}`);
  if (meta.Tempo) metaLines.push(`Tempo: ${meta.Tempo}`);
  if (meta.Time) metaLines.push(`Time: ${meta.Time}`);
  if (meta.Key) metaLines.push(`Key: ${meta.Key}`);

  // ensure a blank line after headers if content exists
  const body = keep.join('\n').trimStart();
  const combined = metaLines.join('\n') + (metaLines.length ? '\n\n' : '') + body;

  sourceEl.value = combined.replace(/\n{3,}/g,'\n\n');
}

for (const k of Object.keys(hdr)){
  hdr[k].addEventListener('input', () => {
    applyHeaderToText();
    updatePreview();
  });
}

sourceEl.addEventListener('input', () => {
  extractHeaderFromText(sourceEl.value);
  updatePreview();
});

/* =========================================================
   CSMPN parsing
========================================================= */
function detectNotationPreferenceFromKeyOrText(key, text){
  const k = (key||'').toLowerCase();
  if (k.includes('b')) return 'flat';
  if (k.includes('#')) return 'sharp';
  // fallback: inspect chord tokens
  if (/[A-G][b]/.test(text)) return 'flat';
  if (/[A-G]#/.test(text)) return 'sharp';
  return 'sharp';
}

// ---------------------------------------------------------
// Transposition helpers
// ---------------------------------------------------------
const NOTE_INDEX = new Map([
  ['C',0],['B#',0],
  ['C#',1],['DB',1],
  ['D',2],
  ['D#',3],['EB',3],
  ['E',4],['FB',4],
  ['F',5],['E#',5],
  ['F#',6],['GB',6],
  ['G',7],
  ['G#',8],['AB',8],
  ['A',9],
  ['A#',10],['BB',10],
  ['B',11],['CB',11],
]);

const NOTES_SHARP = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const NOTES_FLAT  = ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];

function transposeNote(note, semis, pref){
  const n = normalizeAccidentals(note).toUpperCase().replace(/\s+/g,'');
  const idx = NOTE_INDEX.get(n);
  if (idx === undefined) return note;

  const t = (idx + (semis % 12) + 12) % 12;
  const arr = (pref === 'flat') ? NOTES_FLAT : NOTES_SHARP;
  return arr[t];
}


function parseCSMPN(text){
  const raw = (text || '').replace(/\r/g,'');
  const lines = raw.split('\n');

  const doc = {
    title: '',
    composer: '',
    style: '',
    tempo: '',
    time: '',
    key: '',
    blocks: []
  };

  const metaRE = /^(Title|Composer|Artist|Style|Tempo|Time|Key)\s*:\s*(.*)$/i;

  // First pass: meta extraction
  const contentLines = [];
  for (const line of lines){
    const m = line.match(metaRE);
    if (m){
      const field = m[1].toLowerCase();
      const val = m[2].trim();
      if (field === 'title') doc.title = val;
      else if (field === 'composer' || field === 'artist') doc.composer = val;
      else if (field === 'style') doc.style = val;
      else if (field === 'tempo') doc.tempo = val;
      else if (field === 'time') doc.time = val;
      else if (field === 'key') doc.key = val;
      continue;
    }
    contentLines.push(line);
  }

  for (const line0 of contentLines){
    const line = line0.trim();
    if (!line) continue;

    // page break
    if (line.startsWith('+')){
      doc.blocks.push({type:'pagebreak'});
      continue;
    }

    // marker lines
    const lead = line[0];
    if (lead === '-' || lead === ':' || lead === '=' || lead === ';' || lead === '#'){
      doc.blocks.push({type:'marker', marker: lead, text: line.slice(1).trim()});
      continue;
    }

    // chord line
    const tokens = tokenizeBars(line0);
    if (tokens.length){
      doc.blocks.push({type:'bars', tokens});
    }
  }

  return doc;
}

function normalizeBarlineDelimiters(line){
  // Accept UG/ChordSheet barline characters and normalize for tokenization
  // ǁ / ‖ / ∥ are treated as double barlines
  return (line || '')
    .replace(/[ǁ‖∥]/g, '||')
    .replace(/\|\|/g, ' || ')
    .replace(/\|/g, ' | ')
    .replace(/\s+/g, ' ')
    .trim();
}

function tokenizeBars(line){
  // tokenization: keep quoted annotations intact; also supports UG-style barlines
  const s = normalizeBarlineDelimiters(line);
  if (!s) return [];
  const out = [];
  let cur = '';
  let inQuote = false;

  for (let i=0;i<s.length;i++){
    const ch = s[i];
    if (ch === '"'){
      inQuote = !inQuote;
      cur += ch;
      continue;
    }
    if (!inQuote && /\s/.test(ch)){
      if (cur){
        out.push(cur);
        cur = '';
      }
      continue;
    }
    cur += ch;
  }
  if (cur) out.push(cur);

  // If any token still contains barlines (rare PDF extraction cases), explode them.
  const exploded = [];
  for (const t of out){
    if (t.includes('|') && t !== '|' && t !== '||'){
      let buf = '';
      let i = 0;
      while (i < t.length){
        if (t[i] === '|'){
          if (buf){ exploded.push(buf); buf=''; }
          if (i+1 < t.length && t[i+1] === '|'){
            exploded.push('||'); i += 2; continue;
          } else {
            exploded.push('|'); i += 1; continue;
          }
        }
        buf += t[i];
        i++;
      }
      if (buf) exploded.push(buf);
    } else {
      exploded.push(t);
    }
  }

  return exploded;
}

function transposeChordToken(tok, semis, pref){
  // structural tokens
  if (!tok) return tok;
  const upper = tok.toUpperCase();
  if (tok === '%' || tok === '%%' || /^%\d+$/.test(tok)) return tok;
  if (tok === '*' || tok === '||' || tok === '|' ) return tok;
  if (upper === 'N.C.' || upper === 'NC') return tok;
  if (/^\d+\.$/.test(tok)) return tok; // endings marker token itself
  if (tok.startsWith('"') && tok.endsWith('"')) return tok; // annotation token

  // handle repeats: keep punctuation
  const mRepeat = tok.match(/^(\()?(.*?)(\))?(x\d+)?$/);
  if (!mRepeat) return tok;

  const preL = mRepeat[1] || '';
  let core = mRepeat[2] || '';
  const preR = mRepeat[3] || '';
  const rep  = mRepeat[4] || '';

  // split by underscores, commas
  const parts = core.split('_').map(seg => {
    return seg.split(',').map(piece => transposeChordSimple(piece, semis, pref)).join(',');
  }).join('_');

  return preL + parts + preR + rep;
}

function transposeChordSimple(ch, semis, pref){
  const s = ch.trim();
  if (!s) return s;
  // allow directives embedded
  const upper = s.toUpperCase();
  if (upper === 'N.C.' || upper === 'NC') return s;

  const m = s.match(/^([A-G])([b#]?)(.*?)(?:\/([A-G])([b#]?))?$/);
  if (!m) return s;

  const root = m[1] + (m[2]||'');
  const qual = m[3]||'';
  const bass = m[4] ? (m[4] + (m[5]||'')) : '';

  const trRoot = transposeNote(root, semis, pref);
  const trBass = bass ? transposeNote(bass, semis, pref) : '';

  return trBass ? `${trRoot}${qual}/${trBass}` : `${trRoot}${qual}`;
}

function transposeWholeText(text, semis){
  const keyMatch = text.match(/^Key:\s*(.+)$/im);
  const key = keyMatch ? keyMatch[1].trim() : '';
  const pref = detectNotationPreferenceFromKeyOrText(key, text);

  const lines = text.split(/\r?\n/);
  const out = [];
  for (const line of lines){
    const m = line.match(/^Key:\s*(.+)$/i);
    if (m){
      const oldKey = m[1].trim();
      const trKey = transposeChordSimple(oldKey, semis, pref);
      out.push(`Key: ${trKey}`);
      continue;
    }

    // preserve marker lines and meta lines except chord payload
    if (/^(Title|Composer|Artist|Style|Tempo|Time)\s*:/i.test(line.trim())){
      out.push(line);
      continue;
    }
    const trimmed = line.trim();
    if (!trimmed){
      out.push(line);
      continue;
    }

    // marker lines
    if (/^[-:=;#\+]/.test(trimmed)){
      out.push(line);
      continue;
    }

    // chord lines: transpose tokens
    const tokens = tokenizeBars(line);
    const indent = tokens.indent || 0;
    const t2 = tokens.map(tok => transposeChordToken(tok, semis, pref));
    const prefix = indent ? ('X '.repeat(indent)) : '';
    out.push(prefix + t2.join(' '));
  }
  return out.join('\n');
}

/* =========================================================
   Q1 FIX: Repeat Expansion Logic (CRITICAL)
   Expands repeat groups fully to maintain 4-bar-per-row grid
========================================================= */
function parseBarStructures(tokens){
  // Returns flat array of bar objects after expanding repeats.
  // Also consumes UG-style barline tokens: '|' (single) and '||' (double).
  const out = [];
  let i = 0;

  let pendingDoubleLeft = false;

  const markDoubleBoundary = () => {
    const prev = out[out.length - 1];
    if (prev) prev.doubleRight = true;
    pendingDoubleLeft = true;
  };

  const readTimes = (tok) => {
    const m = (tok || '').match(/x(\d+)$/i);
    return m ? parseInt(m[1],10) : null;
  };

  const skipBarlines = () => {
    while (i < tokens.length && (tokens[i] === '|' || tokens[i] === '||')){
      if (tokens[i] === '||') markDoubleBoundary();
      i++;
    }
  };

  while (i < tokens.length){
    let tok = tokens[i];

    if (tok === '|'){ i++; continue; }
    if (tok === '||'){ markDoubleBoundary(); i++; continue; }

    // Endings token - associate with next bar (skipping delimiters)
    if (/^\d+\.$/.test(tok)){
      const endingLabel = tok;
      i++;
      skipBarlines();
      if (i < tokens.length){
        const nextTok = tokens[i];
        out.push({type:'bar', token: nextTok, endingLabel, doubleLeft: pendingDoubleLeft || false, doubleRight: false});
        pendingDoubleLeft = false;
        i++;
      }
      continue;
    }

    // Repeat group ( ... )xN
    if (tok.startsWith('(')){
      const groupTokens = [];
      let times = 2;
      let closed = false;

      tok = tok.slice(1);
      if (tok) groupTokens.push(tok);

      i++;
      while (i < tokens.length){
        const t = tokens[i];

        if (t === '|' ){ i++; continue; }
        if (t === '||'){ i++; continue; }

        if (t.endsWith(')') || /\)x\d+$/i.test(t)){
          const before = t.replace(/\)x\d+$/i,'').replace(/\)$/,'');
          const after = t.match(/\)x(\d+)$/i);
          if (before) groupTokens.push(before);
          if (after) times = parseInt(after[1],10);
          const tIn = readTimes(before) || readTimes(t) || null;
          if (tIn) times = tIn;
          closed = true;
          i++;
          break;
        } else {
          groupTokens.push(t);
          i++;
        }
      }

      if (!closed){
        validationWarnings.push(`⚠️ Unclosed repeat parenthesis - auto-closing`);
      }

      for (let rep=0; rep<times; rep++){
        for (const gt of groupTokens){
          out.push({type:'bar', token: gt, doubleLeft: pendingDoubleLeft || false, doubleRight: false});
          pendingDoubleLeft = false;
        }
      }
      continue;
    }

    out.push({type:'bar', token: tok, doubleLeft: pendingDoubleLeft || false, doubleRight: false});
    pendingDoubleLeft = false;
    i++;
  }

  return out;
}


/* =========================================================
   Rendering (ChordSheet-style only)
========================================================= */
function renderDoc(doc){
  // Q5 VALIDATION: Reset warnings
  validationWarnings = [];

  let html = '';
  if (doc.title){
    html += `<div class="songTitle">${escapeHtml(doc.title)}</div>`;
  }
  const meta = [];
  if (doc.composer) meta.push(`<div class="metaLine"><span class="metaLabel">Composer:</span> ${escapeHtml(doc.composer)}</div>`);
  if (doc.style) meta.push(`<div class="metaLine"><span class="metaLabel">Style:</span> ${escapeHtml(doc.style)}</div>`);
  if (doc.tempo) meta.push(`<div class="metaLine"><span class="metaLabel">Tempo:</span> ${escapeHtml(doc.tempo)}</div>`);
  if (doc.time) meta.push(`<div class="metaLine"><span class="metaLabel">Time:</span> ${escapeHtml(doc.time)}</div>`);
  if (doc.key) meta.push(`<div class="metaLine"><span class="metaLabel">Key:</span> ${escapeHtml(doc.key)}</div>`);
  if (meta.length){
    html += `<div class="meta">${meta.join('')}</div>`;
  }

  for (const block of doc.blocks){
    if (block.type === 'pagebreak'){
      html += `<div class="pageBreak"></div>`;
      continue;
    }
    if (block.type === 'marker'){
      const t = escapeHtml(block.text || '');
      if (block.marker === '-'){
        html += `<div class="sectionText">${t}</div>`;
      } else if (block.marker === ':'){
        html += `<div class="sectionText"><span class="labelBox">${t}</span></div>`;
      } else if (block.marker === '='){
        html += `<div class="dividerRow"><span class="labelBox">${t}</span><div class="rule"></div></div>`;
      } else if (block.marker === ';'){
        html += `<div class="annotation">${t}</div>`;
      } else if (block.marker === '#'){
        html += `<div class="annotation"><span class="small">#</span> ${t}</div>`;
      }
      continue;
    }
    if (block.type === 'bars'){
      html += renderBars(block.tokens);
      continue;
    }
  }

  if (!doc.blocks.length){
    html += `<div style="color:#666; font-size:14px; text-align:center; padding: 40px 10px;">
      Import a file or paste CSMPN to preview.
    </div>`;
  }

  // Q5 VALIDATION: Display warnings if any
  if (validationWarnings.length){
    const warnMsg = validationWarnings.join('\n');
    setStatus(warnMsg, 'warning');
  }

  return html;
}

function renderBars(tokens){
  const bars = parseBarStructures(tokens);
  const indent = tokens.indent || 0;

  let html = `<div class="barsBlock" style="margin-left:${indent * 22}px">`;

  // Render in groups of 4 bars per row (musician-friendly).
  for (let i = 0; i < bars.length; i += 4){
    const row = bars.slice(i, i + 4);

    // Pad to 4
    while (row.length < 4){
      row.push({ token: '', doubleLeft: false, doubleRight: false });
    }

    const startsDouble = !!row[0]?.doubleLeft;

    html += `<div class="barlineRow">`;
    html += `<span class="barSep">${startsDouble ? '||' : '|'}</span>`;

    for (const bar of row){
      const label = bar.endingLabel ? `${bar.endingLabel} ` : '';
      const txt = label + (bar.token || '');
      html += renderMeasure(txt);

      // Respect doubleRight boundaries (e.g., from '||' in source)
      html += `<span class="barSep">${bar.doubleRight ? '||' : '|'}</span>`;
    }

    html += `</div>`;
  }

  html += `</div>`;
  return html;
}

function renderMeasure(measureText){
  const raw = (measureText || '').trim();
  if(!raw){
    return `<div class="measure"><div class="beats"><span class="beat"></span></div></div>`;
  }
  const beats = raw.split('_').map(s => s.trim()).filter(Boolean);
  const beatHtml = (beats.length ? beats : [raw]).map(b => `<span class="beat">${escapeHtml(b)}</span>`).join('');
  return `<div class="measure"><div class="beats">${beatHtml}</div></div>`;
}


function renderBar(bar){
  const tok = bar.token ?? '';

  let endingHtml = '';
  if (bar.endingLabel){
    endingHtml = `<span class="endingLabel">${escapeHtml(bar.endingLabel)}</span>`;
  }

  const classes = [
    bar.doubleLeft ? 'doubleLeft' : '',
    bar.doubleRight ? 'doubleRight' : ''
  ].filter(Boolean).join(' ');

  const segs = tok.split('_').map(s => s.trim());

  for (const s of segs){
    if (s && s !== '*' && s !== '%' && s !== '%%' && !s.startsWith('"') && !isChordLikeToken(s)){
      validationWarnings.push(`⚠️ Unknown token "${s}" - rendering as-is`);
    }
  }

  const segHtml = segs.map(s => {
    if (!s || s === '*') return `<div class="seg"></div>`;
    if (s.startsWith('"') && s.endsWith('"')){
      return `<div class="seg small">${escapeHtml(s.slice(1,-1))}</div>`;
    }
    return `<div class="seg">${escapeHtml(s)}</div>`;
  }).join('');

  return `<div class="bar ${classes}">${endingHtml}<div class="barSegments">${segHtml || '<div class="seg"></div>'}</div></div>`;
}

function updatePreview(){
  const text = sourceEl.value || '';
  const keyMatch = text.match(/^Key:\s*(.+)$/im);
  const key = keyMatch ? keyMatch[1].trim() : '';
  notationPreference = detectNotationPreferenceFromKeyOrText(key, text);

  const doc = parseCSMPN(text);
  previewEl.innerHTML = renderDoc(doc);
}

/* =========================================================
   Q3 FIX: Enhanced PDF Import with X-Coordinate Clustering
   Detects split bars using spatial positioning
========================================================= */
const fileInput = document.getElementById('fileInput');

document.getElementById('btnImport').addEventListener('click', () => {
  fileInput.value = '';
  fileInput.click();
});

fileInput.addEventListener('change', async () => {
  const file = fileInput.files && fileInput.files[0];
  if (!file) return;
  try{
    setStatus(`Importing ${file.name}...`);
    const name = file.name.toLowerCase();
    if (name.endsWith('.pdf')){
      const csmpn = await importUGProPDF(file);
      sourceEl.value = csmpn;
      extractHeaderFromText(csmpn);
      updatePreview();
      return;
    }
    if (name.endsWith('.xml') || name.endsWith('.musicxml')){
      const text = await file.text();
      const csmpn = importMusicXML(text);
      sourceEl.value = csmpn;
      extractHeaderFromText(csmpn);
      updatePreview();
      setStatus('Imported MusicXML.');
      return;
    }
    // txt
    const text = await file.text();
    const csmpn = detectChordPro(text) ? importChordPro(text) : importUGText(text);
    sourceEl.value = csmpn;
    extractHeaderFromText(csmpn);
    updatePreview();
    setStatus('Imported text.');
  }catch(err){
    console.error(err);
    setStatus(`Import failed: ${err?.message || err}`, true);
  }
});

function detectChordPro(text){
  return /\{\s*(title|key|tempo|time)\s*:/i.test(text);
}

function importUGText(text){
  const lines = text.replace(/\r/g,'').split('\n');
  const out = [];
  for (const line0 of lines){
    const line = normalizeAccidentals(line0);
    if (!line.trim()) continue;

    // preserve bracket headings [Verse], etc.
    if (/^\[.*\]$/.test(line.trim())){
      out.push(`- ${line.trim().replace(/^[\[]|[\]]$/g,'')}`);
      continue;
    }

    // chord-line heuristic: majority of tokens look like chords or markers
    const toks = line.trim().split(/\s+/);
    const chordLike = toks.filter(isChordLikeToken).length;
    if (toks.length && chordLike / toks.length >= 0.7){
      out.push(toCSMPNBars(toks));
    }
  }

  if (!out.length){
    setStatus('No chord lines detected in text.', true);
    return '';
  }
  setStatus(`Imported UG text: ${out.length} line(s).`);
  return out.join('\n');
}

function importChordPro(text){
  const lines = text.replace(/\r/g,'').split('\n');
  const out = [];
  for (const line0 of lines){
    const line = normalizeAccidentals(line0);

    // directives
    const m = line.match(/^\{\s*([a-z_]+)\s*:\s*(.*?)\s*\}$/i);
    if (m){
      const k = m[1].toLowerCase();
      const v = m[2].trim();
      if (k === 'title') out.unshift(`Title: ${v}`);
      if (k === 'composer' || k === 'artist') out.unshift(`Composer: ${v}`);
      if (k === 'key') out.unshift(`Key: ${v}`);
      if (k === 'time') out.unshift(`Time: ${v}`);
      if (k === 'tempo') out.unshift(`Tempo: ${v}`);
      continue;
    }
    if (!line.trim()) continue;

    // section markers
    if (/^\{\s*start_of_(chorus|verse|bridge)\s*\}$/i.test(line.trim())){
      out.push(`: ${RegExp.$1.toUpperCase()}`);
      continue;
    }

    // extract chords in []
    const chords = [];
    const re = /\[([^\]]+)\]/g;
    let mm;
    while ((mm = re.exec(line)) !== null){
      const c = mm[1].trim();
      if (c) chords.push(c);
    }
    if (chords.length){
      out.push(toCSMPNBars(chords));
    }
  }
  setStatus(`Imported ChordPro.`);
  return out.join('\n').replace(/\n{3,}/g,'\n\n');
}

function importMusicXML(xmlText){
  const parser = new DOMParser();
  const xml = parser.parseFromString(xmlText, "application/xml");
  const title = xml.querySelector("work > work-title")?.textContent?.trim() || '';
  const composer = xml.querySelector("identification creator[type='composer']")?.textContent?.trim() || '';
  const keyFifths = xml.querySelector("key fifths")?.textContent?.trim();
  const timeBeats = xml.querySelector("time beats")?.textContent?.trim();
  const timeBeatType = xml.querySelector("time beat-type")?.textContent?.trim();

  const out = [];
  if (title) out.push(`Title: ${title}`);
  if (composer) out.push(`Composer: ${composer}`);
  if (timeBeats && timeBeatType) out.push(`Time: ${timeBeats}/${timeBeatType}`);

  // measures
  const measures = [...xml.querySelectorAll("measure")];
  const bars = [];
  for (const meas of measures){
    const harmonies = [...meas.querySelectorAll("harmony")];
    if (!harmonies.length){
      bars.push('%'); // simile (or *), conservative
      continue;
    }
    // take first harmony as bar chord; if multiple, split bar
    const chords = harmonies.map(h => harmonyToChord(h)).filter(Boolean);
    if (chords.length === 1) bars.push(chords[0]);
    else bars.push(chords.join('_'));
  }

  // chunk into 4 per line
  for (let i=0;i<bars.length;i+=4){
    out.push(bars.slice(i,i+4).join(' '));
  }
  setStatus(`Imported MusicXML: ${measures.length} measure(s).`);
  return out.join('\n');
}

function harmonyToChord(h){
  const step = h.querySelector("root root-step")?.textContent?.trim();
  const alter = h.querySelector("root root-alter")?.textContent?.trim();
  if (!step) return '';
  const acc = alter === '1' ? '#' : (alter === '-1' ? 'b' : '');
  const kindText = h.querySelector("kind")?.getAttribute("text")?.trim() || '';
  const kind = h.querySelector("kind")?.textContent?.trim() || '';
  const bassStep = h.querySelector("bass bass-step")?.textContent?.trim();
  const bassAlter = h.querySelector("bass bass-alter")?.textContent?.trim();
  const bassAcc = bassAlter === '1' ? '#' : (bassAlter === '-1' ? 'b' : '');

  let qual = kindText || kind || '';
  // map a few common MusicXML kinds to chord quality
  const map = {
    'major': '',
    'minor': 'm',
    'dominant': '7',
    'major-seventh': 'maj7',
    'minor-seventh': 'm7',
    'diminished': 'dim',
    'diminished-seventh': 'dim7',
    'augmented': 'aug',
    'half-diminished': 'm7b5'
  };
  if (map[qual]) qual = map[qual];

  let chord = `${step}${acc}${qual}`;
  if (bassStep) chord += `/${bassStep}${bassAcc}`;
  return chord;
}

function isChordLikeToken(tok){
  if (!tok) return false;
  const t = normalizeAccidentals(tok);
  if (t === '%' || t === '%%' || /^%\d+$/.test(t)) return true;
  if (t === '*' || t.toUpperCase()==='N.C.' || t.toUpperCase()==='NC') return true;
  // root chord
  return /^\(?[A-G](?:b|#)?[a-zA-Z0-9+()#b/.,_-]*\)?(?:x\d+)?$/.test(t);
}

function toCSMPNBars(chords){
  // chords array -> lines of 4 bars
  const toks = chords.map(c => normalizeAccidentals(c)).filter(Boolean);
  const out = [];
  for (let i=0;i<toks.length;i+=4){
    out.push(toks.slice(i,i+4).join(' '));
  }
  return out.join('\n');
}


/* =========================================================
   PDF Import (UG Pro / ChordSheet PDFs)
   - Uses PDF.js text extraction
   - Prefers barline reconstruction when PDFs contain | / ‖ / ǁ
   - Falls back to spatial clustering for "floating chord glyph" PDFs
========================================================= */
async function importUGProPDF(file){
  if (!window.pdfjsLib) throw new Error('PDF.js failed to load (pdfjsLib missing).');

  // Strategy:
  // 1) Reconstruct full text lines (best for PDFs that contain '|' barlines).
  // 2) If that fails, fall back to spatial chord clustering.
  const arrayBuffer = await file.arrayBuffer();
  const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
  const pdf = await loadingTask.promise;

  const allItems = [];
  const reconstructedLines = [];

  for (let p=1; p<=pdf.numPages; p++){
    const page = await pdf.getPage(p);
    const tc = await page.getTextContent();

    const items = tc.items.map(it => {
      const t = it.transform || [1,0,0,1,0,0];
      const e = t[4] ?? 0;
      const f = t[5] ?? 0;
      return {
        page: p,
        str: (it.str || '').trim(),
        x: e,
        y: f
      };
    }).filter(it => it.str);

    allItems.push(...items);

    // Cluster into lines by Y (tolerance buckets)
    const buckets = new Map();
    for (const it of items){
      const yKey = Math.round(it.y / 4) * 4;
      const key = `${p}:${yKey}`;
      if (!buckets.has(key)) buckets.set(key, []);
      buckets.get(key).push(it);
    }

    // Sort top-to-bottom
    const sortedBuckets = Array.from(buckets.entries())
      .sort((a,b) => {
        const ya = parseFloat(a[0].split(':')[1]);
        const yb = parseFloat(b[0].split(':')[1]);
        return yb - ya;
      });

    for (const [_k, arr] of sortedBuckets){
      arr.sort((a,b) => a.x - b.x);
      const line = arr.map(x => x.str).join(' ').replace(/\s+/g,' ').trim();
      if (line) reconstructedLines.push(line);
    }
  }

  const hasBarlines = reconstructedLines.some(l => /[|ǁ‖∥]/.test(l));
  if (hasBarlines){
    const csmpn = ugLinesToCSMPN(reconstructedLines);
    if (csmpn && csmpn.trim().length > 20){
      setStatus(`PDF import: parsed ${pdf.numPages} page(s) using text-line reconstruction.`, 'warning');
      return csmpn;
    }
  }

  // Fall back: spatial chord clustering
  const chordItems = allItems
    .map(it => ({...it, str: (it.str || '').replace(/\s+/g,'') }))
    .filter(it => isChordLikeToken(it.str) || (it.str && it.str.includes('|') && /[A-G]/.test(it.str)));

  if (!chordItems.length){
    setStatus('PDF import: no selectable chord text detected. This PDF is likely image-only (scanned).', 'error');
    return '';
  }

  chordItems.sort((a,b) => (a.page-b.page) || (b.y-a.y) || (a.x-b.x));

  const bars = [];
  let splitBarsDetected = 0;

  for (let i=0; i<chordItems.length; i++){
    const current = chordItems[i];

    // Explode embedded barlines in a single token (common in some PDFs)
    if (current.str.includes('|') || /[ǁ‖∥]/.test(current.str)){
      const parts = tokenizeBars(current.str).filter(t => t !== '|' && t !== '||');
      for (const p of parts) bars.push(p);
      continue;
    }

    // Detect split bars by grouping close-Y neighbors
    const cluster = [current];
    for (let j=i+1; j<chordItems.length; j++){
      const next = chordItems[j];
      if (next.page === current.page &&
          Math.abs(next.y - current.y) < 10 &&
          Math.abs(next.x - current.x) > 5){
        cluster.push(next);
      } else {
        break;
      }
    }

    if (cluster.length > 1){
      const splitBar = cluster.map(c => c.str).join('_');
      bars.push(splitBar);
      splitBarsDetected++;
      i += (cluster.length - 1);
    } else {
      bars.push(current.str);
    }
  }

  const out = [];
  out.push('Title:');
  out.push('Composer:');
  out.push('Style:');
  out.push('Tempo:');
  out.push('Time:');
  out.push('Key:');
  out.push('');

  for (let i=0;i<bars.length;i+=4){
    out.push(bars.slice(i,i+4).join(' '));
  }

  const statusMsg = `PDF import: ${bars.length} bar(s) extracted from ${pdf.numPages} page(s).` +
    (splitBarsDetected ? `\n${splitBarsDetected} split bar(s) auto-detected.` : '') +
    `\nIf any multi-chord bars were missed, add "_" manually (e.g., Dm7_G7).`;
  setStatus(statusMsg, 'warning');
  return out.join('\n');
}

// Convert barline-delimited text lines from UG/ChordSheet-like PDFs into CSMPN
function ugLinesToCSMPN(lines){
  const blocks = [];

  let title = '';
  let composer = '';
  let key = '';
  let time = '';
  let tempo = '';
  let style = '';

  const isHeaderLine = (ln) => /^(title|composer|artist|key|tempo|time|style)\s*:/i.test(ln);

  let sawAnyBars = false;

  // First pass: pull header-ish fields
  for (let raw of lines){
    const ln = (raw || '').replace(/\s+/g,' ').trim();
    if (!ln) continue;
    if (/^powered by/i.test(ln)) continue;

    if (!title && !ln.includes(':') && ln.length <= 60 && /^[A-Za-z0-9][A-Za-z0-9 '\-()]+$/.test(ln)){
      title = ln;
      continue;
    }
    if (/^composer\s*:/i.test(ln)) { composer = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^artist\s*:/i.test(ln))   { composer = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^key\s*:/i.test(ln))      { key = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^time\s*:/i.test(ln))     { time = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^tempo\s*:/i.test(ln))    { tempo = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^style\s*:/i.test(ln))    { style = ln.split(':').slice(1).join(':').trim(); continue; }
  }

  // Second pass: build blocks
  for (let raw of lines){
    let ln = (raw || '').replace(/\s+/g,' ').trim();
    if (!ln) continue;
    if (/^powered by/i.test(ln)) continue;
    if (isHeaderLine(ln)) continue;

    if (/[|ǁ‖∥]/.test(ln)){
      const hasChordLetters = /\b[A-G](?:#|b)?/.test(ln);
      if (!hasChordLetters){
        blocks.push(`- ${ln.replace(/^[\-:;=]\s*/,'')}`);
        continue;
      }

      sawAnyBars = true;
      const startsDouble = /^[ǁ‖∥]|^\|\|/.test(ln);

      // Normalize double barline chars
      ln = ln.replace(/^[ǁ‖∥]/,'||').trim();
      ln = ln.replace(/[ǁ‖∥]/g,'||');

      // Split measures on single barline char
      const measures = ln.split('|').map(x => x.trim()).filter(Boolean);

      const bars = [];
      if (startsDouble) bars.push('||');

      for (const m of measures){
        const parts = m.split(/\s+/).filter(Boolean);
        if (!parts.length) continue;
        bars.push(parts.length === 1 ? parts[0] : parts.join('_'));
      }

      if (bars.length){
        blocks.push(bars.join(' '));
      }
      continue;
    }

    // Non-barlined text: treat as section/annotation
    if (/^(intro|verse|chorus|bridge|pre-?chorus|tag|outro|turnaround|solo)/i.test(ln)){
      blocks.push(`- ${ln}`);
    } else {
      blocks.push(`; ${ln}`);
    }
  }

  if (!sawAnyBars) return '';

  const header = [];
  header.push(`Title: ${title || ''}`.trimEnd());
  header.push(`Composer: ${composer || ''}`.trimEnd());
  if (style) header.push(`Style: ${style}`);
  if (tempo) header.push(`Tempo: ${tempo}`);
  if (time) header.push(`Time: ${time}`);
  if (key) header.push(`Key: ${key}`);
  header.push('');

  return header.concat(blocks).join('\n');
}


/* =========================================================
   Export / Print / Copy
========================================================= */
document.getElementById('btnTransposeDown').addEventListener('click', () => doTranspose(-1));
document.getElementById('btnTransposeUp').addEventListener('click', () => doTranspose(1));
document.getElementById('btnTransposeReset').addEventListener('click', () => { currentTranspose = 0; updatePreview(); setStatus('Transpose reset.'); });

function doTranspose(delta){
  currentTranspose += delta;
  const tr = transposeWholeText(sourceEl.value, delta);
  sourceEl.value = tr;
  extractHeaderFromText(tr);
  updatePreview();
  setStatus(`Transposed ${currentTranspose >= 0 ? '+' : ''}${currentTranspose} semitone(s).`);
}

document.getElementById('btnPrint').addEventListener('click', () => {
  setStatus('Opening print dialog...');
  window.print();
});

/* =========================================================
   Q4 FIX: jsPDF Download Button for iOS One-Tap Export
========================================================= */
document.getElementById('btnDownloadPdf').addEventListener('click', async () => {
  try{
    setStatus('Rendering PDF…');
    const canvas = await html2canvas(previewEl, {
      scale: 2,
      backgroundColor: '#ffffff',
      logging: false,
      useCORS: true
    });

    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;

    const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'letter' });
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 36; // 0.5 inch

    const imgProps = pdf.getImageProperties(imgData);
    const imgWidth = pageWidth - margin * 2;
    const imgHeight = (imgProps.height * imgWidth) / imgProps.width;

    let heightLeft = imgHeight;
    let position = margin;

    pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);

    heightLeft -= (pageHeight - margin * 2);
    while (heightLeft > 0){
      pdf.addPage();
      position = margin - (imgHeight - heightLeft);
      pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);
      heightLeft -= (pageHeight - margin * 2);
    }

    const filename = safeFilename(hdr.title.value?.trim() || 'chart') + '.pdf';
    const blob = pdf.output('blob');
    const file = new File([blob], filename, { type: 'application/pdf' });
    const shared = await tryShareFile(file);
    if(!shared) downloadBlob(blob, filename);
    setStatus(shared ? 'PDF ready (shared).' : 'PDF downloaded.');
  } catch (e){
    console.error(e);
    setStatus('PDF export failed: ' + (e?.message || e), 'error');
  }
});

document.getElementById('btnPng').addEventListener('click', async () => {
  try{
    setStatus('Rendering PNG...');
    const canvas = await html2canvas(previewEl, {scale: 2, backgroundColor: '#ffffff'});
    const filename = safeFilename(hdr.title.value?.trim() || 'chordsheet') + '.png';

    await new Promise((resolve, reject) => {
      canvas.toBlob(async (blob) => {
        try{
          if(!blob) throw new Error('PNG blob is empty');
          const file = new File([blob], filename, { type: 'image/png' });
          const shared = await tryShareFile(file);
          if(!shared) downloadBlob(blob, filename);
          setStatus(shared ? 'PNG ready (shared).' : 'PNG downloaded.');
          resolve();
        }catch(e){
          reject(e);
        }
      }, 'image/png');
    });
  }catch(err){
    console.error(err);
    setStatus(`PNG export failed: ${err?.message || err}`, true);
  }
});


document.getElementById('btnCopy').addEventListener('click', async () => {
  try{
    await navigator.clipboard.writeText(sourceEl.value || '');
    setStatus('CSMPN copied to clipboard.');
  }catch(err){
    setStatus('Copy failed (clipboard permissions).', true);
  }
});

/* =========================================================
   Init
========================================================= */
sourceEl.value = `Title: Sin City Blues
Composer: Czemba
Style: Jazz swing
Tempo: 81
Time: 4/4
Key: Bb

- Verse
Bb % Eb7 %
F7 Bb % %

: Chorus
(Bb_Eb7 F7_Bb)x2

= Bridge
1. Gm7 C7 2. F7 Bb

- Solo Section
Bb Eb7 F7 Bb
Gm7 C7 F7 Bb
`;

extractHeaderFromText(sourceEl.value);
updatePreview();
setStatus('Ready. v1.4 - Render fixes applied.');
</script>
</body>
</html>
