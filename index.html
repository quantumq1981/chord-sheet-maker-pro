<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ChordSheet CSMPN Builder v1.6.4.2</title>

<!-- PDF.js (required for UG Pro PDF text extraction) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- html2canvas for image/PDF capture -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- jsPDF for optional PDF export (print remains the primary PDF workflow) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<style>
  :root{
    --bg:#f5f5f5;
    --card:#ffffff;
    --ink:#111111;
    --muted:#5b5b5b;
    --accent:#2563eb;
    --accent2:#111827;
    --border:#d9d9d9;
    --radius:14px;
  }

  *{ box-sizing:border-box; }

  body{
    margin:0;
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
    background:var(--bg);
    color:var(--ink);
  }

  .app{
    max-width:1200px;
    margin:0 auto;
    padding:12px;
  }

  .topbar{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
    margin-bottom:12px;
  }

  .title{
    font-weight:800;
    font-size:20px;
    margin-bottom:10px;
  }

  .row{
    display:grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap:10px;
    margin-bottom:10px;
  }

  .field label{
    display:block;
    font-size:12px;
    color:var(--muted);
    margin-bottom:4px;
    font-weight:700;
  }
  .field input{
    width:100%;
    padding:10px 10px;
    border:1px solid var(--border);
    border-radius:10px;
    font-size:16px;
    background:#fff;
  }

  .btnrow{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    margin:10px 0 8px 0;
  }
  button{
    border:0;
    border-radius:12px;
    padding:12px 14px;
    font-weight:800;
    font-size:16px;
    cursor:pointer;
  }
  button.accent{ background:var(--accent); color:white; }
  button.secondary{ background:var(--accent2); color:white; }

  .tips{
    margin-top:8px;
    font-size:13px;
    color:var(--muted);
    line-height:1.35;
  }
  .tips ul{ margin:8px 0 0 18px; }

  .status{
    margin-top:10px;
    padding:10px 12px;
    border-radius:12px;
    background:#eef2ff;
    border:1px solid #c7d2fe;
    font-weight:700;
  }
  .status.warn{
    background:#fff7ed;
    border-color:#fdba74;
  }
  .status.err{
    background:#fef2f2;
    border-color:#fca5a5;
  }

  .grid{
    display:grid;
    grid-template-columns: 1fr;
    gap:12px;
  }

  .card{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
  }

  textarea{
    width:100%;
    min-height:320px;
    resize:vertical;
    padding:12px;
    border:1px solid var(--border);
    border-radius:12px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:14px;
    line-height:1.35;
    background:#fff;
  }

  .previewWrap{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
  }

  .sheet{
    background:#fff;
    border:1px solid #e5e5e5;
    border-radius:12px;
    padding:18px;
    box-shadow: 0 1px 0 rgba(0,0,0,0.04);
    max-width: 8.5in;
    margin: 0 auto;
  }

  /* ===== Flow (barline) renderer ===== */
  .songTitle{
    font-size:42px;
    font-weight:900;
    margin:0 0 6px 0;
    letter-spacing:-0.02em;
  }

  .metaLine{ margin:2px 0; font-size:14px; }
  .metaLabel{ font-weight:900; }

  .sectionText{
    margin:14px 0 6px 0;
    font-size:18px;
    font-weight:900;
  }

  .barlineRow{
    display:flex;
    flex-wrap:wrap;          /* crucial for portrait phones */
    align-items:baseline;
    gap:0.45rem;
    margin: 8px 0;
  }

  .barSep{
    font-weight:900;
    font-size:18px;
    line-height:1;
  }

  .measure{
    display:inline-flex;
    align-items:baseline;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-weight:800;
    font-size:18px;
    line-height:1.2;
    white-space:nowrap;      /* keep chord tokens intact */
  }

  .measure.split{
    gap: 0.55rem;
  }

  .beats{
    display:inline-flex;
    gap: 0.55rem;
    align-items:baseline;
  }
  .beat{
    display:inline-block;
  }


  .endingLabel{
    font-weight:900;
    margin-right:6px;
  }

  .annotation{
    margin:8px 0;
    font-size:15px;
    color:#111;
  }

  .pageBreak{ page-break-before: always; break-before: page; height:1px; }

  /* Desktop: side-by-side editor and preview */
  @media (min-width: 980px){
    .grid{ grid-template-columns: 1fr 1fr; }
    textarea{ min-height: 520px; }
    .previewWrap{ position: sticky; top: 12px; align-self: start; }
  }

  /* Print: show only the sheet */
  
/* Export fidelity: flatten UI chrome for PDF/PNG captures */
body.exporting .card{
  border: none !important;
  box-shadow: none !important;
  border-radius: 0 !important;
  padding: 0 !important;
  margin: 0 !important;
}
body.exporting #renderTarget{
  padding: 0 !important;
  margin: 0 !important;
  background: #fff !important;
}
body.exporting .sheet{
  padding: 36px 42px !important; /* ~0.5in */
}

/* Chord-sheet.com-like typography (preview + export) */
.songTitle{
  font-size: 48px !important;
  font-weight: 900 !important;
  letter-spacing: -0.5px;
  margin: 0 0 8px 0 !important;
}
.metaLine{
  font-size: 16px !important;
  line-height: 1.35 !important;
  margin: 2px 0 !important;
}
.metaLabel{
  font-weight: 800 !important;
  display: inline-block;
  min-width: 78px;
}
.sectionText{
  font-size: 22px !important;
  font-weight: 900 !important;
  margin: 18px 0 8px 0 !important;
}
.barText{
  font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace !important;
  font-size: 18px !important;
  font-weight: 700 !important;
  line-height: 1.6 !important;
}

@media print{
    body{ background:white; }
    .topbar, .card.editorCard, .tips, .status, .btnrow { display:none !important; }
    .app{ max-width:none; padding:0; }
    .previewWrap{ border:0; padding:0; }
    .sheet{ border-radius:0; padding:18px; box-shadow:none; }
    @page { size: letter; margin: 0.5in; }
    .sheet{ max-width:none; margin:0; border:0; }
  }
</style>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="title">ChordSheet CSMPN Builder v1.6.4.2</div>

    <div class="row">
      <div class="field"><label>Title</label><input id="hdrTitle" placeholder="Song title"></div>
      <div class="field"><label>Composer / Artist</label><input id="hdrComposer" placeholder="Artist / composer"></div>
      <div class="field"><label>Key</label><input id="hdrKey" placeholder="e.g., Bb"></div>
      <div class="field"><label>Time</label><input id="hdrTime" placeholder="e.g., 4/4"></div>
      <div class="field"><label>Tempo</label><input id="hdrTempo" placeholder="e.g., 120"></div>
      <div class="field"><label>Style</label><input id="hdrStyle" placeholder="e.g., Swing"></div>
    </div>

    <div class="btnrow">
      <button class="accent" id="btnImport">Import File → CSMPN</button>
      <button class="secondary" id="btnTransposeDown">Transpose -1</button>
      <button class="secondary" id="btnTransposeUp">Transpose +1</button>
      <button class="secondary" id="btnTransposeReset">Reset Transpose</button>
      <button class="accent" id="btnPrint">Print / Save PDF</button>
      <button class="secondary" id="btnDownloadPdf">Download PDF (iOS)</button>
      <button class="secondary" id="btnPng">Save Image (PNG)</button>
      <button class="secondary" id="btnCopy">Copy CSMPN</button>
    </div>

    <div class="tips">
      <strong>How to use:</strong>
      <ul>
        <li>Import a PDF/TXT/XML, or paste CSMPN in the editor.</li>
        <li>Each chord token is a bar; four bars render per row automatically.</li>
        <li>Use <code>_</code> to split a bar (e.g., <code>Bb_Eb7</code>), <code>%</code> to repeat a bar, and <code>(... )x2</code> for repeats.</li>
        <li>Endings: <code>1. Gm7 C7 2. F7 Bb</code> renders with labels above bars.</li>
        <li>Print is the primary PDF workflow; "Download PDF (iOS)" provides one-tap mobile export.</li>
        <li>You can paste/import barline charts using "|" and "ǁ" – they will be interpreted as measure separators.
If a PDF import yields no chords, it may be image-only (no selectable text).</li>
      </ul>
    </div>

    <div id="status" class="status">Ready. v1.6 - PDF import fixes applied.</div>

    <!-- hidden file input -->
    <input id="fileInput" type="file" accept=".pdf,.txt,.xml,.musicxml" style="display:none" />
  </div>

  <div class="grid">
    <div class="card editorCard">
      <label>CSMPN Source (ChordSheet-compatible)</label>
      <textarea id="source"></textarea>
    </div>

    <div class="previewWrap">
      <div id="preview" class="sheet">
        <div style="color:#666; font-size:14px; text-align:center; padding: 40px 10px;">
          Import a file or paste CSMPN to preview.
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================================================
   Core constants / helpers
========================================================= */
const sourceEl = document.getElementById('source');
const previewEl = document.getElementById('preview');
const statusEl = document.getElementById('status');

// PDF.js worker config (required when loading PDF.js from a CDN on GitHub Pages)
if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
  try {
      if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
        // Some Safari/iOS builds treat workerSrc as read-only. Guard and fail soft.
        if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
          pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
        }
      }
    } catch (e) {
      console.warn('pdf.js workerSrc assignment skipped:', e);
    }
}

const hdr = {
  title: document.getElementById('hdrTitle'),
  composer: document.getElementById('hdrComposer'),
  key: document.getElementById('hdrKey'),
  time: document.getElementById('hdrTime'),
  tempo: document.getElementById('hdrTempo'),
  style: document.getElementById('hdrStyle'),
};

let currentTranspose = 0;
let notationPreference = 'sharp'; // recomputed from key/text
let validationWarnings = []; // Q5: Track validation issues

function setStatus(msg, type='info'){
  // Back-compat: older call sites passed boolean (true=error)
  if (type === true) type = 'error';
  if (type === false) type = 'info';

  try{
    window.__csmpnLog = window.__csmpnLog || [];
    window.__csmpnLog.push({ t: new Date().toISOString(), type, msg: String(msg), ua: navigator.userAgent });
    // Keep last ~500 entries
    if (window.__csmpnLog.length > 500) window.__csmpnLog = window.__csmpnLog.slice(-500);
  }catch(e){}

  statusEl.textContent = msg;
  statusEl.classList.remove('err', 'warn');
  if (type === 'error') statusEl.classList.add('err');
  if (type === 'warning') statusEl.classList.add('warn');
}

function escapeHtml(s){
  return (s ?? '').toString()
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'","&#039;");
}

function safeFilename(name, fallback='chart'){
  const base = (name || fallback).toString().trim() || fallback;
  return base
    .replace(/[\\\/\:*?"<>|]+/g,'-')
    .replace(/\s+/g,' ')
    .trim()
    .slice(0, 80);
}

async function tryShareFile(file){
  try{
    if (navigator.canShare && navigator.canShare({ files: [file] })) {
      await navigator.share({ files: [file], title: file.name });
      return true;
    }
  }catch(_e){}
  return false;
}

function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.rel = 'noopener';
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}



function normalizeAccidentals(s){
  return (s ?? '')
    .replace(/♭/g,'b')
    .replace(/♯/g,'#')
    .replace(/\u00A0/g,' ')
    .trim();
}

/* =========================================================
   Phase-1 fixes: Header <-> Source bidirectional sync
========================================================= */
function extractHeaderFromText(text, writeToInputs=true){
  // Extracts header metadata from CSMPN-like source and (optionally) syncs the form fields.
  // Defensive: avoids poisoning header fields with chord lines / section labels.
  const norm = (s) => (s ?? "").toString()
    .replace(/\u00A0/g, " ")
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim();

  const looksChordy = (s) => {
    const t = norm(s);
    if (!t) return false;
    if (/[|ǁ]/.test(t) || /%/.test(t)) return true;
    const toks = t.split(" ").filter(Boolean);
    let chordCount = 0;
    for (const tok of toks){
      if (isChordToken(tok)) chordCount++;
    }
    // If it contains multiple chord tokens, it's likely not a human header value.
    return chordCount >= 2;
  };

  const normalizeField = (field, raw) => {
    let v = norm(raw);
    if (!v) return "";
    // Strip stray trailing punctuation
    v = v.replace(/^[\-\u2013\u2014]+/, "").trim();

    if (field === "key"){
      // Accept common key spellings: Bb, F#, C#m, Abm, etc.
      v = v.replace(/\s+/g, "");
      v = v.replace(/minor$/i, "m").replace(/min$/i, "m");
      // Reject obviously bad values
      if (!/^[A-G](?:#|b)?(?:m)?$/i.test(v)) return "";
      return v;
    }
    if (field === "time"){
      v = v.replace(/\s+/g, "");
      if (!/^\d{1,2}\/\d{1,2}$/.test(v)) return "";
      return v;
    }
    if (field === "tempo"){
      const m = v.match(/(\d{1,3})/);
      if (!m) return "";
      const n = parseInt(m[1], 10);
      if (!(n >= 20 && n <= 320)) return "";
      return String(n);
    }

    // title/composer/style: reject chord-like garbage or label-only values
    if (/^(title|composer|artist|style|tempo|time|key)\s*:?$/i.test(v)) return "";
    if (looksChordy(v)) return "";
    // Cap ridiculous lengths (often PDF garbage)
    if (v.length > 120) v = v.slice(0, 120).trim();
    return v;
  };

  const getLineValue = (labelRe) => {
    const m = text.match(labelRe);
    return m ? m[1] : "";
  };

  const hdr = {
    title: normalizeField("title", getLineValue(/^\s*Title:\s*(.*)$/im)),
    composer: normalizeField("composer", getLineValue(/^\s*(?:Composer|Artist):\s*(.*)$/im)),
    style: normalizeField("style", getLineValue(/^\s*Style:\s*(.*)$/im)),
    tempo: normalizeField("tempo", getLineValue(/^\s*Tempo:\s*(.*)$/im)),
    time: normalizeField("time", getLineValue(/^\s*Time:\s*(.*)$/im)),
    key: normalizeField("key", getLineValue(/^\s*Key:\s*(.*)$/im)),
  };

  // If no explicit Title: and first non-empty line looks like a title, adopt it.
  if (!hdr.title){
    const first = (text.split(/\r?\n/).map(l => l.trim()).find(l => l) || "");
    // Avoid promoting section/marker lines (e.g., "- Intro", "= Verse") to Title.
    const looksLikeMarker = (s) => /^[-=:#;\[]\s*/.test((s||"").trim());
    if (first && !looksLikeMarker(first) && !first.includes(":") && !looksChordy(first) && first.length <= 80){
      hdr.title = normalizeField("title", first);
    }
  }

  if (writeToInputs){
    const map = {
      title: elTitle,
      composer: elComposer,
      style: elStyle,
      tempo: elTempo,
      time: elTime,
      key: elKey,
    };
    for (const k of Object.keys(map)){
      const v = hdr[k] || "";
      if (map[k] && map[k].value !== v) map[k].value = v;
    }
  }
  return hdr;
}

function applyHeaderToText(){
  const lines = sourceEl.value.split(/\r?\n/);
  const meta = {
    Title: hdr.title.value.trim(),
    Composer: hdr.composer.value.trim(),
    Key: hdr.key.value.trim(),
    Time: hdr.time.value.trim(),
    Tempo: hdr.tempo.value.trim(),
    Style: hdr.style.value.trim(),
  };

  // remove existing meta lines
  const keep = [];
  for (const line of lines){
    if (/^(Title|Composer|Artist|Key|Time|Tempo|Style)\s*:/i.test(line.trim())) continue;
    keep.push(line);
  }

  const metaLines = [];
  if (meta.Title) metaLines.push(`Title: ${meta.Title}`);
  if (meta.Composer) metaLines.push(`Composer: ${meta.Composer}`);
  if (meta.Style) metaLines.push(`Style: ${meta.Style}`);
  if (meta.Tempo) metaLines.push(`Tempo: ${meta.Tempo}`);
  if (meta.Time) metaLines.push(`Time: ${meta.Time}`);
  if (meta.Key) metaLines.push(`Key: ${meta.Key}`);

  // ensure a blank line after headers if content exists
  const body = keep.join('\n').trimStart();
  const combined = metaLines.join('\n') + (metaLines.length ? '\n\n' : '') + body;

  sourceEl.value = combined.replace(/\n{3,}/g,'\n\n');
}

for (const k of Object.keys(hdr)){
  hdr[k].addEventListener('input', () => {
    applyHeaderToText();
    updatePreview();
  });
}

sourceEl.addEventListener('input', () => {
  extractHeaderFromText(sourceEl.value);
  updatePreview();
});

/* =========================================================
   CSMPN parsing
========================================================= */
function detectNotationPreferenceFromKeyOrText(key, text){
  const k = (key||'').toLowerCase();
  if (k.includes('b')) return 'flat';
  if (k.includes('#')) return 'sharp';
  // fallback: inspect chord tokens
  if (/[A-G][b]/.test(text)) return 'flat';
  if (/[A-G]#/.test(text)) return 'sharp';
  return 'sharp';
}

// ---------------------------------------------------------
// Transposition helpers
// ---------------------------------------------------------
const NOTE_INDEX = new Map([
  ['C',0],['B#',0],
  ['C#',1],['DB',1],
  ['D',2],
  ['D#',3],['EB',3],
  ['E',4],['FB',4],
  ['F',5],['E#',5],
  ['F#',6],['GB',6],
  ['G',7],
  ['G#',8],['AB',8],
  ['A',9],
  ['A#',10],['BB',10],
  ['B',11],['CB',11],
]);

const NOTES_SHARP = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const NOTES_FLAT  = ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];

function transposeNote(note, semis, pref){
  const n = normalizeAccidentals(note).toUpperCase().replace(/\s+/g,'');
  const idx = NOTE_INDEX.get(n);
  if (idx === undefined) return note;

  const t = (idx + (semis % 12) + 12) % 12;
  const arr = (pref === 'flat') ? NOTES_FLAT : NOTES_SHARP;
  return arr[t];
}


function parseCSMPN(text){
  const raw = (text || '').replace(/\r/g,'');
  const lines = raw.split('\n');

  const doc = {
    title: '',
    composer: '',
    style: '',
    tempo: '',
    time: '',
    key: '',
    blocks: []
  };

  const metaRE = /^(Title|Composer|Artist|Style|Tempo|Time|Key)\s*:\s*(.*)$/i;

  // First pass: meta extraction
  const contentLines = [];
  for (const line of lines){
    const m = line.match(metaRE);
    if (m){
      const field = m[1].toLowerCase();
      const val = m[2].trim();
      if (field === 'title') doc.title = val;
      else if (field === 'composer' || field === 'artist') doc.composer = val;
      else if (field === 'style') doc.style = val;
      else if (field === 'tempo') doc.tempo = val;
      else if (field === 'time') doc.time = val;
      else if (field === 'key') doc.key = val;
      continue;
    }
    contentLines.push(line);
  }

  for (const line0 of contentLines){
    const line = line0.trim();
    if (!line) continue;

    // page break
    if (line.startsWith('+')){
      doc.blocks.push({type:'pagebreak'});
      continue;
    }

    // marker lines
    const lead = line[0];
    if (lead === '-' || lead === ':' || lead === '=' || lead === ';' || lead === '#'){
      doc.blocks.push({type:'marker', marker: lead, text: line.slice(1).trim()});
      continue;
    }

    // chord line
    const tokens = tokenizeBars(line0);
    if (tokens.length){
      doc.blocks.push({type:'bars', tokens});
    }
  }

  return doc;
}

function normalizeBarlineDelimiters(line){
  // Accept UG/ChordSheet barline characters and normalize for tokenization
  // ǁ / ‖ / ∥ are treated as double barlines
  return (line || '')
    .replace(/[ǁ‖∥]/g, '||')
    .replace(/\|\|/g, ' || ')
    .replace(/\|/g, ' | ')
    .replace(/\s+/g, ' ')
    .trim();
}


function normalizeUGProText(text){
  // Normalizes Ultimate Guitar / UG Pro text exports.
  let t = (text ?? "").toString();
  t = t.replace(/\r\n?/g, "\n");
  t = t.replace(/\u00A0/g, " ");
  t = t.replace(/[\u200B-\u200D\uFEFF]/g, ""); // zero-width
  // Normalize "times" repeat phrasing to xN
  t = t.replace(/\b(times)\s*(two|2)\b/gi, "x2");
  t = t.replace(/\b(times)\s*(three|3)\b/gi, "x3");
  t = t.replace(/\b(times)\s*(four|4)\b/gi, "x4");
  // Normalize unicode bars
  t = t.replace(/[ǁ∥]/g, "||");
  // Collapse duplicate repeat tokens
  t = t.replace(/\b(x[234])(\s+\1)+\b/gi, "$1");
  // UG sometimes emits "x2 x2)" etc
  t = t.replace(/(\)\s*)\b(x[234])\b\s*\b\2\b/gi, "$1$2");
  // Normalize common quote types
  t = t.replace(/[“”]/g, "\"").replace(/[‘’]/g, "'");
  return t.trim();
}

function tokenizeBars(line){
  // tokenization: keep quoted annotations intact; also supports UG-style barlines
  const s = normalizeBarlineDelimiters(line);
  if (!s) return [];
  const out = [];
  let cur = '';
  let inQuote = false;

  for (let i=0;i<s.length;i++){
    const ch = s[i];
    if (ch === '"'){
      inQuote = !inQuote;
      cur += ch;
      continue;
    }
    if (!inQuote && /\s/.test(ch)){
      if (cur){
        out.push(cur);
        cur = '';
      }
      continue;
    }
    cur += ch;
  }
  if (cur) out.push(cur);

  // If any token still contains barlines (rare PDF extraction cases), explode them.
  const exploded = [];
  for (const t of out){
    if (t.includes('|') && t !== '|' && t !== '||'){
      let buf = '';
      let i = 0;
      while (i < t.length){
        if (t[i] === '|'){
          if (buf){ exploded.push(buf); buf=''; }
          if (i+1 < t.length && t[i+1] === '|'){
            exploded.push('||'); i += 2; continue;
          } else {
            exploded.push('|'); i += 1; continue;
          }
        }
        buf += t[i];
        i++;
      }
      if (buf) exploded.push(buf);
    } else {
      exploded.push(t);
    }
  }

  return exploded;
}

function transposeChordToken(tok, semis, pref){
  // structural tokens
  if (!tok) return tok;
  const upper = tok.toUpperCase();
  if (tok === '%' || tok === '%%' || /^%\d+$/.test(tok)) return tok;
  if (tok === '*' || tok === '||' || tok === '|' ) return tok;
  if (upper === 'N.C.' || upper === 'NC') return tok;
  if (/^\d+\.$/.test(tok)) return tok; // endings marker token itself
  if (tok.startsWith('"') && tok.endsWith('"')) return tok; // annotation token

  // handle repeats: keep punctuation
  const mRepeat = tok.match(/^(\()?(.*?)(\))?(x\d+)?$/);
  if (!mRepeat) return tok;

  const preL = mRepeat[1] || '';
  let core = mRepeat[2] || '';
  const preR = mRepeat[3] || '';
  const rep  = mRepeat[4] || '';

  // split by underscores, commas
  const parts = core.split('_').map(seg => {
    return seg.split(',').map(piece => transposeChordSimple(piece, semis, pref)).join(',');
  }).join('_');

  return preL + parts + preR + rep;
}

function transposeChordSimple(ch, semis, pref){
  const s = ch.trim();
  if (!s) return s;
  // allow directives embedded
  const upper = s.toUpperCase();
  if (upper === 'N.C.' || upper === 'NC') return s;

  const m = s.match(/^([A-G])([b#]?)(.*?)(?:\/([A-G])([b#]?))?$/);
  if (!m) return s;

  const root = m[1] + (m[2]||'');
  const qual = m[3]||'';
  const bass = m[4] ? (m[4] + (m[5]||'')) : '';

  const trRoot = transposeNote(root, semis, pref);
  const trBass = bass ? transposeNote(bass, semis, pref) : '';

  return trBass ? `${trRoot}${qual}/${trBass}` : `${trRoot}${qual}`;
}

function transposeWholeText(text, semis){
  const keyMatch = text.match(/^Key:\s*(.+)$/im);
  const key = keyMatch ? keyMatch[1].trim() : '';
  const pref = detectNotationPreferenceFromKeyOrText(key, text);

  const lines = text.split(/\r?\n/);
  const out = [];
  for (const line of lines){
    const m = line.match(/^Key:\s*(.+)$/i);
    if (m){
      const oldKey = m[1].trim();
      const trKey = transposeChordSimple(oldKey, semis, pref);
      out.push(`Key: ${trKey}`);
      continue;
    }

    // preserve marker lines and meta lines except chord payload
    if (/^(Title|Composer|Artist|Style|Tempo|Time)\s*:/i.test(line.trim())){
      out.push(line);
      continue;
    }
    const trimmed = line.trim();
    if (!trimmed){
      out.push(line);
      continue;
    }

    // marker lines
    if (/^[-:=;#\+]/.test(trimmed)){
      out.push(line);
      continue;
    }

    // chord lines: transpose tokens
    const tokens = tokenizeBars(line);
    const indent = tokens.indent || 0;
    const t2 = tokens.map(tok => transposeChordToken(tok, semis, pref));
    const prefix = indent ? ('X '.repeat(indent)) : '';
    out.push(prefix + t2.join(' '));
  }
  return out.join('\n');
}

/* =========================================================
   Q1 FIX: Repeat Expansion Logic (CRITICAL)
   Expands repeat groups fully to maintain 4-bar-per-row grid
========================================================= */
function parseBarStructures(tokens){
  // Returns flat array of bar objects after expanding repeats.
  // Also consumes UG-style barline tokens: '|' (single) and '||' (double).
  const out = [];
  let i = 0;

  let pendingDoubleLeft = false;

  const markDoubleBoundary = () => {
    const prev = out[out.length - 1];
    if (prev) prev.doubleRight = true;
    pendingDoubleLeft = true;
  };

  const readTimes = (tok) => {
    const m = (tok || '').match(/x(\d+)$/i);
    return m ? parseInt(m[1],10) : null;
  };

  const skipBarlines = () => {
    while (i < tokens.length && (tokens[i] === '|' || tokens[i] === '||')){
      if (tokens[i] === '||') markDoubleBoundary();
      i++;
    }
  };

  while (i < tokens.length){
    let tok = tokens[i];

    if (tok === '|'){ i++; continue; }
    if (tok === '||'){ markDoubleBoundary(); i++; continue; }

    // Endings token - associate with next bar (skipping delimiters)
    if (/^\d+\.$/.test(tok)){
      const endingLabel = tok;
      i++;
      skipBarlines();
      if (i < tokens.length){
        const nextTok = tokens[i];
        out.push({type:'bar', token: nextTok, endingLabel, doubleLeft: pendingDoubleLeft || false, doubleRight: false});
        pendingDoubleLeft = false;
        i++;
      }
      continue;
    }

    // Repeat group ( ... )xN
    if (tok.startsWith('(')){
      const groupTokens = [];
      let times = 2;
      let closed = false;

      tok = tok.slice(1);
      if (tok) groupTokens.push(tok);

      i++;
      while (i < tokens.length){
        const t = tokens[i];

        if (t === '|' ){ i++; continue; }
        if (t === '||'){ i++; continue; }

        if (t.endsWith(')') || /\)x\d+$/i.test(t)){
          const before = t.replace(/\)x\d+$/i,'').replace(/\)$/,'');
          const after = t.match(/\)x(\d+)$/i);
          if (before) groupTokens.push(before);
          if (after) times = parseInt(after[1],10);
          const tIn = readTimes(before) || readTimes(t) || null;
          if (tIn) times = tIn;
          closed = true;
          i++;
          break;
        } else {
          groupTokens.push(t);
          i++;
        }
      }

      if (!closed){
        validationWarnings.push(`⚠️ Unclosed repeat parenthesis - auto-closing`);
      }

      for (let rep=0; rep<times; rep++){
        for (const gt of groupTokens){
          out.push({type:'bar', token: gt, doubleLeft: pendingDoubleLeft || false, doubleRight: false});
          pendingDoubleLeft = false;
        }
      }
      continue;
    }

    out.push({type:'bar', token: tok, doubleLeft: pendingDoubleLeft || false, doubleRight: false});
    pendingDoubleLeft = false;
    i++;
  }

  return out;
}


/* =========================================================
   Rendering (ChordSheet-style only)
========================================================= */
function renderDoc(doc){
  // Q5 VALIDATION: Reset warnings
  validationWarnings = [];

  let html = '';
  if (doc.title){
    html += `<div class="songTitle">${escapeHtml(doc.title)}</div>`;
  }
  const meta = [];
  if (doc.composer) meta.push(`<div class="metaLine"><span class="metaLabel">Composer:</span> ${escapeHtml(doc.composer)}</div>`);
  if (doc.style) meta.push(`<div class="metaLine"><span class="metaLabel">Style:</span> ${escapeHtml(doc.style)}</div>`);
  if (doc.tempo) meta.push(`<div class="metaLine"><span class="metaLabel">Tempo:</span> ${escapeHtml(doc.tempo)}</div>`);
  if (doc.time) meta.push(`<div class="metaLine"><span class="metaLabel">Time:</span> ${escapeHtml(doc.time)}</div>`);
  if (doc.key) meta.push(`<div class="metaLine"><span class="metaLabel">Key:</span> ${escapeHtml(doc.key)}</div>`);
  if (meta.length){
    html += `<div class="meta">${meta.join('')}</div>`;
  }

  for (const block of doc.blocks){
    if (block.type === 'pagebreak'){
      html += `<div class="pageBreak"></div>`;
      continue;
    }
    if (block.type === 'marker'){
      const t = escapeHtml(block.text || '');
      if (block.marker === '-'){
        html += `<div class="sectionText">${t}</div>`;
      } else if (block.marker === ':'){
        html += `<div class="sectionText"><span class="labelBox">${t}</span></div>`;
      } else if (block.marker === '='){
        html += `<div class="dividerRow"><span class="labelBox">${t}</span><div class="rule"></div></div>`;
      } else if (block.marker === ';'){
        html += `<div class="annotation">${t}</div>`;
      } else if (block.marker === '#'){
        html += `<div class="annotation"><span class="small">#</span> ${t}</div>`;
      }
      continue;
    }
    if (block.type === 'bars'){
      html += renderBars(block.tokens);
      continue;
    }
  }

  if (!doc.blocks.length){
    html += `<div style="color:#666; font-size:14px; text-align:center; padding: 40px 10px;">
      Import a file or paste CSMPN to preview.
    </div>`;
  }

  // Q5 VALIDATION: Display warnings if any
  if (validationWarnings.length){
    const warnMsg = validationWarnings.join('\n');
    setStatus(warnMsg, 'warning');
  }

  return html;
}

function renderBars(tokens){
  const bars = parseBarStructures(tokens);
  const indent = tokens.indent || 0;

  let html = `<div class="barsBlock" style="margin-left:${indent * 22}px">`;

  // Render in groups of 4 bars per row (musician-friendly).
  for (let i = 0; i < bars.length; i += 4){
    const row = bars.slice(i, i + 4);

    // Pad to 4
    while (row.length < 4){
      row.push({ token: '', doubleLeft: false, doubleRight: false });
    }

    const startsDouble = !!row[0]?.doubleLeft;

    html += `<div class="barlineRow">`;
    html += `<span class="barSep">${startsDouble ? '||' : '|'}</span>`;

    for (const bar of row){
      const label = bar.endingLabel ? `${bar.endingLabel} ` : '';
      const txt = label + (bar.token || '');
      html += renderMeasure(txt);

      // Respect doubleRight boundaries (e.g., from '||' in source)
      html += `<span class="barSep">${bar.doubleRight ? '||' : '|'}</span>`;
    }

    html += `</div>`;
  }

  html += `</div>`;
  return html;
}

function renderMeasure(measureText){
  const raw = (measureText || '').trim();
  if(!raw){
    return `<div class="measure"><div class="beats"><span class="beat"></span></div></div>`;
  }
  const beats = raw.split('_').map(s => s.trim()).filter(Boolean);
  const beatHtml = (beats.length ? beats : [raw]).map(b => `<span class="beat">${escapeHtml(b)}</span>`).join('');
  return `<div class="measure"><div class="beats">${beatHtml}</div></div>`;
}


function renderBar(bar){
  const tok = bar.token ?? '';

  let endingHtml = '';
  if (bar.endingLabel){
    endingHtml = `<span class="endingLabel">${escapeHtml(bar.endingLabel)}</span>`;
  }

  const classes = [
    bar.doubleLeft ? 'doubleLeft' : '',
    bar.doubleRight ? 'doubleRight' : ''
  ].filter(Boolean).join(' ');

  const segs = tok.split('_').map(s => s.trim());

  for (const s of segs){
    if (s && s !== '*' && s !== '%' && s !== '%%' && !s.startsWith('"') && !isChordLikeToken(s)){
      validationWarnings.push(`⚠️ Unknown token "${s}" - rendering as-is`);
    }
  }

  const segHtml = segs.map(s => {
    if (!s || s === '*') return `<div class="seg"></div>`;
    if (s.startsWith('"') && s.endsWith('"')){
      return `<div class="seg small">${escapeHtml(s.slice(1,-1))}</div>`;
    }
    return `<div class="seg">${escapeHtml(s)}</div>`;
  }).join('');

  return `<div class="bar ${classes}">${endingHtml}<div class="barSegments">${segHtml || '<div class="seg"></div>'}</div></div>`;
}

function updatePreview(){
  const text = sourceEl.value || '';
  const keyMatch = text.match(/^Key:\s*(.+)$/im);
  const key = keyMatch ? keyMatch[1].trim() : '';
  notationPreference = detectNotationPreferenceFromKeyOrText(key, text);

  const doc = parseCSMPN(text);
  previewEl.innerHTML = renderDoc(doc);
}

/* =========================================================
   Q3 FIX: Enhanced PDF Import with X-Coordinate Clustering
   Detects split bars using spatial positioning
========================================================= */
const fileInput = document.getElementById('fileInput');

document.getElementById('btnImport').addEventListener('click', () => {
  fileInput.value = '';
  fileInput.click();
});

fileInput.addEventListener('change', async () => {
  const file = fileInput.files && fileInput.files[0];
  if (!file) return;
  try{
    setStatus(`Importing ${file.name}...`);
    const name = file.name.toLowerCase();
    if (name.endsWith('.pdf')){
      const csmpn = await importUGProPDF(file);
      sourceEl.value = csmpn;
      extractHeaderFromText(csmpn);
      updatePreview();
      return;
    }
    if (name.endsWith('.xml') || name.endsWith('.musicxml')){
      const text = await file.text();
      const csmpn = importMusicXML(text);
      sourceEl.value = csmpn;
      extractHeaderFromText(csmpn);
      updatePreview();
      setStatus('Imported MusicXML.');
      return;
    }
    // txt
    const text = await file.text();
    const csmpn = detectChordPro(text) ? importChordPro(text) : importUGText(text);
    sourceEl.value = csmpn;
    extractHeaderFromText(csmpn);
    updatePreview();
    setStatus('Imported text.');
  }catch(err){
    console.error(err);
    setStatus(`Import failed: ${err?.message || err}`, true);
  }
});

function detectChordPro(text){
  return /\{\s*(title|key|tempo|time)\s*:/i.test(text);
}

function importUGText(text){
  // UG Pro TXT exports can be noisy: headers, blank lines, "times two", duplicate repeats, etc.
  // Goal: produce chord-only CSMPN with 4 bars per line, preserving repeat intent when explicit.
  text = (text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");

  const repeatTokenToN = (t) => {
    if (!t) return null;
    const s = String(t).trim();
    let m = s.match(/^\(\s*x\s*(\d+)\s*\)$/i); // (x2)
    if (m) return parseInt(m[1], 10);
    m = s.match(/^x\s*(\d+)$/i); // x2
    if (m) return parseInt(m[1], 10);
    m = s.match(/^(\d+)\s*x$/i); // 2x
    if (m) return parseInt(m[1], 10);
    return null;
  };

  const parseTimesPhrase = (tokens) => {
    if (!tokens || tokens.length < 2) return null;
    if (String(tokens[0]).toLowerCase() !== "times") return null;
    const v = String(tokens[1]).toLowerCase();
    const map = {one:1,two:2,three:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10};
    if (v in map) return map[v];
    if (/^\d+$/.test(v)) return parseInt(v, 10);
    return null;
  };

  const lines = text.split("\n").map(l => l.trim()).filter(Boolean);

  const out = [];
  for (const line of lines){
    const raw = line.trim();
    if (!raw) continue;

    // Section headings: common UG / chord dump patterns
    let m = raw.match(/^\[(.+?)\]$/); // [Chorus]
    if (m){ out.push(`= ${m[1].trim()}`); continue; }
    m = raw.match(/^[-=]\s*(.+)$/); // - Intro / = Verse
    if (m){ out.push(`= ${m[1].trim()}`); continue; }
    m = raw.match(/^(#{1,6})\s*(.+)$/); // Markdown
    if (m){ out.push(`= ${m[2].trim()}`); continue; }

    // Standalone repeat marker line applies to previous chord line
    const standaloneN = repeatTokenToN(raw) || parseTimesPhrase(raw.split(/\s+/));
    if (standaloneN && out.length){
      const prev = (out[out.length-1] || "").trim();
      if (prev && !/^[=:#;]/.test(prev) && !/^\(.*\)x\d+$/i.test(prev)){
        out[out.length-1] = `(${prev})x${standaloneN}`;
      }
      continue;
    }

    // Tokenize
    let toks = raw.split(/\s+/).filter(Boolean);

    // Strip common UG "times N" that can appear after a chord line
    let repeatN = repeatTokenToN(toks[toks.length-1]);
    if (!repeatN && toks.length >= 2){
      repeatN = parseTimesPhrase(toks.slice(-2));
    }

    // Remove trailing repeat tokens from chord candidates
    if (repeatN){
      if (repeatTokenToN(toks[toks.length-1])) toks = toks.slice(0, -1);
      else if (parseTimesPhrase(toks.slice(-2))) toks = toks.slice(0, -2);
    }

    // Determine if this is chord-dominant
    const chordLike = toks.reduce((acc,t)=>acc + (isChordLikeToken(t) ? 1 : 0), 0);
    if (!toks.length || (chordLike / toks.length) < 0.6) continue;

    // Normalize chords
    const chords = toks.map(t => normalizeChordToken(t)).filter(Boolean);
    if (!chords.length) continue;

    // Convert to 4-bars-per-line CSMPN; if repeatN is present, wrap as a single repeat block
    let block = toCSMPNBars(chords).trim();
    if (repeatN && repeatN > 1){
      // Collapse newlines inside the repeat block for safer syntax: (A B C D)x2
      block = block.replace(/\n+/g, " ").trim();
      out.push(`(${block})x${repeatN}`);
    } else {
      out.push(block);
    }
  }

  return out.join("\n").trim();
}

function importChordPro(text){
  const lines = text.replace(/\r/g,'').split('\n');
  const out = [];
  for (const line0 of lines){
    const line = normalizeAccidentals(line0);

    // directives
    const m = line.match(/^\{\s*([a-z_]+)\s*:\s*(.*?)\s*\}$/i);
    if (m){
      const k = m[1].toLowerCase();
      const v = m[2].trim();
      if (k === 'title') out.unshift(`Title: ${v}`);
      if (k === 'composer' || k === 'artist') out.unshift(`Composer: ${v}`);
      if (k === 'key') out.unshift(`Key: ${v}`);
      if (k === 'time') out.unshift(`Time: ${v}`);
      if (k === 'tempo') out.unshift(`Tempo: ${v}`);
      continue;
    }
    if (!line.trim()) continue;

    // section markers
    if (/^\{\s*start_of_(chorus|verse|bridge)\s*\}$/i.test(line.trim())){
      out.push(`: ${RegExp.$1.toUpperCase()}`);
      continue;
    }

    // extract chords in []
    const chords = [];
    const re = /\[([^\]]+)\]/g;
    let mm;
    while ((mm = re.exec(line)) !== null){
      const c = mm[1].trim();
      if (c) chords.push(c);
    }
    if (chords.length){
      out.push(toCSMPNBars(chords));
    }
  }
  setStatus(`Imported ChordPro.`);
  return out.join('\n').replace(/\n{3,}/g,'\n\n');
}

function importMusicXML(xmlText){
  const parser = new DOMParser();
  const xml = parser.parseFromString(xmlText, "application/xml");
  const title = xml.querySelector("work > work-title")?.textContent?.trim() || '';
  const composer = xml.querySelector("identification creator[type='composer']")?.textContent?.trim() || '';
  const keyFifths = xml.querySelector("key fifths")?.textContent?.trim();
  const timeBeats = xml.querySelector("time beats")?.textContent?.trim();
  const timeBeatType = xml.querySelector("time beat-type")?.textContent?.trim();

  const out = [];
  if (title) out.push(`Title: ${title}`);
  if (composer) out.push(`Composer: ${composer}`);
  if (timeBeats && timeBeatType) out.push(`Time: ${timeBeats}/${timeBeatType}`);

  // measures
  const measures = [...xml.querySelectorAll("measure")];
  const bars = [];
  for (const meas of measures){
    const harmonies = [...meas.querySelectorAll("harmony")];
    if (!harmonies.length){
      bars.push('%'); // simile (or *), conservative
      continue;
    }
    // take first harmony as bar chord; if multiple, split bar
    const chords = harmonies.map(h => harmonyToChord(h)).filter(Boolean);
    if (chords.length === 1) bars.push(chords[0]);
    else bars.push(chords.join('_'));
  }

  // chunk into 4 per line
  for (let i=0;i<bars.length;i+=4){
    out.push(bars.slice(i,i+4).join(' '));
  }
  setStatus(`Imported MusicXML: ${measures.length} measure(s).`);
  return out.join('\n');
}

function harmonyToChord(h){
  const step = h.querySelector("root root-step")?.textContent?.trim();
  const alter = h.querySelector("root root-alter")?.textContent?.trim();
  if (!step) return '';
  const acc = alter === '1' ? '#' : (alter === '-1' ? 'b' : '');
  const kindText = h.querySelector("kind")?.getAttribute("text")?.trim() || '';
  const kind = h.querySelector("kind")?.textContent?.trim() || '';
  const bassStep = h.querySelector("bass bass-step")?.textContent?.trim();
  const bassAlter = h.querySelector("bass bass-alter")?.textContent?.trim();
  const bassAcc = bassAlter === '1' ? '#' : (bassAlter === '-1' ? 'b' : '');

  let qual = kindText || kind || '';
  // map a few common MusicXML kinds to chord quality
  const map = {
    'major': '',
    'minor': 'm',
    'dominant': '7',
    'major-seventh': 'maj7',
    'minor-seventh': 'm7',
    'diminished': 'dim',
    'diminished-seventh': 'dim7',
    'augmented': 'aug',
    'half-diminished': 'm7b5'
  };
  if (map[qual]) qual = map[qual];

  let chord = `${step}${acc}${qual}`;
  if (bassStep) chord += `/${bassStep}${bassAcc}`;
  return chord;
}

function stripTokenDecorators(t){
  return (t || '')
    .replace(/^\(+/,'')
    .replace(/\)+$/,'')
    .replace(/x\d+$/i,'')
    .trim();
}

// Stricter chord token detection to avoid false positives from PDF text (e.g., section labels).
function isChordLikeToken(tok){
  if (!tok) return false;
  let t = normalizeAccidentals(tok)
    .replace(/\u200B/g,'')
    .trim();

  if (t === '%' || t === '%%' || /^%\d+$/.test(t)) return true;
  if (t === '*') return true;
  const upper = t.toUpperCase();
  if (upper === 'N.C.' || upper === 'NC') return true;

  t = stripTokenDecorators(t);
  if (!t) return false;

  const m = t.match(/^([A-G])([b#]?)(.*)$/);
  if (!m) return false;

  const rest = m[3] || '';
  if (!rest) return true;

  const rl = rest.toLowerCase();

  const startsOk =
    /^[0-9#b\/()+.,-]/.test(rest) ||
    rl.startsWith('m') ||
    rl.startsWith('maj') ||
    rl.startsWith('min') ||
    rl.startsWith('dim') ||
    rl.startsWith('aug') ||
    rl.startsWith('sus') ||
    rl.startsWith('add') ||
    rl.startsWith('alt') ||
    rl.startsWith('omit') ||
    rl.startsWith('no');

  if (!startsOk) return false;

  if (/^[a-z]+$/i.test(rest) && rest.length > 3){
    if (!/^(maj|min|dim|aug|sus|add|alt|omit|no|m)$/.test(rl)) return false;
  }

  return /^[A-Za-z0-9#b\/()+.,-ΔøØ°º]*$/.test(rest);
}

function isChordLikeTokenPDF(tok){
  if (!isChordLikeToken(tok)) return false;
  const t = stripTokenDecorators(normalizeAccidentals(tok));
  if (/^[A-G][a-z]{4,}$/i.test(t) && !/[0-9#b]/.test(t)) return false;
  return true;
}



function toCSMPNBars(chords){
  // chords array -> lines of 4 bars
  const toks = chords.map(c => normalizeAccidentals(c)).filter(Boolean);
  const out = [];
  for (let i=0;i<toks.length;i+=4){
    out.push(toks.slice(i,i+4).join(' '));
  }
  return out.join('\n');
}


/* =========================================================
   PDF Import (UG Pro / ChordSheet PDFs)
   - Uses PDF.js text extraction
   - Prefers barline reconstruction when PDFs contain | / ‖ / ǁ
   - Falls back to spatial clustering for "floating chord glyph" PDFs
========================================================= */
async function importUGProPDF(file){
  if (!window.pdfjsLib) throw new Error("PDF.js not loaded.");
  statusEl.textContent = "Reading PDF…";
  const arrayBuffer = await file.arrayBuffer();
  const pdfOpts = { data: arrayBuffer };
  // If the worker cannot be configured (common on iOS Safari), fall back to no-worker mode.
  try {
    if (!pdfjsLib?.GlobalWorkerOptions?.workerSrc) pdfOpts.disableWorker = true;
  } catch (e) {
    pdfOpts.disableWorker = true;
  }
  const loadingTask = pdfjsLib.getDocument(pdfOpts);
  const pdf = await loadingTask.promise;

  const meta = { title:"", composer:"", style:"", tempo:"", time:"", key:"" };
  const bodyLines = [];
  let pendingBars = [];

  const flushBars = () => {
    while (pendingBars.length){
      bodyLines.push(pendingBars.splice(0,4).join(" "));
    }
  };

  const normLine = (s) => (s ?? "").toString()
    .replace(/\u00A0/g, " ")
    .replace(/[ǁ∥]/g, "||")
    .replace(/[“”]/g, "\"")
    .replace(/[‘’]/g, "'")
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim();

  const isBarToken = (t) => /^(\|{1,2})$/.test(t);

  const splitTokens = (line) => {
    // Ensure barlines are tokenized
    let s = normLine(line);
    s = s.replace(/(\|{1,2})/g, " $1 ");
    return s.split(" ").filter(Boolean);
  };

  const looksLikeSection = (line, tokens, chordCount) => {
    if (!line) return false;
    if (chordCount > 0) return false;
    if (line.length > 48) return false;
    // common section words or "Chorus1" style
    if (/^(intro|verse|chorus|bridge|solo|tag|ending|outro|interlude|pre[-\s]?chorus|turnaround)\b/i.test(line)) return true;
    if (/^(chorus|verse|bridge|solo)\s*\d+$/i.test(line)) return true;
    // ALL CAPS markers like DOUBLE-TIME
    if (/^[A-Z][A-Z0-9\-\s]{3,}$/.test(line) && !/TITLE|COMPOSER|STYLE|TEMPO|TIME|KEY/.test(line)) return true;
    // "ENDXXXX" marker
    if (/^END[A-Z0-9\-]+$/.test(line)) return true;
    return false;
  };

  const parseHeaderFromLine = (line) => {
    const m1 = line.match(/^\s*Title:\s*(.*)$/i);
    if (m1) { meta.title = m1[1].trim(); return true; }
    const m2 = line.match(/^\s*(Composer|Artist):\s*(.*)$/i);
    if (m2) { meta.composer = m2[2].trim(); return true; }
    const m3 = line.match(/^\s*Style:\s*(.*)$/i);
    if (m3) { meta.style = m3[1].trim(); return true; }
    const m4 = line.match(/^\s*Tempo:\s*(.*)$/i);
    if (m4) { meta.tempo = m4[1].trim(); return true; }
    const m5 = line.match(/^\s*Time:\s*(.*)$/i);
    if (m5) { meta.time = m5[1].trim(); return true; }
    const m6 = line.match(/^\s*Key:\s*(.*)$/i);
    if (m6) { meta.key = m6[1].trim(); return true; }
    return false;
  };

  for (let p = 1; p <= pdf.numPages; p++){
    statusEl.textContent = `Parsing PDF… page ${p}/${pdf.numPages}`;
    const page = await pdf.getPage(p);
    const tc = await page.getTextContent();
    const items = tc.items
      .map(it => ({
        str: (it.str ?? "").toString(),
        x: it.transform[4] ?? 0,
        y: it.transform[5] ?? 0
      }))
      .filter(it => it.str && it.str.trim());

    // Cluster by y into "visual lines"
    const buckets = new Map();
    for (const it of items){
      const yk = Math.round(it.y * 2) / 2; // 0.5pt buckets
      if (!buckets.has(yk)) buckets.set(yk, []);
      buckets.get(yk).push(it);
    }

    const yKeys = Array.from(buckets.keys()).sort((a,b) => b-a); // top-to-bottom
    for (const yk of yKeys){
      const lineItems = buckets.get(yk).sort((a,b) => a.x-b.x);
      // Join while preserving short gaps; PDF.js tends to split pipes and chords
      const rawLine = lineItems.map(it => it.str).join(" ");
      const line = normLine(rawLine);
      if (!line) continue;

      // header lines
      if (parseHeaderFromLine(line)) continue;

      const tokens = splitTokens(line);
      const chordTokens = tokens.filter(t => isChordToken(t));
      const chordCount = chordTokens.length;

      // If line has no chords: maybe title / section / ignore
      if (chordCount === 0){
        // candidate title line near top of doc
        if (!meta.title && line.length <= 80 && !line.includes(":") && !/^(page\s*\d+)/i.test(line)){
          meta.title = line;
          continue;
        }
        if (looksLikeSection(line, tokens, chordCount)){
          flushBars();
          let label = line;
          if (/^END([A-Z0-9\-]+)$/.test(line)){
            label = "End " + line.replace(/^END/i,"").replace(/_/g," ");
          }
          bodyLines.push(`- ${label}`);
          continue;
        }
        continue;
      }

      // chord line: build bars
      let bars = [];
      if (tokens.some(t => isBarToken(t))){
        let seg = [];
        for (const t of tokens){
          if (isBarToken(t)){
            if (seg.length){
              bars.push(seg.join("_"));
              seg = [];
            } else {
              // consecutive bars -> empty bar; skip
            }
            continue;
          }
          if (isChordToken(t)) seg.push(t);
        }
        if (seg.length) bars.push(seg.join("_"));
      } else {
        // No explicit bars: assume each chord is a bar
        bars = chordTokens.slice();
      }

      // Append bars
      for (const b of bars){
        if (!b) continue;
        pendingBars.push(b);
      }
    }
  }

  flushBars();

  // Apply normalization / validation to meta and sync UI
  const hdrText = [
    meta.title ? `Title: ${meta.title}` : "",
    meta.composer ? `Composer: ${meta.composer}` : "",
    meta.style ? `Style: ${meta.style}` : "",
    meta.tempo ? `Tempo: ${meta.tempo}` : "",
    meta.time ? `Time: ${meta.time}` : "",
    meta.key ? `Key: ${meta.key}` : ""
  ].filter(Boolean).join("\n");

  // This will sanitize and populate form fields.
  extractHeaderFromText(hdrText, true);

  const hdr = readHeaderInputs();
  let out = applyHeaderToText("", hdr);
  if (out && !out.endsWith("\n\n")) out += "\n\n";
  out += bodyLines.join("\n");

  const chordBars = bodyLines.join(" ").split(/\s+/).filter(t => isChordToken(t) || t.includes("_") || t === "%");
  statusEl.textContent = `PDF import: ${chordBars.length} bar(s) extracted from ${pdf.numPages} page(s).`;

  return out.trim();
}

// Convert barline-delimited text lines from UG/ChordSheet-like PDFs into CSMPN
function ugLinesToCSMPN(lines){
  const blocks = [];

  let title = '';
  let composer = '';
  let key = '';
  let time = '';
  let tempo = '';
  let style = '';

  const isHeaderLine = (ln) => /^(title|composer|artist|key|tempo|time|style)\s*:/i.test(ln);

  let sawAnyBars = false;

  // First pass: pull header-ish fields
  for (let raw of lines){
    const ln = (raw || '').replace(/\s+/g,' ').trim();
    if (!ln) continue;
    if (/^powered by/i.test(ln)) continue;

    if (!title && !ln.includes(':') && ln.length <= 60 && /^[A-Za-z0-9][A-Za-z0-9 '\-()]+$/.test(ln)){
      title = ln;
      continue;
    }
    if (/^composer\s*:/i.test(ln)) { composer = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^artist\s*:/i.test(ln))   { composer = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^key\s*:/i.test(ln))      { key = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^time\s*:/i.test(ln))     { time = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^tempo\s*:/i.test(ln))    { tempo = ln.split(':').slice(1).join(':').trim(); continue; }
    if (/^style\s*:/i.test(ln))    { style = ln.split(':').slice(1).join(':').trim(); continue; }
  }

  // Second pass: build blocks
  for (let raw of lines){
    let ln = (raw || '').replace(/\s+/g,' ').trim();
    if (!ln) continue;
    if (/^powered by/i.test(ln)) continue;
    if (isHeaderLine(ln)) continue;

    if (/[|ǁ‖∥]/.test(ln)){
      const hasChordLetters = /\b[A-G](?:#|b)?/.test(ln);
      if (!hasChordLetters){
        blocks.push(`- ${ln.replace(/^[\-:;=]\s*/,'')}`);
        continue;
      }

      sawAnyBars = true;
      const startsDouble = /^[ǁ‖∥]|^\|\|/.test(ln);

      // Normalize double barline chars
      ln = ln.replace(/^[ǁ‖∥]/,'||').trim();
      ln = ln.replace(/[ǁ‖∥]/g,'||');

      // Split measures on single barline char
      const measures = ln.split('|').map(x => x.trim()).filter(Boolean);

      const bars = [];
      if (startsDouble) bars.push('||');

      for (const m of measures){
        const parts = m.split(/\s+/).filter(Boolean);
        if (!parts.length) continue;
        bars.push(parts.length === 1 ? parts[0] : parts.join('_'));
      }

      if (bars.length){
        blocks.push(bars.join(' '));
      }
      continue;
    }

    // Non-barlined text: treat as section/annotation
    if (/^(intro|verse|chorus|bridge|pre-?chorus|tag|outro|turnaround|solo)/i.test(ln)){
      blocks.push(`- ${ln}`);
    } else {
      blocks.push(`; ${ln}`);
    }
  }

  if (!sawAnyBars) return '';

  const header = [];
  header.push(`Title: ${title || ''}`.trimEnd());
  header.push(`Composer: ${composer || ''}`.trimEnd());
  if (style) header.push(`Style: ${style}`);
  if (tempo) header.push(`Tempo: ${tempo}`);
  if (time) header.push(`Time: ${time}`);
  if (key) header.push(`Key: ${key}`);
  header.push('');

  return header.concat(blocks).join('\n');
}


/* =========================================================
   Export / Print / Copy
========================================================= */
document.getElementById('btnTransposeDown').addEventListener('click', () => doTranspose(-1));
document.getElementById('btnTransposeUp').addEventListener('click', () => doTranspose(1));
document.getElementById('btnTransposeReset').addEventListener('click', () => { currentTranspose = 0; updatePreview(); setStatus('Transpose reset.'); });

function doTranspose(delta){
  currentTranspose += delta;
  const tr = transposeWholeText(sourceEl.value, delta);
  sourceEl.value = tr;
  extractHeaderFromText(tr);
  updatePreview();
  setStatus(`Transposed ${currentTranspose >= 0 ? '+' : ''}${currentTranspose} semitone(s).`);
}

document.getElementById('btnPrint').addEventListener('click', () => {
  setStatus('Opening print dialog...');
  window.print();
});

/* =========================================================
   Q4 FIX: jsPDF Download Button for iOS One-Tap Export
========================================================= */
document.getElementById('btnDownloadPdf').addEventListener('click', async () => {
  try{
    document.body.classList.add('exporting');
    setStatus('Rendering PDF…');
    const canvas = await html2canvas(previewEl, {
      scale: 2,
      backgroundColor: '#ffffff',
      logging: false,
      useCORS: true
    });

    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;

    const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'letter' });
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 36; // 0.5 inch

    const imgProps = pdf.getImageProperties(imgData);
    const imgWidth = pageWidth - margin * 2;
    const imgHeight = (imgProps.height * imgWidth) / imgProps.width;

    let heightLeft = imgHeight;
    let position = margin;

    pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);

    heightLeft -= (pageHeight - margin * 2);
    while (heightLeft > 0){
      pdf.addPage();
      position = margin - (imgHeight - heightLeft);
      pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);
      heightLeft -= (pageHeight - margin * 2);
    }

    const filename = safeFilename(hdr.title.value?.trim() || 'chart') + '.pdf';
    const blob = pdf.output('blob');
    const file = new File([blob], filename, { type: 'application/pdf' });
    const shared = await tryShareFile(file);
    if(!shared) downloadBlob(blob, filename);
    setStatus(shared ? 'PDF ready (shared).' : 'PDF downloaded.');
  } catch (e){
    console.error(e);
    setStatus('PDF export failed: ' + (e?.message || e), 'error');
  }
});

document.getElementById('btnPng').addEventListener('click', async () => {
  try{
    document.body.classList.add('exporting');
    setStatus('Rendering PNG...');
    const canvas = await html2canvas(previewEl, {scale: 2, backgroundColor: '#ffffff'});
    const filename = safeFilename(hdr.title.value?.trim() || 'chordsheet') + '.png';

    await new Promise((resolve, reject) => {
      canvas.toBlob(async (blob) => {
        try{
          if(!blob) throw new Error('PNG blob is empty');
          const file = new File([blob], filename, { type: 'image/png' });
          const shared = await tryShareFile(file);
          if(!shared) downloadBlob(blob, filename);
          setStatus(shared ? 'PNG ready (shared).' : 'PNG downloaded.');
          resolve();
        }catch(e){
          reject(e);
        }
      }, 'image/png');
    });
  }catch(err){
    console.error(err);
    setStatus(`PNG export failed: ${err?.message || err}`, true);
  }finally{
    document.body.classList.remove('exporting');
  }
});


document.getElementById('btnCopy').addEventListener('click', async () => {
  try{
    await navigator.clipboard.writeText(sourceEl.value || '');
    setStatus('CSMPN copied to clipboard.');
  }catch(err){
    setStatus('Copy failed (clipboard permissions).', true);
  }
});

/* =========================================================
   Init
========================================================= */
sourceEl.value = `Title: Sin City Blues
Composer: Czemba
Style: Jazz swing
Tempo: 81
Time: 4/4
Key: Bb

- Verse
Bb % Eb7 %
F7 Bb % %

: Chorus
(Bb_Eb7 F7_Bb)x2

= Bridge
1. Gm7 C7 2. F7 Bb

- Solo Section
Bb Eb7 F7 Bb
Gm7 C7 F7 Bb
`;

extractHeaderFromText(sourceEl.value);
updatePreview();
setStatus('Ready. v1.6 - PDF import fixes applied.');

// --- Optional self-tests (run manually in console): window.runCSMPNSelfTests() ---
window.runCSMPNSelfTests = function(){
  const results = [];
  const assert = (name, cond) => results.push({ name, pass: !!cond });
  try{
    // Header extraction sanity
    const h = extractHeaderFromText("Title: Sin City Blues\nComposer: Czemba\nStyle: Swing\nTempo: 81\nTime: 4/4\nKey: Bb", false);
    assert("header.title", h.title === "Sin City Blues");
    assert("header.key", h.key === "Bb");
    assert("header.tempo", h.tempo === "81");

    // Reject chord-poisoned key
    const h2 = extractHeaderFromText("Key: G G7sus4", false);
    assert("reject chordy key", h2.key === "");

    // UG Pro normalization
    const n = normalizeUGProText("Bb7 | Eb7 | x2 x2\n(times two)\n");
    assert("normalize times two", n.includes("x2"));
    assert("dedupe x2", !/x2\s+x2/i.test(n));

    // Barline delimiter normalization
    const b = normalizeBarlineDelimiters("ǁ Bb7 | % |");
    assert("normalize unicode bars", b.includes("||"));

  }catch(e){
    results.push({ name: "exception", pass: false, error: e?.message || String(e) });
  }
  console.table(results);
  return results;
};

</script>
</body>
</html>
